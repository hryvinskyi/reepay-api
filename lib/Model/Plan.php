<?php
/**
 * Plan
 *
 * PHP version 5
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * API
 *
 * REST API to manage Reepay resources
 *
 * OpenAPI spec version: 1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.28
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Reepay\Model;

use \ArrayAccess;
use \Reepay\ObjectSerializer;

/**
 * Plan Class Doc Comment
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Plan implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'Plan';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'name' => 'string',
        'description' => 'string',
        'vat' => 'float',
        'amount' => 'int',
        'quantity' => 'int',
        'prepaid' => 'bool',
        'handle' => 'string',
        'version' => 'int',
        'state' => 'string',
        'currency' => 'string',
        'created' => '\DateTime',
        'dunningPlan' => 'string',
        'renewalReminderEmailDays' => 'int',
        'trialReminderEmailDays' => 'int',
        'partialPeriodHandling' => 'string',
        'includeZeroAmount' => 'bool',
        'setupFee' => 'int',
        'setupFeeText' => 'string',
        'setupFeeHandling' => 'string',
        'partialProrationDays' => 'bool',
        'fixedTrialDays' => 'bool',
        'minimumProratedAmount' => 'int',
        'amountInclVat' => 'bool',
        'fixedCount' => 'int',
        'fixedLifeTimeUnit' => 'string',
        'fixedLifeTimeLength' => 'int',
        'trialIntervalUnit' => 'string',
        'trialIntervalLength' => 'int',
        'intervalLength' => 'int',
        'scheduleType' => 'string',
        'scheduleFixedDay' => 'int',
        'baseMonth' => 'int',
        'noticePeriods' => 'int',
        'noticePeriodsAfterCurrent' => 'bool',
        'fixationPeriods' => 'int',
        'fixationPeriodsFull' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'name' => null,
        'description' => null,
        'vat' => 'float',
        'amount' => 'int32',
        'quantity' => 'int32',
        'prepaid' => null,
        'handle' => null,
        'version' => 'int32',
        'state' => null,
        'currency' => null,
        'created' => 'date-time',
        'dunningPlan' => null,
        'renewalReminderEmailDays' => 'int32',
        'trialReminderEmailDays' => 'int32',
        'partialPeriodHandling' => null,
        'includeZeroAmount' => null,
        'setupFee' => 'int32',
        'setupFeeText' => null,
        'setupFeeHandling' => null,
        'partialProrationDays' => null,
        'fixedTrialDays' => null,
        'minimumProratedAmount' => 'int32',
        'amountInclVat' => null,
        'fixedCount' => 'int32',
        'fixedLifeTimeUnit' => null,
        'fixedLifeTimeLength' => 'int32',
        'trialIntervalUnit' => null,
        'trialIntervalLength' => 'int32',
        'intervalLength' => 'int32',
        'scheduleType' => null,
        'scheduleFixedDay' => 'int32',
        'baseMonth' => 'int32',
        'noticePeriods' => 'int32',
        'noticePeriodsAfterCurrent' => null,
        'fixationPeriods' => 'int32',
        'fixationPeriodsFull' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'name' => 'name',
        'description' => 'description',
        'vat' => 'vat',
        'amount' => 'amount',
        'quantity' => 'quantity',
        'prepaid' => 'prepaid',
        'handle' => 'handle',
        'version' => 'version',
        'state' => 'state',
        'currency' => 'currency',
        'created' => 'created',
        'dunningPlan' => 'dunning_plan',
        'renewalReminderEmailDays' => 'renewal_reminder_email_days',
        'trialReminderEmailDays' => 'trial_reminder_email_days',
        'partialPeriodHandling' => 'partial_period_handling',
        'includeZeroAmount' => 'include_zero_amount',
        'setupFee' => 'setup_fee',
        'setupFeeText' => 'setup_fee_text',
        'setupFeeHandling' => 'setup_fee_handling',
        'partialProrationDays' => 'partial_proration_days',
        'fixedTrialDays' => 'fixed_trial_days',
        'minimumProratedAmount' => 'minimum_prorated_amount',
        'amountInclVat' => 'amount_incl_vat',
        'fixedCount' => 'fixed_count',
        'fixedLifeTimeUnit' => 'fixed_life_time_unit',
        'fixedLifeTimeLength' => 'fixed_life_time_length',
        'trialIntervalUnit' => 'trial_interval_unit',
        'trialIntervalLength' => 'trial_interval_length',
        'intervalLength' => 'interval_length',
        'scheduleType' => 'schedule_type',
        'scheduleFixedDay' => 'schedule_fixed_day',
        'baseMonth' => 'base_month',
        'noticePeriods' => 'notice_periods',
        'noticePeriodsAfterCurrent' => 'notice_periods_after_current',
        'fixationPeriods' => 'fixation_periods',
        'fixationPeriodsFull' => 'fixation_periods_full'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'name' => 'setName',
        'description' => 'setDescription',
        'vat' => 'setVat',
        'amount' => 'setAmount',
        'quantity' => 'setQuantity',
        'prepaid' => 'setPrepaid',
        'handle' => 'setHandle',
        'version' => 'setVersion',
        'state' => 'setState',
        'currency' => 'setCurrency',
        'created' => 'setCreated',
        'dunningPlan' => 'setDunningPlan',
        'renewalReminderEmailDays' => 'setRenewalReminderEmailDays',
        'trialReminderEmailDays' => 'setTrialReminderEmailDays',
        'partialPeriodHandling' => 'setPartialPeriodHandling',
        'includeZeroAmount' => 'setIncludeZeroAmount',
        'setupFee' => 'setSetupFee',
        'setupFeeText' => 'setSetupFeeText',
        'setupFeeHandling' => 'setSetupFeeHandling',
        'partialProrationDays' => 'setPartialProrationDays',
        'fixedTrialDays' => 'setFixedTrialDays',
        'minimumProratedAmount' => 'setMinimumProratedAmount',
        'amountInclVat' => 'setAmountInclVat',
        'fixedCount' => 'setFixedCount',
        'fixedLifeTimeUnit' => 'setFixedLifeTimeUnit',
        'fixedLifeTimeLength' => 'setFixedLifeTimeLength',
        'trialIntervalUnit' => 'setTrialIntervalUnit',
        'trialIntervalLength' => 'setTrialIntervalLength',
        'intervalLength' => 'setIntervalLength',
        'scheduleType' => 'setScheduleType',
        'scheduleFixedDay' => 'setScheduleFixedDay',
        'baseMonth' => 'setBaseMonth',
        'noticePeriods' => 'setNoticePeriods',
        'noticePeriodsAfterCurrent' => 'setNoticePeriodsAfterCurrent',
        'fixationPeriods' => 'setFixationPeriods',
        'fixationPeriodsFull' => 'setFixationPeriodsFull'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'name' => 'getName',
        'description' => 'getDescription',
        'vat' => 'getVat',
        'amount' => 'getAmount',
        'quantity' => 'getQuantity',
        'prepaid' => 'getPrepaid',
        'handle' => 'getHandle',
        'version' => 'getVersion',
        'state' => 'getState',
        'currency' => 'getCurrency',
        'created' => 'getCreated',
        'dunningPlan' => 'getDunningPlan',
        'renewalReminderEmailDays' => 'getRenewalReminderEmailDays',
        'trialReminderEmailDays' => 'getTrialReminderEmailDays',
        'partialPeriodHandling' => 'getPartialPeriodHandling',
        'includeZeroAmount' => 'getIncludeZeroAmount',
        'setupFee' => 'getSetupFee',
        'setupFeeText' => 'getSetupFeeText',
        'setupFeeHandling' => 'getSetupFeeHandling',
        'partialProrationDays' => 'getPartialProrationDays',
        'fixedTrialDays' => 'getFixedTrialDays',
        'minimumProratedAmount' => 'getMinimumProratedAmount',
        'amountInclVat' => 'getAmountInclVat',
        'fixedCount' => 'getFixedCount',
        'fixedLifeTimeUnit' => 'getFixedLifeTimeUnit',
        'fixedLifeTimeLength' => 'getFixedLifeTimeLength',
        'trialIntervalUnit' => 'getTrialIntervalUnit',
        'trialIntervalLength' => 'getTrialIntervalLength',
        'intervalLength' => 'getIntervalLength',
        'scheduleType' => 'getScheduleType',
        'scheduleFixedDay' => 'getScheduleFixedDay',
        'baseMonth' => 'getBaseMonth',
        'noticePeriods' => 'getNoticePeriods',
        'noticePeriodsAfterCurrent' => 'getNoticePeriodsAfterCurrent',
        'fixationPeriods' => 'getFixationPeriods',
        'fixationPeriodsFull' => 'getFixationPeriodsFull'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const STATE_ACTIVE = 'active';
    const STATE_SUPERSEDED = 'superseded';
    const STATE_DELETED = 'deleted';
    const PARTIAL_PERIOD_HANDLING_BILL_FULL = 'bill_full';
    const PARTIAL_PERIOD_HANDLING_BILL_PRORATED = 'bill_prorated';
    const PARTIAL_PERIOD_HANDLING_BILL_ZERO_AMOUNT = 'bill_zero_amount';
    const PARTIAL_PERIOD_HANDLING_NO_BILL = 'no_bill';
    const FIXED_LIFE_TIME_UNIT_MONTHS = 'months';
    const FIXED_LIFE_TIME_UNIT_DAYS = 'days';
    const TRIAL_INTERVAL_UNIT_MONTHS = 'months';
    const TRIAL_INTERVAL_UNIT_DAYS = 'days';
    const SCHEDULE_TYPE_MANUAL = 'manual';
    const SCHEDULE_TYPE_DAILY = 'daily';
    const SCHEDULE_TYPE_WEEKLY_FIXEDDAY = 'weekly_fixedday';
    const SCHEDULE_TYPE_MONTH_STARTDATE = 'month_startdate';
    const SCHEDULE_TYPE_MONTH_FIXEDDAY = 'month_fixedday';
    const SCHEDULE_TYPE_MONTH_LASTDAY = 'month_lastday';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStateAllowableValues()
    {
        return [
            self::STATE_ACTIVE,
            self::STATE_SUPERSEDED,
            self::STATE_DELETED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPartialPeriodHandlingAllowableValues()
    {
        return [
            self::PARTIAL_PERIOD_HANDLING_BILL_FULL,
            self::PARTIAL_PERIOD_HANDLING_BILL_PRORATED,
            self::PARTIAL_PERIOD_HANDLING_BILL_ZERO_AMOUNT,
            self::PARTIAL_PERIOD_HANDLING_NO_BILL,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFixedLifeTimeUnitAllowableValues()
    {
        return [
            self::FIXED_LIFE_TIME_UNIT_MONTHS,
            self::FIXED_LIFE_TIME_UNIT_DAYS,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTrialIntervalUnitAllowableValues()
    {
        return [
            self::TRIAL_INTERVAL_UNIT_MONTHS,
            self::TRIAL_INTERVAL_UNIT_DAYS,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getScheduleTypeAllowableValues()
    {
        return [
            self::SCHEDULE_TYPE_MANUAL,
            self::SCHEDULE_TYPE_DAILY,
            self::SCHEDULE_TYPE_WEEKLY_FIXEDDAY,
            self::SCHEDULE_TYPE_MONTH_STARTDATE,
            self::SCHEDULE_TYPE_MONTH_FIXEDDAY,
            self::SCHEDULE_TYPE_MONTH_LASTDAY,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['description'] = isset($data['description']) ? $data['description'] : null;
        $this->container['vat'] = isset($data['vat']) ? $data['vat'] : null;
        $this->container['amount'] = isset($data['amount']) ? $data['amount'] : null;
        $this->container['quantity'] = isset($data['quantity']) ? $data['quantity'] : null;
        $this->container['prepaid'] = isset($data['prepaid']) ? $data['prepaid'] : null;
        $this->container['handle'] = isset($data['handle']) ? $data['handle'] : null;
        $this->container['version'] = isset($data['version']) ? $data['version'] : null;
        $this->container['state'] = isset($data['state']) ? $data['state'] : null;
        $this->container['currency'] = isset($data['currency']) ? $data['currency'] : null;
        $this->container['created'] = isset($data['created']) ? $data['created'] : null;
        $this->container['dunningPlan'] = isset($data['dunningPlan']) ? $data['dunningPlan'] : null;
        $this->container['renewalReminderEmailDays'] = isset($data['renewalReminderEmailDays']) ? $data['renewalReminderEmailDays'] : null;
        $this->container['trialReminderEmailDays'] = isset($data['trialReminderEmailDays']) ? $data['trialReminderEmailDays'] : null;
        $this->container['partialPeriodHandling'] = isset($data['partialPeriodHandling']) ? $data['partialPeriodHandling'] : null;
        $this->container['includeZeroAmount'] = isset($data['includeZeroAmount']) ? $data['includeZeroAmount'] : null;
        $this->container['setupFee'] = isset($data['setupFee']) ? $data['setupFee'] : null;
        $this->container['setupFeeText'] = isset($data['setupFeeText']) ? $data['setupFeeText'] : null;
        $this->container['setupFeeHandling'] = isset($data['setupFeeHandling']) ? $data['setupFeeHandling'] : null;
        $this->container['partialProrationDays'] = isset($data['partialProrationDays']) ? $data['partialProrationDays'] : null;
        $this->container['fixedTrialDays'] = isset($data['fixedTrialDays']) ? $data['fixedTrialDays'] : null;
        $this->container['minimumProratedAmount'] = isset($data['minimumProratedAmount']) ? $data['minimumProratedAmount'] : null;
        $this->container['amountInclVat'] = isset($data['amountInclVat']) ? $data['amountInclVat'] : null;
        $this->container['fixedCount'] = isset($data['fixedCount']) ? $data['fixedCount'] : null;
        $this->container['fixedLifeTimeUnit'] = isset($data['fixedLifeTimeUnit']) ? $data['fixedLifeTimeUnit'] : null;
        $this->container['fixedLifeTimeLength'] = isset($data['fixedLifeTimeLength']) ? $data['fixedLifeTimeLength'] : null;
        $this->container['trialIntervalUnit'] = isset($data['trialIntervalUnit']) ? $data['trialIntervalUnit'] : null;
        $this->container['trialIntervalLength'] = isset($data['trialIntervalLength']) ? $data['trialIntervalLength'] : null;
        $this->container['intervalLength'] = isset($data['intervalLength']) ? $data['intervalLength'] : null;
        $this->container['scheduleType'] = isset($data['scheduleType']) ? $data['scheduleType'] : null;
        $this->container['scheduleFixedDay'] = isset($data['scheduleFixedDay']) ? $data['scheduleFixedDay'] : null;
        $this->container['baseMonth'] = isset($data['baseMonth']) ? $data['baseMonth'] : null;
        $this->container['noticePeriods'] = isset($data['noticePeriods']) ? $data['noticePeriods'] : null;
        $this->container['noticePeriodsAfterCurrent'] = isset($data['noticePeriodsAfterCurrent']) ? $data['noticePeriodsAfterCurrent'] : null;
        $this->container['fixationPeriods'] = isset($data['fixationPeriods']) ? $data['fixationPeriods'] : null;
        $this->container['fixationPeriodsFull'] = isset($data['fixationPeriodsFull']) ? $data['fixationPeriodsFull'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        if (!is_null($this->container['vat']) && ($this->container['vat'] > 1)) {
            $invalidProperties[] = "invalid value for 'vat', must be smaller than or equal to 1.";
        }

        if (!is_null($this->container['vat']) && ($this->container['vat'] < 0)) {
            $invalidProperties[] = "invalid value for 'vat', must be bigger than or equal to 0.";
        }

        if ($this->container['amount'] === null) {
            $invalidProperties[] = "'amount' can't be null";
        }
        if (($this->container['amount'] < 0)) {
            $invalidProperties[] = "invalid value for 'amount', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['quantity']) && ($this->container['quantity'] < 1)) {
            $invalidProperties[] = "invalid value for 'quantity', must be bigger than or equal to 1.";
        }

        if ($this->container['handle'] === null) {
            $invalidProperties[] = "'handle' can't be null";
        }
        if ($this->container['version'] === null) {
            $invalidProperties[] = "'version' can't be null";
        }
        if (($this->container['version'] < 1)) {
            $invalidProperties[] = "invalid value for 'version', must be bigger than or equal to 1.";
        }

        if ($this->container['state'] === null) {
            $invalidProperties[] = "'state' can't be null";
        }
        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($this->container['state']) && !in_array($this->container['state'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'state', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['currency'] === null) {
            $invalidProperties[] = "'currency' can't be null";
        }
        if ($this->container['created'] === null) {
            $invalidProperties[] = "'created' can't be null";
        }
        if (!is_null($this->container['renewalReminderEmailDays']) && ($this->container['renewalReminderEmailDays'] < 1)) {
            $invalidProperties[] = "invalid value for 'renewalReminderEmailDays', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['trialReminderEmailDays']) && ($this->container['trialReminderEmailDays'] < 1)) {
            $invalidProperties[] = "invalid value for 'trialReminderEmailDays', must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getPartialPeriodHandlingAllowableValues();
        if (!is_null($this->container['partialPeriodHandling']) && !in_array($this->container['partialPeriodHandling'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'partialPeriodHandling', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['setupFee']) && ($this->container['setupFee'] < 0)) {
            $invalidProperties[] = "invalid value for 'setupFee', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['minimumProratedAmount']) && ($this->container['minimumProratedAmount'] < 0)) {
            $invalidProperties[] = "invalid value for 'minimumProratedAmount', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['fixedCount']) && ($this->container['fixedCount'] < 1)) {
            $invalidProperties[] = "invalid value for 'fixedCount', must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getFixedLifeTimeUnitAllowableValues();
        if (!is_null($this->container['fixedLifeTimeUnit']) && !in_array($this->container['fixedLifeTimeUnit'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'fixedLifeTimeUnit', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['fixedLifeTimeLength']) && ($this->container['fixedLifeTimeLength'] < 1)) {
            $invalidProperties[] = "invalid value for 'fixedLifeTimeLength', must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getTrialIntervalUnitAllowableValues();
        if (!is_null($this->container['trialIntervalUnit']) && !in_array($this->container['trialIntervalUnit'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'trialIntervalUnit', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['trialIntervalLength']) && ($this->container['trialIntervalLength'] < 1)) {
            $invalidProperties[] = "invalid value for 'trialIntervalLength', must be bigger than or equal to 1.";
        }

        if ($this->container['intervalLength'] === null) {
            $invalidProperties[] = "'intervalLength' can't be null";
        }
        if (($this->container['intervalLength'] < 1)) {
            $invalidProperties[] = "invalid value for 'intervalLength', must be bigger than or equal to 1.";
        }

        if ($this->container['scheduleType'] === null) {
            $invalidProperties[] = "'scheduleType' can't be null";
        }
        $allowedValues = $this->getScheduleTypeAllowableValues();
        if (!is_null($this->container['scheduleType']) && !in_array($this->container['scheduleType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'scheduleType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['scheduleFixedDay']) && ($this->container['scheduleFixedDay'] > 28)) {
            $invalidProperties[] = "invalid value for 'scheduleFixedDay', must be smaller than or equal to 28.";
        }

        if (!is_null($this->container['scheduleFixedDay']) && ($this->container['scheduleFixedDay'] < 1)) {
            $invalidProperties[] = "invalid value for 'scheduleFixedDay', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['baseMonth']) && ($this->container['baseMonth'] > 12)) {
            $invalidProperties[] = "invalid value for 'baseMonth', must be smaller than or equal to 12.";
        }

        if (!is_null($this->container['baseMonth']) && ($this->container['baseMonth'] < 1)) {
            $invalidProperties[] = "invalid value for 'baseMonth', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['noticePeriods']) && ($this->container['noticePeriods'] < 0)) {
            $invalidProperties[] = "invalid value for 'noticePeriods', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['fixationPeriods']) && ($this->container['fixationPeriods'] < 0)) {
            $invalidProperties[] = "invalid value for 'fixationPeriods', must be bigger than or equal to 0.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name Name of the plan
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string $description Description of the plan
     *
     * @return $this
     */
    public function setDescription($description)
    {
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets vat
     *
     * @return float
     */
    public function getVat()
    {
        return $this->container['vat'];
    }

    /**
     * Sets vat
     *
     * @param float $vat Optional vat for this plan. Account default is used if none given.
     *
     * @return $this
     */
    public function setVat($vat)
    {

        if (!is_null($vat) && ($vat > 1)) {
            throw new \InvalidArgumentException('invalid value for $vat when calling Plan., must be smaller than or equal to 1.');
        }
        if (!is_null($vat) && ($vat < 0)) {
            throw new \InvalidArgumentException('invalid value for $vat when calling Plan., must be bigger than or equal to 0.');
        }

        $this->container['vat'] = $vat;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return int
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param int $amount Amount for the plan in the smallest unit for the account currency
     *
     * @return $this
     */
    public function setAmount($amount)
    {

        if (($amount < 0)) {
            throw new \InvalidArgumentException('invalid value for $amount when calling Plan., must be bigger than or equal to 0.');
        }

        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets quantity
     *
     * @return int
     */
    public function getQuantity()
    {
        return $this->container['quantity'];
    }

    /**
     * Sets quantity
     *
     * @param int $quantity Optional default quantity of the subscription plan product for new subscriptions. Default is 1.
     *
     * @return $this
     */
    public function setQuantity($quantity)
    {

        if (!is_null($quantity) && ($quantity < 1)) {
            throw new \InvalidArgumentException('invalid value for $quantity when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['quantity'] = $quantity;

        return $this;
    }

    /**
     * Gets prepaid
     *
     * @return bool
     */
    public function getPrepaid()
    {
        return $this->container['prepaid'];
    }

    /**
     * Sets prepaid
     *
     * @param bool $prepaid Subscriptions can either be prepaid where an amount is paid in advance, or the opposite. This setting only relates to handling of pause scenarios.
     *
     * @return $this
     */
    public function setPrepaid($prepaid)
    {
        $this->container['prepaid'] = $prepaid;

        return $this;
    }

    /**
     * Gets handle
     *
     * @return string
     */
    public function getHandle()
    {
        return $this->container['handle'];
    }

    /**
     * Sets handle
     *
     * @param string $handle Per account unique handle for the subscription plan. Max length 255 with allowable characters [a-zA-Z0-9_.-@].
     *
     * @return $this
     */
    public function setHandle($handle)
    {
        $this->container['handle'] = $handle;

        return $this;
    }

    /**
     * Gets version
     *
     * @return int
     */
    public function getVersion()
    {
        return $this->container['version'];
    }

    /**
     * Sets version
     *
     * @param int $version Plan version
     *
     * @return $this
     */
    public function setVersion($version)
    {

        if (($version < 1)) {
            throw new \InvalidArgumentException('invalid value for $version when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['version'] = $version;

        return $this;
    }

    /**
     * Gets state
     *
     * @return string
     */
    public function getState()
    {
        return $this->container['state'];
    }

    /**
     * Sets state
     *
     * @param string $state State of the subscription plan one of the following: `active`, `superseded`, `deleted`
     *
     * @return $this
     */
    public function setState($state)
    {
        $allowedValues = $this->getStateAllowableValues();
        if (!in_array($state, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'state', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['state'] = $state;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string $currency Currency for the subscription plan in [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) three letter alpha code
     *
     * @return $this
     */
    public function setCurrency($currency)
    {
        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets created
     *
     * @return \DateTime
     */
    public function getCreated()
    {
        return $this->container['created'];
    }

    /**
     * Sets created
     *
     * @param \DateTime $created Date when the subscripton plan was created. In ISO-8601 extended offset date-time format.
     *
     * @return $this
     */
    public function setCreated($created)
    {
        $this->container['created'] = $created;

        return $this;
    }

    /**
     * Gets dunningPlan
     *
     * @return string
     */
    public function getDunningPlan()
    {
        return $this->container['dunningPlan'];
    }

    /**
     * Sets dunningPlan
     *
     * @param string $dunningPlan Dunning plan handle
     *
     * @return $this
     */
    public function setDunningPlan($dunningPlan)
    {
        $this->container['dunningPlan'] = $dunningPlan;

        return $this;
    }

    /**
     * Gets renewalReminderEmailDays
     *
     * @return int
     */
    public function getRenewalReminderEmailDays()
    {
        return $this->container['renewalReminderEmailDays'];
    }

    /**
     * Sets renewalReminderEmailDays
     *
     * @param int $renewalReminderEmailDays Optional renewal reminder email settings. Number of days before next billing to send a reminder email.
     *
     * @return $this
     */
    public function setRenewalReminderEmailDays($renewalReminderEmailDays)
    {

        if (!is_null($renewalReminderEmailDays) && ($renewalReminderEmailDays < 1)) {
            throw new \InvalidArgumentException('invalid value for $renewalReminderEmailDays when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['renewalReminderEmailDays'] = $renewalReminderEmailDays;

        return $this;
    }

    /**
     * Gets trialReminderEmailDays
     *
     * @return int
     */
    public function getTrialReminderEmailDays()
    {
        return $this->container['trialReminderEmailDays'];
    }

    /**
     * Sets trialReminderEmailDays
     *
     * @param int $trialReminderEmailDays Optional end of trial reminder email settings. Number of days before end of trial to send a reminder email.
     *
     * @return $this
     */
    public function setTrialReminderEmailDays($trialReminderEmailDays)
    {

        if (!is_null($trialReminderEmailDays) && ($trialReminderEmailDays < 1)) {
            throw new \InvalidArgumentException('invalid value for $trialReminderEmailDays when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['trialReminderEmailDays'] = $trialReminderEmailDays;

        return $this;
    }

    /**
     * Gets partialPeriodHandling
     *
     * @return string
     */
    public function getPartialPeriodHandling()
    {
        return $this->container['partialPeriodHandling'];
    }

    /**
     * Sets partialPeriodHandling
     *
     * @param string $partialPeriodHandling How to handle a potential initial partial billing period for fixed day scheduling. The options are to bill for a full period, bill prorated for the partial period, bill a zero amoumt, or not to consider the period before first fixed day a billing period. The default is to bill prorated. Options: `bill_full`, `bill_prorated`, `bill_zero_amount`, `no_bill`.
     *
     * @return $this
     */
    public function setPartialPeriodHandling($partialPeriodHandling)
    {
        $allowedValues = $this->getPartialPeriodHandlingAllowableValues();
        if (!is_null($partialPeriodHandling) && !in_array($partialPeriodHandling, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'partialPeriodHandling', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['partialPeriodHandling'] = $partialPeriodHandling;

        return $this;
    }

    /**
     * Gets includeZeroAmount
     *
     * @return bool
     */
    public function getIncludeZeroAmount()
    {
        return $this->container['includeZeroAmount'];
    }

    /**
     * Sets includeZeroAmount
     *
     * @param bool $includeZeroAmount Whether to add a zero amount order line to subscription invoices if plan amount is zero or the subscription overrides to zero amount. The default is to not include the line. If no other order lines are present the plan order line will be added.
     *
     * @return $this
     */
    public function setIncludeZeroAmount($includeZeroAmount)
    {
        $this->container['includeZeroAmount'] = $includeZeroAmount;

        return $this;
    }

    /**
     * Gets setupFee
     *
     * @return int
     */
    public function getSetupFee()
    {
        return $this->container['setupFee'];
    }

    /**
     * Sets setupFee
     *
     * @param int $setupFee Optional one-time setup fee billed with the first invoice or as a separate invoice depending on the setting `setup_fee_handling`.
     *
     * @return $this
     */
    public function setSetupFee($setupFee)
    {

        if (!is_null($setupFee) && ($setupFee < 0)) {
            throw new \InvalidArgumentException('invalid value for $setupFee when calling Plan., must be bigger than or equal to 0.');
        }

        $this->container['setupFee'] = $setupFee;

        return $this;
    }

    /**
     * Gets setupFeeText
     *
     * @return string
     */
    public function getSetupFeeText()
    {
        return $this->container['setupFeeText'];
    }

    /**
     * Sets setupFeeText
     *
     * @param string $setupFeeText Optional invoice order text for the setup fee that
     *
     * @return $this
     */
    public function setSetupFeeText($setupFeeText)
    {
        $this->container['setupFeeText'] = $setupFeeText;

        return $this;
    }

    /**
     * Gets setupFeeHandling
     *
     * @return string
     */
    public function getSetupFeeHandling()
    {
        return $this->container['setupFeeHandling'];
    }

    /**
     * Sets setupFeeHandling
     *
     * @param string $setupFeeHandling How the billing of the setup fee should be done. The options are: `first` - include setup fee as order line on the first scheduled invoice. `separate` - create a separate invoice for the setup fee, is appropriate if first invoice is not in conjunction with creation. `separate_conditional` - create a separate invoice for setup fee if the first invoice is not created in conjunction with the creation. Default is `first`.
     *
     * @return $this
     */
    public function setSetupFeeHandling($setupFeeHandling)
    {
        $this->container['setupFeeHandling'] = $setupFeeHandling;

        return $this;
    }

    /**
     * Gets partialProrationDays
     *
     * @return bool
     */
    public function getPartialProrationDays()
    {
        return $this->container['partialProrationDays'];
    }

    /**
     * Sets partialProrationDays
     *
     * @param bool $partialProrationDays For fixed day scheduling and prorated partial handling calculate prorated amount using whole days counting start day as a full day, or use by the minute proration calculation from start date time to the next period start. Default is true (whole days).
     *
     * @return $this
     */
    public function setPartialProrationDays($partialProrationDays)
    {
        $this->container['partialProrationDays'] = $partialProrationDays;

        return $this;
    }

    /**
     * Gets fixedTrialDays
     *
     * @return bool
     */
    public function getFixedTrialDays()
    {
        return $this->container['fixedTrialDays'];
    }

    /**
     * Sets fixedTrialDays
     *
     * @param bool $fixedTrialDays When using trial for fixed day scheduling use this setting to control if trial expires at midnight or the trial period is down to the minute. Default is true (trial until start of day). Trial in days can only be true if `partial_proration_days` is also set to true.
     *
     * @return $this
     */
    public function setFixedTrialDays($fixedTrialDays)
    {
        $this->container['fixedTrialDays'] = $fixedTrialDays;

        return $this;
    }

    /**
     * Gets minimumProratedAmount
     *
     * @return int
     */
    public function getMinimumProratedAmount()
    {
        return $this->container['minimumProratedAmount'];
    }

    /**
     * Sets minimumProratedAmount
     *
     * @param int $minimumProratedAmount When using prorated partial handling the prorated amount for plan and add-ons might result in very small amounts. A minimum prorated amount for plan and add-ons can be defined. If the prorated amount is below this minimum the amount will be changed to zero.
     *
     * @return $this
     */
    public function setMinimumProratedAmount($minimumProratedAmount)
    {

        if (!is_null($minimumProratedAmount) && ($minimumProratedAmount < 0)) {
            throw new \InvalidArgumentException('invalid value for $minimumProratedAmount when calling Plan., must be bigger than or equal to 0.');
        }

        $this->container['minimumProratedAmount'] = $minimumProratedAmount;

        return $this;
    }

    /**
     * Gets amountInclVat
     *
     * @return bool
     */
    public function getAmountInclVat()
    {
        return $this->container['amountInclVat'];
    }

    /**
     * Sets amountInclVat
     *
     * @param bool $amountInclVat Whether the amount is including VAT. Default true.
     *
     * @return $this
     */
    public function setAmountInclVat($amountInclVat)
    {
        $this->container['amountInclVat'] = $amountInclVat;

        return $this;
    }

    /**
     * Gets fixedCount
     *
     * @return int
     */
    public function getFixedCount()
    {
        return $this->container['fixedCount'];
    }

    /**
     * Sets fixedCount
     *
     * @param int $fixedCount Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices.
     *
     * @return $this
     */
    public function setFixedCount($fixedCount)
    {

        if (!is_null($fixedCount) && ($fixedCount < 1)) {
            throw new \InvalidArgumentException('invalid value for $fixedCount when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['fixedCount'] = $fixedCount;

        return $this;
    }

    /**
     * Gets fixedLifeTimeUnit
     *
     * @return string
     */
    public function getFixedLifeTimeUnit()
    {
        return $this->container['fixedLifeTimeUnit'];
    }

    /**
     * Sets fixedLifeTimeUnit
     *
     * @param string $fixedLifeTimeUnit Time unit use for fixed life time
     *
     * @return $this
     */
    public function setFixedLifeTimeUnit($fixedLifeTimeUnit)
    {
        $allowedValues = $this->getFixedLifeTimeUnitAllowableValues();
        if (!is_null($fixedLifeTimeUnit) && !in_array($fixedLifeTimeUnit, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'fixedLifeTimeUnit', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['fixedLifeTimeUnit'] = $fixedLifeTimeUnit;

        return $this;
    }

    /**
     * Gets fixedLifeTimeLength
     *
     * @return int
     */
    public function getFixedLifeTimeLength()
    {
        return $this->container['fixedLifeTimeLength'];
    }

    /**
     * Sets fixedLifeTimeLength
     *
     * @param int $fixedLifeTimeLength Fixed life time length for subscriptions using this plan. E.g. 12 months. Subscriptions will cancel after the fixed life time and expire when the active billing cycle ends.
     *
     * @return $this
     */
    public function setFixedLifeTimeLength($fixedLifeTimeLength)
    {

        if (!is_null($fixedLifeTimeLength) && ($fixedLifeTimeLength < 1)) {
            throw new \InvalidArgumentException('invalid value for $fixedLifeTimeLength when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['fixedLifeTimeLength'] = $fixedLifeTimeLength;

        return $this;
    }

    /**
     * Gets trialIntervalUnit
     *
     * @return string
     */
    public function getTrialIntervalUnit()
    {
        return $this->container['trialIntervalUnit'];
    }

    /**
     * Sets trialIntervalUnit
     *
     * @param string $trialIntervalUnit Time unit for free trial period
     *
     * @return $this
     */
    public function setTrialIntervalUnit($trialIntervalUnit)
    {
        $allowedValues = $this->getTrialIntervalUnitAllowableValues();
        if (!is_null($trialIntervalUnit) && !in_array($trialIntervalUnit, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'trialIntervalUnit', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['trialIntervalUnit'] = $trialIntervalUnit;

        return $this;
    }

    /**
     * Gets trialIntervalLength
     *
     * @return int
     */
    public function getTrialIntervalLength()
    {
        return $this->container['trialIntervalLength'];
    }

    /**
     * Sets trialIntervalLength
     *
     * @param int $trialIntervalLength Free trial interval length. E.g. 1 month.
     *
     * @return $this
     */
    public function setTrialIntervalLength($trialIntervalLength)
    {

        if (!is_null($trialIntervalLength) && ($trialIntervalLength < 1)) {
            throw new \InvalidArgumentException('invalid value for $trialIntervalLength when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['trialIntervalLength'] = $trialIntervalLength;

        return $this;
    }

    /**
     * Gets intervalLength
     *
     * @return int
     */
    public function getIntervalLength()
    {
        return $this->container['intervalLength'];
    }

    /**
     * Sets intervalLength
     *
     * @param int $intervalLength The length of intervals. E.g. every second month or every 14 days.
     *
     * @return $this
     */
    public function setIntervalLength($intervalLength)
    {

        if (($intervalLength < 1)) {
            throw new \InvalidArgumentException('invalid value for $intervalLength when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['intervalLength'] = $intervalLength;

        return $this;
    }

    /**
     * Gets scheduleType
     *
     * @return string
     */
    public function getScheduleType()
    {
        return $this->container['scheduleType'];
    }

    /**
     * Sets scheduleType
     *
     * @param string $scheduleType Scheduling type, one of the following: `manual`, `daily`, `weekly_fixedday`, `month_startdate`, `month_fixedday`, `month_lastday`. See documentation for descriptions of the different types.
     *
     * @return $this
     */
    public function setScheduleType($scheduleType)
    {
        $allowedValues = $this->getScheduleTypeAllowableValues();
        if (!in_array($scheduleType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'scheduleType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['scheduleType'] = $scheduleType;

        return $this;
    }

    /**
     * Gets scheduleFixedDay
     *
     * @return int
     */
    public function getScheduleFixedDay()
    {
        return $this->container['scheduleFixedDay'];
    }

    /**
     * Sets scheduleFixedDay
     *
     * @param int $scheduleFixedDay If a fixed day scheduling type is used a fixed day must be provided. For months the allowed value is 1-28 for weeks it is 1-7
     *
     * @return $this
     */
    public function setScheduleFixedDay($scheduleFixedDay)
    {

        if (!is_null($scheduleFixedDay) && ($scheduleFixedDay > 28)) {
            throw new \InvalidArgumentException('invalid value for $scheduleFixedDay when calling Plan., must be smaller than or equal to 28.');
        }
        if (!is_null($scheduleFixedDay) && ($scheduleFixedDay < 1)) {
            throw new \InvalidArgumentException('invalid value for $scheduleFixedDay when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['scheduleFixedDay'] = $scheduleFixedDay;

        return $this;
    }

    /**
     * Gets baseMonth
     *
     * @return int
     */
    public function getBaseMonth()
    {
        return $this->container['baseMonth'];
    }

    /**
     * Sets baseMonth
     *
     * @param int $baseMonth For fixed month schedule types the base month can be used to control which months are eligible for start of first billing period. The eligible months are calculated as `base_month + k * interval_length` up to 12. E.g. to use quaterly billing in the months jan-apr-jul-oct, `base_month` 1 and `interval_length` 3 can be used. If not defined the first fixed day will be used as start of first billing period.
     *
     * @return $this
     */
    public function setBaseMonth($baseMonth)
    {

        if (!is_null($baseMonth) && ($baseMonth > 12)) {
            throw new \InvalidArgumentException('invalid value for $baseMonth when calling Plan., must be smaller than or equal to 12.');
        }
        if (!is_null($baseMonth) && ($baseMonth < 1)) {
            throw new \InvalidArgumentException('invalid value for $baseMonth when calling Plan., must be bigger than or equal to 1.');
        }

        $this->container['baseMonth'] = $baseMonth;

        return $this;
    }

    /**
     * Gets noticePeriods
     *
     * @return int
     */
    public function getNoticePeriods()
    {
        return $this->container['noticePeriods'];
    }

    /**
     * Sets noticePeriods
     *
     * @param int $noticePeriods Optional number of notice periods for a cancel. The subscription will be cancelled for this number of full periods before expiring. Either from the cancellation date, or from the end of the the current period. See `notice_periods_after_current`. The default is to expire at the end of current period (0). A value of 1 (and `notice_periods_after_current` set to true) will for example result in a scenario where the subscription is cancelled until the end of current period, and then for the full subsequent period before expiring.
     *
     * @return $this
     */
    public function setNoticePeriods($noticePeriods)
    {

        if (!is_null($noticePeriods) && ($noticePeriods < 0)) {
            throw new \InvalidArgumentException('invalid value for $noticePeriods when calling Plan., must be bigger than or equal to 0.');
        }

        $this->container['noticePeriods'] = $noticePeriods;

        return $this;
    }

    /**
     * Gets noticePeriodsAfterCurrent
     *
     * @return bool
     */
    public function getNoticePeriodsAfterCurrent()
    {
        return $this->container['noticePeriodsAfterCurrent'];
    }

    /**
     * Sets noticePeriodsAfterCurrent
     *
     * @param bool $noticePeriodsAfterCurrent If notice periods is set, this option controls whether the number of full notice periods should start at the end of the current period, or run from cancellation date and result in a partial period with partial amount for the last period. The default is true. E.g. if set to false and `notice_periods = 1` then the subscription will be cancelled for exactly for one period from the cancellation time and a partial amount will be billed at the start of the next billing period.
     *
     * @return $this
     */
    public function setNoticePeriodsAfterCurrent($noticePeriodsAfterCurrent)
    {
        $this->container['noticePeriodsAfterCurrent'] = $noticePeriodsAfterCurrent;

        return $this;
    }

    /**
     * Gets fixationPeriods
     *
     * @return int
     */
    public function getFixationPeriods()
    {
        return $this->container['fixationPeriods'];
    }

    /**
     * Sets fixationPeriods
     *
     * @param int $fixationPeriods Optional number of fixation periods. Fixation periods will guarantee that a subscription will have this number of paid full periods before expiring after a cancel. Default is to have no requirement (0).
     *
     * @return $this
     */
    public function setFixationPeriods($fixationPeriods)
    {

        if (!is_null($fixationPeriods) && ($fixationPeriods < 0)) {
            throw new \InvalidArgumentException('invalid value for $fixationPeriods when calling Plan., must be bigger than or equal to 0.');
        }

        $this->container['fixationPeriods'] = $fixationPeriods;

        return $this;
    }

    /**
     * Gets fixationPeriodsFull
     *
     * @return bool
     */
    public function getFixationPeriodsFull()
    {
        return $this->container['fixationPeriodsFull'];
    }

    /**
     * Sets fixationPeriodsFull
     *
     * @param bool $fixationPeriodsFull If fixation periods are defined, and the subscription can have a partial prorated first period, this parameter controls if the the last period should be full, or partial to give exactly `fixation_periods` paid periods. Default is false.
     *
     * @return $this
     */
    public function setFixationPeriodsFull($fixationPeriodsFull)
    {
        $this->container['fixationPeriodsFull'] = $fixationPeriodsFull;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


