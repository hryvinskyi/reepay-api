<?php
/**
 * PaymentMethodV2
 *
 * PHP version 5
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * API
 *
 * REST API to manage Reepay resources
 *
 * OpenAPI spec version: 1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.28
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Reepay\Model;

use \ArrayAccess;
use \Reepay\ObjectSerializer;

/**
 * PaymentMethodV2 Class Doc Comment
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PaymentMethodV2 implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'PaymentMethodV2';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'id' => 'string',
        'state' => 'string',
        'customer' => 'string',
        'reference' => 'string',
        'failed' => '\DateTime',
        'created' => '\DateTime',
        'card' => '\Reepay\Model\CardV2',
        'applepay' => '\Reepay\Model\CardV2',
        'paymentType' => 'string',
        'mpsSubscription' => '\Reepay\Model\MpsSubscriptionV2',
        'vippsRecurringSubscription' => '\Reepay\Model\VippsRecurringSubscriptionDto'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'id' => null,
        'state' => null,
        'customer' => null,
        'reference' => null,
        'failed' => 'date-time',
        'created' => 'date-time',
        'card' => null,
        'applepay' => null,
        'paymentType' => null,
        'mpsSubscription' => null,
        'vippsRecurringSubscription' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'state' => 'state',
        'customer' => 'customer',
        'reference' => 'reference',
        'failed' => 'failed',
        'created' => 'created',
        'card' => 'card',
        'applepay' => 'applepay',
        'paymentType' => 'payment_type',
        'mpsSubscription' => 'mps_subscription',
        'vippsRecurringSubscription' => 'vipps_recurring_subscription'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'state' => 'setState',
        'customer' => 'setCustomer',
        'reference' => 'setReference',
        'failed' => 'setFailed',
        'created' => 'setCreated',
        'card' => 'setCard',
        'applepay' => 'setApplepay',
        'paymentType' => 'setPaymentType',
        'mpsSubscription' => 'setMpsSubscription',
        'vippsRecurringSubscription' => 'setVippsRecurringSubscription'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'state' => 'getState',
        'customer' => 'getCustomer',
        'reference' => 'getReference',
        'failed' => 'getFailed',
        'created' => 'getCreated',
        'card' => 'getCard',
        'applepay' => 'getApplepay',
        'paymentType' => 'getPaymentType',
        'mpsSubscription' => 'getMpsSubscription',
        'vippsRecurringSubscription' => 'getVippsRecurringSubscription'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const STATE_ACTIVE = 'active';
    const STATE_INACTIVATED = 'inactivated';
    const STATE_FAILED = 'failed';
    const STATE_PENDING = 'pending';
    const STATE_DELETED = 'deleted';
    const PAYMENT_TYPE_CARD = 'card';
    const PAYMENT_TYPE_MOBILEPAY = 'mobilepay';
    const PAYMENT_TYPE_VIPPS = 'vipps';
    const PAYMENT_TYPE_SWISH = 'swish';
    const PAYMENT_TYPE_VIABILL = 'viabill';
    const PAYMENT_TYPE_MANUAL = 'manual';
    const PAYMENT_TYPE_APPLEPAY = 'applepay';
    const PAYMENT_TYPE_GOOGLEPAY = 'googlepay';
    const PAYMENT_TYPE_PAYPAL = 'paypal';
    const PAYMENT_TYPE_KLARNA_PAY_NOW = 'klarna_pay_now';
    const PAYMENT_TYPE_KLARNA_PAY_LATER = 'klarna_pay_later';
    const PAYMENT_TYPE_KLARNA_SLICE_IT = 'klarna_slice_it';
    const PAYMENT_TYPE_KLARNA_DIRECT_BANK_TRANSFER = 'klarna_direct_bank_transfer';
    const PAYMENT_TYPE_KLARNA_DIRECT_DEBIT = 'klarna_direct_debit';
    const PAYMENT_TYPE_RESURS = 'resurs';
    const PAYMENT_TYPE_MOBILEPAY_SUBSCRIPTIONS = 'mobilepay_subscriptions';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStateAllowableValues()
    {
        return [
            self::STATE_ACTIVE,
            self::STATE_INACTIVATED,
            self::STATE_FAILED,
            self::STATE_PENDING,
            self::STATE_DELETED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPaymentTypeAllowableValues()
    {
        return [
            self::PAYMENT_TYPE_CARD,
            self::PAYMENT_TYPE_MOBILEPAY,
            self::PAYMENT_TYPE_VIPPS,
            self::PAYMENT_TYPE_SWISH,
            self::PAYMENT_TYPE_VIABILL,
            self::PAYMENT_TYPE_MANUAL,
            self::PAYMENT_TYPE_APPLEPAY,
            self::PAYMENT_TYPE_GOOGLEPAY,
            self::PAYMENT_TYPE_PAYPAL,
            self::PAYMENT_TYPE_KLARNA_PAY_NOW,
            self::PAYMENT_TYPE_KLARNA_PAY_LATER,
            self::PAYMENT_TYPE_KLARNA_SLICE_IT,
            self::PAYMENT_TYPE_KLARNA_DIRECT_BANK_TRANSFER,
            self::PAYMENT_TYPE_KLARNA_DIRECT_DEBIT,
            self::PAYMENT_TYPE_RESURS,
            self::PAYMENT_TYPE_MOBILEPAY_SUBSCRIPTIONS,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['state'] = isset($data['state']) ? $data['state'] : null;
        $this->container['customer'] = isset($data['customer']) ? $data['customer'] : null;
        $this->container['reference'] = isset($data['reference']) ? $data['reference'] : null;
        $this->container['failed'] = isset($data['failed']) ? $data['failed'] : null;
        $this->container['created'] = isset($data['created']) ? $data['created'] : null;
        $this->container['card'] = isset($data['card']) ? $data['card'] : null;
        $this->container['applepay'] = isset($data['applepay']) ? $data['applepay'] : null;
        $this->container['paymentType'] = isset($data['paymentType']) ? $data['paymentType'] : null;
        $this->container['mpsSubscription'] = isset($data['mpsSubscription']) ? $data['mpsSubscription'] : null;
        $this->container['vippsRecurringSubscription'] = isset($data['vippsRecurringSubscription']) ? $data['vippsRecurringSubscription'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['id'] === null) {
            $invalidProperties[] = "'id' can't be null";
        }
        if ($this->container['state'] === null) {
            $invalidProperties[] = "'state' can't be null";
        }
        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($this->container['state']) && !in_array($this->container['state'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'state', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['customer'] === null) {
            $invalidProperties[] = "'customer' can't be null";
        }
        if ($this->container['created'] === null) {
            $invalidProperties[] = "'created' can't be null";
        }
        if ($this->container['paymentType'] === null) {
            $invalidProperties[] = "'paymentType' can't be null";
        }
        $allowedValues = $this->getPaymentTypeAllowableValues();
        if (!is_null($this->container['paymentType']) && !in_array($this->container['paymentType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'paymentType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id Unique id for payment method
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets state
     *
     * @return string
     */
    public function getState()
    {
        return $this->container['state'];
    }

    /**
     * Sets state
     *
     * @param string $state State of the payment method: `active`, `inactivated`, `failed`, `pending` or `deleted`
     *
     * @return $this
     */
    public function setState($state)
    {
        $allowedValues = $this->getStateAllowableValues();
        if (!in_array($state, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'state', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['state'] = $state;

        return $this;
    }

    /**
     * Gets customer
     *
     * @return string
     */
    public function getCustomer()
    {
        return $this->container['customer'];
    }

    /**
     * Sets customer
     *
     * @param string $customer Customer by handle
     *
     * @return $this
     */
    public function setCustomer($customer)
    {
        $this->container['customer'] = $customer;

        return $this;
    }

    /**
     * Gets reference
     *
     * @return string
     */
    public function getReference()
    {
        return $this->container['reference'];
    }

    /**
     * Sets reference
     *
     * @param string $reference Optional reference provided when creating the payment method. For payment methods created with Reepay Checkout the reference will correspond to the session id for the Checkout session that created the payment method.
     *
     * @return $this
     */
    public function setReference($reference)
    {
        $this->container['reference'] = $reference;

        return $this;
    }

    /**
     * Gets failed
     *
     * @return \DateTime
     */
    public function getFailed()
    {
        return $this->container['failed'];
    }

    /**
     * Sets failed
     *
     * @param \DateTime $failed Date when the payment method failed. In ISO-8601 extended offset date-time format.
     *
     * @return $this
     */
    public function setFailed($failed)
    {
        $this->container['failed'] = $failed;

        return $this;
    }

    /**
     * Gets created
     *
     * @return \DateTime
     */
    public function getCreated()
    {
        return $this->container['created'];
    }

    /**
     * Sets created
     *
     * @param \DateTime $created Date when the payment method was created. In ISO-8601 extended offset date-time format.
     *
     * @return $this
     */
    public function setCreated($created)
    {
        $this->container['created'] = $created;

        return $this;
    }

    /**
     * Gets card
     *
     * @return \Reepay\Model\CardV2
     */
    public function getCard()
    {
        return $this->container['card'];
    }

    /**
     * Sets card
     *
     * @param \Reepay\Model\CardV2 $card Card object in case of card payment method
     *
     * @return $this
     */
    public function setCard($card)
    {
        $this->container['card'] = $card;

        return $this;
    }

    /**
     * Gets applepay
     *
     * @return \Reepay\Model\CardV2
     */
    public function getApplepay()
    {
        return $this->container['applepay'];
    }

    /**
     * Sets applepay
     *
     * @param \Reepay\Model\CardV2 $applepay Card object in case of Apple Pay payment method
     *
     * @return $this
     */
    public function setApplepay($applepay)
    {
        $this->container['applepay'] = $applepay;

        return $this;
    }

    /**
     * Gets paymentType
     *
     * @return string
     */
    public function getPaymentType()
    {
        return $this->container['paymentType'];
    }

    /**
     * Sets paymentType
     *
     * @param string $paymentType Payment type for saved payment method, either: `card`, `mobilepay`, `vipps`, `swish`, `viabill`, `manual`, `applepay`, `googlepay`, `paypal`, `klarna_pay_now`, `klarna_pay_later`, `klarna_slice_it`, `klarna_direct_bank_transfer`, `klarna_direct_debit`, `resurs` or `mobilepay_subscriptions`
     *
     * @return $this
     */
    public function setPaymentType($paymentType)
    {
        $allowedValues = $this->getPaymentTypeAllowableValues();
        if (!in_array($paymentType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'paymentType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['paymentType'] = $paymentType;

        return $this;
    }

    /**
     * Gets mpsSubscription
     *
     * @return \Reepay\Model\MpsSubscriptionV2
     */
    public function getMpsSubscription()
    {
        return $this->container['mpsSubscription'];
    }

    /**
     * Sets mpsSubscription
     *
     * @param \Reepay\Model\MpsSubscriptionV2 $mpsSubscription MPS subscription object in case of MPS payment method
     *
     * @return $this
     */
    public function setMpsSubscription($mpsSubscription)
    {
        $this->container['mpsSubscription'] = $mpsSubscription;

        return $this;
    }

    /**
     * Gets vippsRecurringSubscription
     *
     * @return \Reepay\Model\VippsRecurringSubscriptionDto
     */
    public function getVippsRecurringSubscription()
    {
        return $this->container['vippsRecurringSubscription'];
    }

    /**
     * Sets vippsRecurringSubscription
     *
     * @param \Reepay\Model\VippsRecurringSubscriptionDto $vippsRecurringSubscription Vipps Recurring subscription object in case of Vipps Recurring payment method
     *
     * @return $this
     */
    public function setVippsRecurringSubscription($vippsRecurringSubscription)
    {
        $this->container['vippsRecurringSubscription'] = $vippsRecurringSubscription;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


