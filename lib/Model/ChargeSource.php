<?php
/**
 * ChargeSource
 *
 * PHP version 5
 *
 * @category Class
 * @package  Reepay
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * API
 *
 * REST API to manage Reepay resources
 *
 * OpenAPI spec version: 1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Reepay\Model;

use \ArrayAccess;

/**
 * ChargeSource Class Doc Comment
 *
 * @category    Class */
/** 
 * @package     Reepay
 * @author      http://github.com/swagger-api/swagger-codegen
 * @license     http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class ChargeSource implements ArrayAccess
{
    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'ChargeSource';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = array(
        'type' => 'string',
        'card' => 'string',
        'mps' => 'string',
        'fingerprint' => 'string',
        'provider' => 'string',
        'auth_transaction' => 'string',
        'card_type' => 'string',
        'exp_date' => 'string',
        'masked_card' => 'string',
        'card_country' => 'string',
        'strong_authentication_status' => 'string',
        'three_d_secure_status' => 'string',
        'risk_rule' => 'string',
        'acquirer_code' => 'string',
        'acquirer_message' => 'string',
        'acquirer_reference' => 'string',
        'text_on_statement' => 'string',
        'surcharge_fee' => 'int'
    );

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = array(
        'type' => 'type',
        'card' => 'card',
        'mps' => 'mps',
        'fingerprint' => 'fingerprint',
        'provider' => 'provider',
        'auth_transaction' => 'auth_transaction',
        'card_type' => 'card_type',
        'exp_date' => 'exp_date',
        'masked_card' => 'masked_card',
        'card_country' => 'card_country',
        'strong_authentication_status' => 'strong_authentication_status',
        'three_d_secure_status' => 'three_d_secure_status',
        'risk_rule' => 'risk_rule',
        'acquirer_code' => 'acquirer_code',
        'acquirer_message' => 'acquirer_message',
        'acquirer_reference' => 'acquirer_reference',
        'text_on_statement' => 'text_on_statement',
        'surcharge_fee' => 'surcharge_fee'
    );

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = array(
        'type' => 'setType',
        'card' => 'setCard',
        'mps' => 'setMps',
        'fingerprint' => 'setFingerprint',
        'provider' => 'setProvider',
        'auth_transaction' => 'setAuthTransaction',
        'card_type' => 'setCardType',
        'exp_date' => 'setExpDate',
        'masked_card' => 'setMaskedCard',
        'card_country' => 'setCardCountry',
        'strong_authentication_status' => 'setStrongAuthenticationStatus',
        'three_d_secure_status' => 'setThreeDSecureStatus',
        'risk_rule' => 'setRiskRule',
        'acquirer_code' => 'setAcquirerCode',
        'acquirer_message' => 'setAcquirerMessage',
        'acquirer_reference' => 'setAcquirerReference',
        'text_on_statement' => 'setTextOnStatement',
        'surcharge_fee' => 'setSurchargeFee'
    );

    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = array(
        'type' => 'getType',
        'card' => 'getCard',
        'mps' => 'getMps',
        'fingerprint' => 'getFingerprint',
        'provider' => 'getProvider',
        'auth_transaction' => 'getAuthTransaction',
        'card_type' => 'getCardType',
        'exp_date' => 'getExpDate',
        'masked_card' => 'getMaskedCard',
        'card_country' => 'getCardCountry',
        'strong_authentication_status' => 'getStrongAuthenticationStatus',
        'three_d_secure_status' => 'getThreeDSecureStatus',
        'risk_rule' => 'getRiskRule',
        'acquirer_code' => 'getAcquirerCode',
        'acquirer_message' => 'getAcquirerMessage',
        'acquirer_reference' => 'getAcquirerReference',
        'text_on_statement' => 'getTextOnStatement',
        'surcharge_fee' => 'getSurchargeFee'
    );

    public static function getters()
    {
        return self::$getters;
    }

    const TYPE_CARD_TOKEN = 'card_token';
    const TYPE_CARD = 'card';
    const TYPE_MPO = 'mpo';
    const TYPE_VIPPS = 'vipps';
    const TYPE_SWISH = 'swish';
    const TYPE_VIABILL = 'viabill';
    const TYPE_MANUAL = 'manual';
    const TYPE_APPLEPAY = 'applepay';
    const TYPE_GOOGLEPAY = 'googlepay';
    const TYPE_PAYPAL = 'paypal';
    const TYPE_KLARNA_PAY_NOW = 'klarna_pay_now';
    const TYPE_KLARNA_PAY_LATER = 'klarna_pay_later';
    const TYPE_KLARNA_SLICE_IT = 'klarna_slice_it';
    const TYPE_KLARNA_DIRECT_BANK_TRANSFER = 'klarna_direct_bank_transfer';
    const TYPE_KLARNA_DIRECT_DEBIT = 'klarna_direct_debit';
    const TYPE_RESURS = 'resurs';
    const TYPE_IDEAL = 'ideal';
    const TYPE_P24 = 'p24';
    const TYPE_BLIK = 'blik';
    const TYPE_MOBILEPAY_SUBSCRIPTIONS = 'mobilepay_subscriptions';
    const PROVIDER_REEPAY = 'reepay';
    const PROVIDER_CLEARHAUS = 'clearhaus';
    const PROVIDER_NETS = 'nets';
    const PROVIDER_SWEDBANK = 'swedbank';
    const PROVIDER_HANDELSBANKEN = 'handelsbanken';
    const PROVIDER_ELAVON = 'elavon';
    const PROVIDER_BAMBORA = 'bambora';
    const PROVIDER_VALITOR = 'valitor';
    const PROVIDER_DIBS = 'dibs';
    const PROVIDER_STRIPE = 'stripe';
    const PROVIDER_QUICKPAY = 'quickpay';
    const PROVIDER_EPAY = 'epay';
    const PROVIDER_TEST = 'test';
    const CARD_TYPE_UNKNOWN = 'unknown';
    const CARD_TYPE_VISA = 'visa';
    const CARD_TYPE_MC = 'mc';
    const CARD_TYPE_DANKORT = 'dankort';
    const CARD_TYPE_VISA_DK = 'visa_dk';
    const CARD_TYPE_FFK = 'ffk';
    const CARD_TYPE_VISA_ELEC = 'visa_elec';
    const CARD_TYPE_MAESTRO = 'maestro';
    const CARD_TYPE_LASER = 'laser';
    const CARD_TYPE_AMEX = 'amex';
    const CARD_TYPE_DINERS = 'diners';
    const CARD_TYPE_DISCOVER = 'discover';
    const CARD_TYPE_JCB = 'jcb';
    const STRONG_AUTHENTICATION_STATUS_THREED_SECURE = 'threed_secure';
    const STRONG_AUTHENTICATION_STATUS_THREED_SECURE_NOT_ENROLLED = 'threed_secure_not_enrolled';
    const STRONG_AUTHENTICATION_STATUS_SECURED_BY_NETS = 'secured_by_nets';
    

    
    /**
     * Gets allowable values of the enum
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_CARD_TOKEN,
            self::TYPE_CARD,
            self::TYPE_MPO,
            self::TYPE_VIPPS,
            self::TYPE_SWISH,
            self::TYPE_VIABILL,
            self::TYPE_MANUAL,
            self::TYPE_APPLEPAY,
            self::TYPE_GOOGLEPAY,
            self::TYPE_PAYPAL,
            self::TYPE_KLARNA_PAY_NOW,
            self::TYPE_KLARNA_PAY_LATER,
            self::TYPE_KLARNA_SLICE_IT,
            self::TYPE_KLARNA_DIRECT_BANK_TRANSFER,
            self::TYPE_KLARNA_DIRECT_DEBIT,
            self::TYPE_RESURS,
            self::TYPE_IDEAL,
            self::TYPE_P24,
            self::TYPE_BLIK,
            self::TYPE_MOBILEPAY_SUBSCRIPTIONS,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     * @return string[]
     */
    public function getProviderAllowableValues()
    {
        return [
            self::PROVIDER_REEPAY,
            self::PROVIDER_CLEARHAUS,
            self::PROVIDER_NETS,
            self::PROVIDER_SWEDBANK,
            self::PROVIDER_HANDELSBANKEN,
            self::PROVIDER_ELAVON,
            self::PROVIDER_BAMBORA,
            self::PROVIDER_VALITOR,
            self::PROVIDER_DIBS,
            self::PROVIDER_STRIPE,
            self::PROVIDER_QUICKPAY,
            self::PROVIDER_EPAY,
            self::PROVIDER_TEST,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     * @return string[]
     */
    public function getCardTypeAllowableValues()
    {
        return [
            self::CARD_TYPE_UNKNOWN,
            self::CARD_TYPE_VISA,
            self::CARD_TYPE_MC,
            self::CARD_TYPE_DANKORT,
            self::CARD_TYPE_VISA_DK,
            self::CARD_TYPE_FFK,
            self::CARD_TYPE_VISA_ELEC,
            self::CARD_TYPE_MAESTRO,
            self::CARD_TYPE_LASER,
            self::CARD_TYPE_AMEX,
            self::CARD_TYPE_DINERS,
            self::CARD_TYPE_DISCOVER,
            self::CARD_TYPE_JCB,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     * @return string[]
     */
    public function getStrongAuthenticationStatusAllowableValues()
    {
        return [
            self::STRONG_AUTHENTICATION_STATUS_THREED_SECURE,
            self::STRONG_AUTHENTICATION_STATUS_THREED_SECURE_NOT_ENROLLED,
            self::STRONG_AUTHENTICATION_STATUS_SECURED_BY_NETS,
        ];
    }
    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = array();

    /**
     * Constructor
     * @param mixed[] $data Associated array of property value initalizing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['type'] = isset($data['type']) ? $data['type'] : null;
        $this->container['card'] = isset($data['card']) ? $data['card'] : null;
        $this->container['mps'] = isset($data['mps']) ? $data['mps'] : null;
        $this->container['fingerprint'] = isset($data['fingerprint']) ? $data['fingerprint'] : null;
        $this->container['provider'] = isset($data['provider']) ? $data['provider'] : null;
        $this->container['auth_transaction'] = isset($data['auth_transaction']) ? $data['auth_transaction'] : null;
        $this->container['card_type'] = isset($data['card_type']) ? $data['card_type'] : null;
        $this->container['exp_date'] = isset($data['exp_date']) ? $data['exp_date'] : null;
        $this->container['masked_card'] = isset($data['masked_card']) ? $data['masked_card'] : null;
        $this->container['card_country'] = isset($data['card_country']) ? $data['card_country'] : null;
        $this->container['strong_authentication_status'] = isset($data['strong_authentication_status']) ? $data['strong_authentication_status'] : null;
        $this->container['three_d_secure_status'] = isset($data['three_d_secure_status']) ? $data['three_d_secure_status'] : null;
        $this->container['risk_rule'] = isset($data['risk_rule']) ? $data['risk_rule'] : null;
        $this->container['acquirer_code'] = isset($data['acquirer_code']) ? $data['acquirer_code'] : null;
        $this->container['acquirer_message'] = isset($data['acquirer_message']) ? $data['acquirer_message'] : null;
        $this->container['acquirer_reference'] = isset($data['acquirer_reference']) ? $data['acquirer_reference'] : null;
        $this->container['text_on_statement'] = isset($data['text_on_statement']) ? $data['text_on_statement'] : null;
        $this->container['surcharge_fee'] = isset($data['surcharge_fee']) ? $data['surcharge_fee'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = array();
        if ($this->container['type'] === null) {
            $invalid_properties[] = "'type' can't be null";
        }
        $allowed_values = array("card_token", "card", "mpo", "vipps", "swish", "viabill", "manual", "applepay", "googlepay", "paypal", "klarna_pay_now", "klarna_pay_later", "klarna_slice_it", "klarna_direct_bank_transfer", "klarna_direct_debit", "resurs", "ideal", "p24", "blik", "mobilepay_subscriptions");
        if (!in_array($this->container['type'], $allowed_values)) {
            $invalid_properties[] = "invalid value for 'type', must be one of #{allowed_values}.";
        }

        $allowed_values = array("reepay", "clearhaus", "nets", "swedbank", "handelsbanken", "elavon", "bambora", "valitor", "dibs", "stripe", "quickpay", "epay", "test");
        if (!in_array($this->container['provider'], $allowed_values)) {
            $invalid_properties[] = "invalid value for 'provider', must be one of #{allowed_values}.";
        }

        $allowed_values = array("unknown", "visa", "mc", "dankort", "visa_dk", "ffk", "visa_elec", "maestro", "laser", "amex", "diners", "discover", "jcb");
        if (!in_array($this->container['card_type'], $allowed_values)) {
            $invalid_properties[] = "invalid value for 'card_type', must be one of #{allowed_values}.";
        }

        $allowed_values = array("threed_secure", "threed_secure_not_enrolled", "secured_by_nets");
        if (!in_array($this->container['strong_authentication_status'], $allowed_values)) {
            $invalid_properties[] = "invalid value for 'strong_authentication_status', must be one of #{allowed_values}.";
        }

        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properteis are valid
     */
    public function valid()
    {
        if ($this->container['type'] === null) {
            return false;
        }
        $allowed_values = array("card_token", "card", "mpo", "vipps", "swish", "viabill", "manual", "applepay", "googlepay", "paypal", "klarna_pay_now", "klarna_pay_later", "klarna_slice_it", "klarna_direct_bank_transfer", "klarna_direct_debit", "resurs", "ideal", "p24", "blik", "mobilepay_subscriptions");
        if (!in_array($this->container['type'], $allowed_values)) {
            return false;
        }
        $allowed_values = array("reepay", "clearhaus", "nets", "swedbank", "handelsbanken", "elavon", "bambora", "valitor", "dibs", "stripe", "quickpay", "epay", "test");
        if (!in_array($this->container['provider'], $allowed_values)) {
            return false;
        }
        $allowed_values = array("unknown", "visa", "mc", "dankort", "visa_dk", "ffk", "visa_elec", "maestro", "laser", "amex", "diners", "discover", "jcb");
        if (!in_array($this->container['card_type'], $allowed_values)) {
            return false;
        }
        $allowed_values = array("threed_secure", "threed_secure_not_enrolled", "secured_by_nets");
        if (!in_array($this->container['strong_authentication_status'], $allowed_values)) {
            return false;
        }
        return true;
    }


    /**
     * Gets type
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     * @param string $type Type of charge source: `card` - existing customer card, `card_token` - card token, `mpo` - MobilePay Online, `vipps`, `swish`, `viabill`, `manual`, `applepay`, `googlepay`, `paypal`, `klarna_pay_now`, `klarna_pay_later`, `klarna_slice_it`, `klarna_direct_bank_transfer`, `klarna_direct_debit`, `resurs`, `ideal`, `p24`, `blik` or `mobilepay_subscriptions`
     * @return $this
     */
    public function setType($type)
    {
        $allowed_values = array('card_token', 'card', 'mpo', 'vipps', 'swish', 'viabill', 'manual', 'applepay', 'googlepay', 'paypal', 'klarna_pay_now', 'klarna_pay_later', 'klarna_slice_it', 'klarna_direct_bank_transfer', 'klarna_direct_debit', 'resurs', 'ideal', 'p24', 'blik', 'mobilepay_subscriptions');
        if (!in_array($type, $allowed_values)) {
            throw new \InvalidArgumentException("Invalid value for 'type', must be one of 'card_token', 'card', 'mpo', 'vipps', 'swish', 'viabill', 'manual', 'applepay', 'googlepay', 'paypal', 'klarna_pay_now', 'klarna_pay_later', 'klarna_slice_it', 'klarna_direct_bank_transfer', 'klarna_direct_debit', 'resurs', 'ideal', 'p24', 'blik', 'mobilepay_subscriptions'");
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets card
     * @return string
     */
    public function getCard()
    {
        return $this->container['card'];
    }

    /**
     * Sets card
     * @param string $card Reference to customer card if source type `card`
     * @return $this
     */
    public function setCard($card)
    {
        $this->container['card'] = $card;

        return $this;
    }

    /**
     * Gets mps
     * @return string
     */
    public function getMps()
    {
        return $this->container['mps'];
    }

    /**
     * Sets mps
     * @param string $mps Reference to MobilePay Subscriptions payment method if source type `mobilepay_subscriptions`
     * @return $this
     */
    public function setMps($mps)
    {
        $this->container['mps'] = $mps;

        return $this;
    }

    /**
     * Gets fingerprint
     * @return string
     */
    public function getFingerprint()
    {
        return $this->container['fingerprint'];
    }

    /**
     * Sets fingerprint
     * @param string $fingerprint Uniquely identifies this particular card number if credit card source
     * @return $this
     */
    public function setFingerprint($fingerprint)
    {
        $this->container['fingerprint'] = $fingerprint;

        return $this;
    }

    /**
     * Gets provider
     * @return string
     */
    public function getProvider()
    {
        return $this->container['provider'];
    }

    /**
     * Sets provider
     * @param string $provider Card acquirer or card payment gateway used if card source: `reepay`, `clearhaus`, `nets`, `swedbank`, `handelsbanken`, `elavon`, `bambora`, `valitor`, `dibs`, `stripe`, `quickpay`, `epay`, `test`
     * @return $this
     */
    public function setProvider($provider)
    {
        $allowed_values = array('reepay', 'clearhaus', 'nets', 'swedbank', 'handelsbanken', 'elavon', 'bambora', 'valitor', 'dibs', 'stripe', 'quickpay', 'epay', 'test');
        if (!in_array($provider, $allowed_values)) {
            throw new \InvalidArgumentException("Invalid value for 'provider', must be one of 'reepay', 'clearhaus', 'nets', 'swedbank', 'handelsbanken', 'elavon', 'bambora', 'valitor', 'dibs', 'stripe', 'quickpay', 'epay', 'test'");
        }
        $this->container['provider'] = $provider;

        return $this;
    }

    /**
     * Gets auth_transaction
     * @return string
     */
    public function getAuthTransaction()
    {
        return $this->container['auth_transaction'];
    }

    /**
     * Sets auth_transaction
     * @param string $auth_transaction Reference to authorization transaction if charge is settled after authorization
     * @return $this
     */
    public function setAuthTransaction($auth_transaction)
    {
        $this->container['auth_transaction'] = $auth_transaction;

        return $this;
    }

    /**
     * Gets card_type
     * @return string
     */
    public function getCardType()
    {
        return $this->container['card_type'];
    }

    /**
     * Sets card_type
     * @param string $card_type Card type if credit card source: `unknown`, `visa`, `mc`, `dankort`, `visa_dk`, `ffk`, `visa_elec`, `maestro`, `laser`, `amex`, `diners`, `discover` or `jcb`
     * @return $this
     */
    public function setCardType($card_type)
    {
        $allowed_values = array('unknown', 'visa', 'mc', 'dankort', 'visa_dk', 'ffk', 'visa_elec', 'maestro', 'laser', 'amex', 'diners', 'discover', 'jcb');
        if (!in_array($card_type, $allowed_values)) {
            throw new \InvalidArgumentException("Invalid value for 'card_type', must be one of 'unknown', 'visa', 'mc', 'dankort', 'visa_dk', 'ffk', 'visa_elec', 'maestro', 'laser', 'amex', 'diners', 'discover', 'jcb'");
        }
        $this->container['card_type'] = $card_type;

        return $this;
    }

    /**
     * Gets exp_date
     * @return string
     */
    public function getExpDate()
    {
        return $this->container['exp_date'];
    }

    /**
     * Sets exp_date
     * @param string $exp_date Card expire date on form MM-YY if credit card source
     * @return $this
     */
    public function setExpDate($exp_date)
    {
        $this->container['exp_date'] = $exp_date;

        return $this;
    }

    /**
     * Gets masked_card
     * @return string
     */
    public function getMaskedCard()
    {
        return $this->container['masked_card'];
    }

    /**
     * Sets masked_card
     * @param string $masked_card Masked card number if credit card source
     * @return $this
     */
    public function setMaskedCard($masked_card)
    {
        $this->container['masked_card'] = $masked_card;

        return $this;
    }

    /**
     * Gets card_country
     * @return string
     */
    public function getCardCountry()
    {
        return $this->container['card_country'];
    }

    /**
     * Sets card_country
     * @param string $card_country Card issuing country if credit card source, in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
     * @return $this
     */
    public function setCardCountry($card_country)
    {
        $this->container['card_country'] = $card_country;

        return $this;
    }

    /**
     * Gets strong_authentication_status
     * @return string
     */
    public function getStrongAuthenticationStatus()
    {
        return $this->container['strong_authentication_status'];
    }

    /**
     * Sets strong_authentication_status
     * @param string $strong_authentication_status Status for strong customer authentication: `threed_secure` - 3D Secure authenticated, `threed_secure_not_enrolled` - 3D Secure authentication not performed as card not enrolled, `secured_by_nets` - Secure by Nets authenticated
     * @return $this
     */
    public function setStrongAuthenticationStatus($strong_authentication_status)
    {
        $allowed_values = array('threed_secure', 'threed_secure_not_enrolled', 'secured_by_nets');
        if (!in_array($strong_authentication_status, $allowed_values)) {
            throw new \InvalidArgumentException("Invalid value for 'strong_authentication_status', must be one of 'threed_secure', 'threed_secure_not_enrolled', 'secured_by_nets'");
        }
        $this->container['strong_authentication_status'] = $strong_authentication_status;

        return $this;
    }

    /**
     * Gets three_d_secure_status
     * @return string
     */
    public function getThreeDSecureStatus()
    {
        return $this->container['three_d_secure_status'];
    }

    /**
     * Sets three_d_secure_status
     * @param string $three_d_secure_status If 3D Secure authenticated the 3D status will either be `Y` (fully authenticated) or `A` (attempted authenticated). An attempted authentication means that card issuer (e.g. bank) does not support 3D Secure so no full authentication has been performed. Attempted authentication normally means liability shift, but this can differ between acquirers.
     * @return $this
     */
    public function setThreeDSecureStatus($three_d_secure_status)
    {
        $this->container['three_d_secure_status'] = $three_d_secure_status;

        return $this;
    }

    /**
     * Gets risk_rule
     * @return string
     */
    public function getRiskRule()
    {
        return $this->container['risk_rule'];
    }

    /**
     * Sets risk_rule
     * @param string $risk_rule If this parameter is set the charge has either been flagged or declined by a Reepay Risk Filter rule. For flag action rules the charge can be successful, but may require special attention. For block action rules the decline error will be `risk_filter_block`.
     * @return $this
     */
    public function setRiskRule($risk_rule)
    {
        $this->container['risk_rule'] = $risk_rule;

        return $this;
    }

    /**
     * Gets acquirer_code
     * @return string
     */
    public function getAcquirerCode()
    {
        return $this->container['acquirer_code'];
    }

    /**
     * Sets acquirer_code
     * @param string $acquirer_code Card acquirer error code in case of card error
     * @return $this
     */
    public function setAcquirerCode($acquirer_code)
    {
        $this->container['acquirer_code'] = $acquirer_code;

        return $this;
    }

    /**
     * Gets acquirer_message
     * @return string
     */
    public function getAcquirerMessage()
    {
        return $this->container['acquirer_message'];
    }

    /**
     * Sets acquirer_message
     * @param string $acquirer_message Acquirer message in case of error
     * @return $this
     */
    public function setAcquirerMessage($acquirer_message)
    {
        $this->container['acquirer_message'] = $acquirer_message;

        return $this;
    }

    /**
     * Gets acquirer_reference
     * @return string
     */
    public function getAcquirerReference()
    {
        return $this->container['acquirer_reference'];
    }

    /**
     * Sets acquirer_reference
     * @param string $acquirer_reference Card acquirer reference to transaction in case of card source. E.g. Nets order id or Clearhaus reference.
     * @return $this
     */
    public function setAcquirerReference($acquirer_reference)
    {
        $this->container['acquirer_reference'] = $acquirer_reference;

        return $this;
    }

    /**
     * Gets text_on_statement
     * @return string
     */
    public function getTextOnStatement()
    {
        return $this->container['text_on_statement'];
    }

    /**
     * Sets text_on_statement
     * @param string $text_on_statement Resulting text on bank statement if known
     * @return $this
     */
    public function setTextOnStatement($text_on_statement)
    {
        $this->container['text_on_statement'] = $text_on_statement;

        return $this;
    }

    /**
     * Gets surcharge_fee
     * @return int
     */
    public function getSurchargeFee()
    {
        return $this->container['surcharge_fee'];
    }

    /**
     * Sets surcharge_fee
     * @param int $surcharge_fee Potential card surcharge fee added to amount if surcharging enabled
     * @return $this
     */
    public function setSurchargeFee($surcharge_fee)
    {
        $this->container['surcharge_fee'] = $surcharge_fee;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\Reepay\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\Reepay\ObjectSerializer::sanitizeForSerialization($this));
    }
}


