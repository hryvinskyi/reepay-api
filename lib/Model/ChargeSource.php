<?php
/**
 * ChargeSource
 *
 * PHP version 5
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * API
 *
 * REST API to manage Reepay resources
 *
 * OpenAPI spec version: 1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.28
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Reepay\Model;

use \ArrayAccess;
use \Reepay\ObjectSerializer;

/**
 * ChargeSource Class Doc Comment
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ChargeSource implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'ChargeSource';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'type' => 'string',
        'card' => 'string',
        'mps' => 'string',
        'fingerprint' => 'string',
        'provider' => 'string',
        'vippsRecurring' => 'string',
        'authTransaction' => 'string',
        'cardType' => 'string',
        'transactionCardType' => 'string',
        'expDate' => 'string',
        'maskedCard' => 'string',
        'cardCountry' => 'string',
        'strongAuthenticationStatus' => 'string',
        'threeDSecureStatus' => 'string',
        'riskRule' => 'string',
        'acquirerCode' => 'string',
        'acquirerMessage' => 'string',
        'acquirerReference' => 'string',
        'textOnStatement' => 'string',
        'surchargeFee' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'type' => null,
        'card' => null,
        'mps' => null,
        'fingerprint' => null,
        'provider' => null,
        'vippsRecurring' => null,
        'authTransaction' => null,
        'cardType' => null,
        'transactionCardType' => null,
        'expDate' => null,
        'maskedCard' => null,
        'cardCountry' => null,
        'strongAuthenticationStatus' => null,
        'threeDSecureStatus' => null,
        'riskRule' => null,
        'acquirerCode' => null,
        'acquirerMessage' => null,
        'acquirerReference' => null,
        'textOnStatement' => null,
        'surchargeFee' => 'int32'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'type' => 'type',
        'card' => 'card',
        'mps' => 'mps',
        'fingerprint' => 'fingerprint',
        'provider' => 'provider',
        'vippsRecurring' => 'vipps_recurring',
        'authTransaction' => 'auth_transaction',
        'cardType' => 'card_type',
        'transactionCardType' => 'transaction_card_type',
        'expDate' => 'exp_date',
        'maskedCard' => 'masked_card',
        'cardCountry' => 'card_country',
        'strongAuthenticationStatus' => 'strong_authentication_status',
        'threeDSecureStatus' => 'three_d_secure_status',
        'riskRule' => 'risk_rule',
        'acquirerCode' => 'acquirer_code',
        'acquirerMessage' => 'acquirer_message',
        'acquirerReference' => 'acquirer_reference',
        'textOnStatement' => 'text_on_statement',
        'surchargeFee' => 'surcharge_fee'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'type' => 'setType',
        'card' => 'setCard',
        'mps' => 'setMps',
        'fingerprint' => 'setFingerprint',
        'provider' => 'setProvider',
        'vippsRecurring' => 'setVippsRecurring',
        'authTransaction' => 'setAuthTransaction',
        'cardType' => 'setCardType',
        'transactionCardType' => 'setTransactionCardType',
        'expDate' => 'setExpDate',
        'maskedCard' => 'setMaskedCard',
        'cardCountry' => 'setCardCountry',
        'strongAuthenticationStatus' => 'setStrongAuthenticationStatus',
        'threeDSecureStatus' => 'setThreeDSecureStatus',
        'riskRule' => 'setRiskRule',
        'acquirerCode' => 'setAcquirerCode',
        'acquirerMessage' => 'setAcquirerMessage',
        'acquirerReference' => 'setAcquirerReference',
        'textOnStatement' => 'setTextOnStatement',
        'surchargeFee' => 'setSurchargeFee'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'type' => 'getType',
        'card' => 'getCard',
        'mps' => 'getMps',
        'fingerprint' => 'getFingerprint',
        'provider' => 'getProvider',
        'vippsRecurring' => 'getVippsRecurring',
        'authTransaction' => 'getAuthTransaction',
        'cardType' => 'getCardType',
        'transactionCardType' => 'getTransactionCardType',
        'expDate' => 'getExpDate',
        'maskedCard' => 'getMaskedCard',
        'cardCountry' => 'getCardCountry',
        'strongAuthenticationStatus' => 'getStrongAuthenticationStatus',
        'threeDSecureStatus' => 'getThreeDSecureStatus',
        'riskRule' => 'getRiskRule',
        'acquirerCode' => 'getAcquirerCode',
        'acquirerMessage' => 'getAcquirerMessage',
        'acquirerReference' => 'getAcquirerReference',
        'textOnStatement' => 'getTextOnStatement',
        'surchargeFee' => 'getSurchargeFee'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const TYPE_CARD_TOKEN = 'card_token';
    const TYPE_CARD = 'card';
    const TYPE_MPO = 'mpo';
    const TYPE_VIPPS = 'vipps';
    const TYPE_SWISH = 'swish';
    const TYPE_VIABILL = 'viabill';
    const TYPE_MANUAL = 'manual';
    const TYPE_APPLEPAY = 'applepay';
    const TYPE_GOOGLEPAY = 'googlepay';
    const TYPE_PAYPAL = 'paypal';
    const TYPE_KLARNA_PAY_NOW = 'klarna_pay_now';
    const TYPE_KLARNA_PAY_LATER = 'klarna_pay_later';
    const TYPE_KLARNA_SLICE_IT = 'klarna_slice_it';
    const TYPE_KLARNA_DIRECT_BANK_TRANSFER = 'klarna_direct_bank_transfer';
    const TYPE_KLARNA_DIRECT_DEBIT = 'klarna_direct_debit';
    const TYPE_RESURS = 'resurs';
    const TYPE_BANCOTACT = 'bancotact';
    const TYPE_IDEAL = 'ideal';
    const TYPE_P24 = 'p24';
    const TYPE_BLIK = 'blik';
    const TYPE_GIROPAY = 'giropay';
    const TYPE_SEPA = 'sepa';
    const TYPE_VERKKOPANKKI = 'verkkopankki';
    const TYPE_MOBILEPAY_SUBSCRIPTIONS = 'mobilepay_subscriptions';
    const PROVIDER_REEPAY = 'reepay';
    const PROVIDER_CLEARHAUS = 'clearhaus';
    const PROVIDER_NETS = 'nets';
    const PROVIDER_SWEDBANK = 'swedbank';
    const PROVIDER_HANDELSBANKEN = 'handelsbanken';
    const PROVIDER_ELAVON = 'elavon';
    const PROVIDER_BAMBORA = 'bambora';
    const PROVIDER_VALITOR = 'valitor';
    const PROVIDER_DIBS = 'dibs';
    const PROVIDER_STRIPE = 'stripe';
    const PROVIDER_EPAY = 'epay';
    const PROVIDER_TEST = 'test';
    const CARD_TYPE_UNKNOWN = 'unknown';
    const CARD_TYPE_VISA = 'visa';
    const CARD_TYPE_MC = 'mc';
    const CARD_TYPE_DANKORT = 'dankort';
    const CARD_TYPE_VISA_DK = 'visa_dk';
    const CARD_TYPE_FFK = 'ffk';
    const CARD_TYPE_VISA_ELEC = 'visa_elec';
    const CARD_TYPE_MAESTRO = 'maestro';
    const CARD_TYPE_LASER = 'laser';
    const CARD_TYPE_AMEX = 'amex';
    const CARD_TYPE_DINERS = 'diners';
    const CARD_TYPE_DISCOVER = 'discover';
    const CARD_TYPE_JCB = 'jcb';
    const TRANSACTION_CARD_TYPE_UNKNOWN = 'unknown';
    const TRANSACTION_CARD_TYPE_VISA = 'visa';
    const TRANSACTION_CARD_TYPE_MC = 'mc';
    const TRANSACTION_CARD_TYPE_DANKORT = 'dankort';
    const TRANSACTION_CARD_TYPE_VISA_DK = 'visa_dk';
    const TRANSACTION_CARD_TYPE_FFK = 'ffk';
    const TRANSACTION_CARD_TYPE_VISA_ELEC = 'visa_elec';
    const TRANSACTION_CARD_TYPE_MAESTRO = 'maestro';
    const TRANSACTION_CARD_TYPE_LASER = 'laser';
    const TRANSACTION_CARD_TYPE_AMEX = 'amex';
    const TRANSACTION_CARD_TYPE_DINERS = 'diners';
    const TRANSACTION_CARD_TYPE_DISCOVER = 'discover';
    const TRANSACTION_CARD_TYPE_JCB = 'jcb';
    const STRONG_AUTHENTICATION_STATUS_THREED_SECURE = 'threed_secure';
    const STRONG_AUTHENTICATION_STATUS_THREED_SECURE_NOT_ENROLLED = 'threed_secure_not_enrolled';
    const STRONG_AUTHENTICATION_STATUS_SECURED_BY_NETS = 'secured_by_nets';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_CARD_TOKEN,
            self::TYPE_CARD,
            self::TYPE_MPO,
            self::TYPE_VIPPS,
            self::TYPE_SWISH,
            self::TYPE_VIABILL,
            self::TYPE_MANUAL,
            self::TYPE_APPLEPAY,
            self::TYPE_GOOGLEPAY,
            self::TYPE_PAYPAL,
            self::TYPE_KLARNA_PAY_NOW,
            self::TYPE_KLARNA_PAY_LATER,
            self::TYPE_KLARNA_SLICE_IT,
            self::TYPE_KLARNA_DIRECT_BANK_TRANSFER,
            self::TYPE_KLARNA_DIRECT_DEBIT,
            self::TYPE_RESURS,
            self::TYPE_BANCOTACT,
            self::TYPE_IDEAL,
            self::TYPE_P24,
            self::TYPE_BLIK,
            self::TYPE_GIROPAY,
            self::TYPE_SEPA,
            self::TYPE_VERKKOPANKKI,
            self::TYPE_MOBILEPAY_SUBSCRIPTIONS,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getProviderAllowableValues()
    {
        return [
            self::PROVIDER_REEPAY,
            self::PROVIDER_CLEARHAUS,
            self::PROVIDER_NETS,
            self::PROVIDER_SWEDBANK,
            self::PROVIDER_HANDELSBANKEN,
            self::PROVIDER_ELAVON,
            self::PROVIDER_BAMBORA,
            self::PROVIDER_VALITOR,
            self::PROVIDER_DIBS,
            self::PROVIDER_STRIPE,
            self::PROVIDER_EPAY,
            self::PROVIDER_TEST,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCardTypeAllowableValues()
    {
        return [
            self::CARD_TYPE_UNKNOWN,
            self::CARD_TYPE_VISA,
            self::CARD_TYPE_MC,
            self::CARD_TYPE_DANKORT,
            self::CARD_TYPE_VISA_DK,
            self::CARD_TYPE_FFK,
            self::CARD_TYPE_VISA_ELEC,
            self::CARD_TYPE_MAESTRO,
            self::CARD_TYPE_LASER,
            self::CARD_TYPE_AMEX,
            self::CARD_TYPE_DINERS,
            self::CARD_TYPE_DISCOVER,
            self::CARD_TYPE_JCB,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTransactionCardTypeAllowableValues()
    {
        return [
            self::TRANSACTION_CARD_TYPE_UNKNOWN,
            self::TRANSACTION_CARD_TYPE_VISA,
            self::TRANSACTION_CARD_TYPE_MC,
            self::TRANSACTION_CARD_TYPE_DANKORT,
            self::TRANSACTION_CARD_TYPE_VISA_DK,
            self::TRANSACTION_CARD_TYPE_FFK,
            self::TRANSACTION_CARD_TYPE_VISA_ELEC,
            self::TRANSACTION_CARD_TYPE_MAESTRO,
            self::TRANSACTION_CARD_TYPE_LASER,
            self::TRANSACTION_CARD_TYPE_AMEX,
            self::TRANSACTION_CARD_TYPE_DINERS,
            self::TRANSACTION_CARD_TYPE_DISCOVER,
            self::TRANSACTION_CARD_TYPE_JCB,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStrongAuthenticationStatusAllowableValues()
    {
        return [
            self::STRONG_AUTHENTICATION_STATUS_THREED_SECURE,
            self::STRONG_AUTHENTICATION_STATUS_THREED_SECURE_NOT_ENROLLED,
            self::STRONG_AUTHENTICATION_STATUS_SECURED_BY_NETS,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['type'] = isset($data['type']) ? $data['type'] : null;
        $this->container['card'] = isset($data['card']) ? $data['card'] : null;
        $this->container['mps'] = isset($data['mps']) ? $data['mps'] : null;
        $this->container['fingerprint'] = isset($data['fingerprint']) ? $data['fingerprint'] : null;
        $this->container['provider'] = isset($data['provider']) ? $data['provider'] : null;
        $this->container['vippsRecurring'] = isset($data['vippsRecurring']) ? $data['vippsRecurring'] : null;
        $this->container['authTransaction'] = isset($data['authTransaction']) ? $data['authTransaction'] : null;
        $this->container['cardType'] = isset($data['cardType']) ? $data['cardType'] : null;
        $this->container['transactionCardType'] = isset($data['transactionCardType']) ? $data['transactionCardType'] : null;
        $this->container['expDate'] = isset($data['expDate']) ? $data['expDate'] : null;
        $this->container['maskedCard'] = isset($data['maskedCard']) ? $data['maskedCard'] : null;
        $this->container['cardCountry'] = isset($data['cardCountry']) ? $data['cardCountry'] : null;
        $this->container['strongAuthenticationStatus'] = isset($data['strongAuthenticationStatus']) ? $data['strongAuthenticationStatus'] : null;
        $this->container['threeDSecureStatus'] = isset($data['threeDSecureStatus']) ? $data['threeDSecureStatus'] : null;
        $this->container['riskRule'] = isset($data['riskRule']) ? $data['riskRule'] : null;
        $this->container['acquirerCode'] = isset($data['acquirerCode']) ? $data['acquirerCode'] : null;
        $this->container['acquirerMessage'] = isset($data['acquirerMessage']) ? $data['acquirerMessage'] : null;
        $this->container['acquirerReference'] = isset($data['acquirerReference']) ? $data['acquirerReference'] : null;
        $this->container['textOnStatement'] = isset($data['textOnStatement']) ? $data['textOnStatement'] : null;
        $this->container['surchargeFee'] = isset($data['surchargeFee']) ? $data['surchargeFee'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['type'] === null) {
            $invalidProperties[] = "'type' can't be null";
        }
        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($this->container['type']) && !in_array($this->container['type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getProviderAllowableValues();
        if (!is_null($this->container['provider']) && !in_array($this->container['provider'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'provider', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCardTypeAllowableValues();
        if (!is_null($this->container['cardType']) && !in_array($this->container['cardType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'cardType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getTransactionCardTypeAllowableValues();
        if (!is_null($this->container['transactionCardType']) && !in_array($this->container['transactionCardType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'transactionCardType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStrongAuthenticationStatusAllowableValues();
        if (!is_null($this->container['strongAuthenticationStatus']) && !in_array($this->container['strongAuthenticationStatus'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'strongAuthenticationStatus', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets type
     *
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string $type Type of charge source: `card` - existing customer card, `card_token` - card token, `mpo` - MobilePay Online, `vipps`, `swish`, `viabill`, `manual`, `applepay`, `googlepay`, `paypal`, `klarna_pay_now`, `klarna_pay_later`, `klarna_slice_it`, `klarna_direct_bank_transfer`, `klarna_direct_debit`, `resurs`, `bancontact`, `blik`, `giropay`, `ideal`, `p24`, `sepa`, `verkkopankki` or `mobilepay_subscriptions`
     *
     * @return $this
     */
    public function setType($type)
    {
        $allowedValues = $this->getTypeAllowableValues();
        if (!in_array($type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets card
     *
     * @return string
     */
    public function getCard()
    {
        return $this->container['card'];
    }

    /**
     * Sets card
     *
     * @param string $card Reference to customer card if source type `card`
     *
     * @return $this
     */
    public function setCard($card)
    {
        $this->container['card'] = $card;

        return $this;
    }

    /**
     * Gets mps
     *
     * @return string
     */
    public function getMps()
    {
        return $this->container['mps'];
    }

    /**
     * Sets mps
     *
     * @param string $mps Reference to MobilePay Subscriptions payment method if source type `mobilepay_subscriptions`
     *
     * @return $this
     */
    public function setMps($mps)
    {
        $this->container['mps'] = $mps;

        return $this;
    }

    /**
     * Gets fingerprint
     *
     * @return string
     */
    public function getFingerprint()
    {
        return $this->container['fingerprint'];
    }

    /**
     * Sets fingerprint
     *
     * @param string $fingerprint Uniquely identifies this particular card number if credit card source
     *
     * @return $this
     */
    public function setFingerprint($fingerprint)
    {
        $this->container['fingerprint'] = $fingerprint;

        return $this;
    }

    /**
     * Gets provider
     *
     * @return string
     */
    public function getProvider()
    {
        return $this->container['provider'];
    }

    /**
     * Sets provider
     *
     * @param string $provider Card acquirer or card payment gateway used if card source: `reepay`, `clearhaus`, `nets`, `swedbank`, `handelsbanken`, `elavon`, `bambora`, `valitor`, `dibs`, `stripe`, `epay`, `test`
     *
     * @return $this
     */
    public function setProvider($provider)
    {
        $allowedValues = $this->getProviderAllowableValues();
        if (!is_null($provider) && !in_array($provider, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'provider', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['provider'] = $provider;

        return $this;
    }

    /**
     * Gets vippsRecurring
     *
     * @return string
     */
    public function getVippsRecurring()
    {
        return $this->container['vippsRecurring'];
    }

    /**
     * Sets vippsRecurring
     *
     * @param string $vippsRecurring Reference to Vipps Recurring Subscriptions payment method if source type `vipps_recurring`
     *
     * @return $this
     */
    public function setVippsRecurring($vippsRecurring)
    {
        $this->container['vippsRecurring'] = $vippsRecurring;

        return $this;
    }

    /**
     * Gets authTransaction
     *
     * @return string
     */
    public function getAuthTransaction()
    {
        return $this->container['authTransaction'];
    }

    /**
     * Sets authTransaction
     *
     * @param string $authTransaction Reference to authorization transaction if charge is settled after authorization
     *
     * @return $this
     */
    public function setAuthTransaction($authTransaction)
    {
        $this->container['authTransaction'] = $authTransaction;

        return $this;
    }

    /**
     * Gets cardType
     *
     * @return string
     */
    public function getCardType()
    {
        return $this->container['cardType'];
    }

    /**
     * Sets cardType
     *
     * @param string $cardType Card type if credit card source: `unknown`, `visa`, `mc`, `dankort`, `visa_dk`, `ffk`, `visa_elec`, `maestro`, `laser`, `amex`, `diners`, `discover` or `jcb`
     *
     * @return $this
     */
    public function setCardType($cardType)
    {
        $allowedValues = $this->getCardTypeAllowableValues();
        if (!is_null($cardType) && !in_array($cardType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'cardType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['cardType'] = $cardType;

        return $this;
    }

    /**
     * Gets transactionCardType
     *
     * @return string
     */
    public function getTransactionCardType()
    {
        return $this->container['transactionCardType'];
    }

    /**
     * Sets transactionCardType
     *
     * @param string $transactionCardType Transaction card type if credit card source. Will differ from `card_type` if co-branded card. Transaction card type is the card type used for the transaction. `unknown`, `visa`, `mc`, `dankort`, `visa_dk`, `ffk`, `visa_elec`, `maestro`, `laser`, `amex`, `diners`, `discover` or `jcb`
     *
     * @return $this
     */
    public function setTransactionCardType($transactionCardType)
    {
        $allowedValues = $this->getTransactionCardTypeAllowableValues();
        if (!is_null($transactionCardType) && !in_array($transactionCardType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'transactionCardType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['transactionCardType'] = $transactionCardType;

        return $this;
    }

    /**
     * Gets expDate
     *
     * @return string
     */
    public function getExpDate()
    {
        return $this->container['expDate'];
    }

    /**
     * Sets expDate
     *
     * @param string $expDate Card expire date on form MM-YY if credit card source
     *
     * @return $this
     */
    public function setExpDate($expDate)
    {
        $this->container['expDate'] = $expDate;

        return $this;
    }

    /**
     * Gets maskedCard
     *
     * @return string
     */
    public function getMaskedCard()
    {
        return $this->container['maskedCard'];
    }

    /**
     * Sets maskedCard
     *
     * @param string $maskedCard Masked card number if credit card source
     *
     * @return $this
     */
    public function setMaskedCard($maskedCard)
    {
        $this->container['maskedCard'] = $maskedCard;

        return $this;
    }

    /**
     * Gets cardCountry
     *
     * @return string
     */
    public function getCardCountry()
    {
        return $this->container['cardCountry'];
    }

    /**
     * Sets cardCountry
     *
     * @param string $cardCountry Card issuing country if credit card source, in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
     *
     * @return $this
     */
    public function setCardCountry($cardCountry)
    {
        $this->container['cardCountry'] = $cardCountry;

        return $this;
    }

    /**
     * Gets strongAuthenticationStatus
     *
     * @return string
     */
    public function getStrongAuthenticationStatus()
    {
        return $this->container['strongAuthenticationStatus'];
    }

    /**
     * Sets strongAuthenticationStatus
     *
     * @param string $strongAuthenticationStatus Status for strong customer authentication: `threed_secure` - 3D Secure authenticated, `threed_secure_not_enrolled` - 3D Secure authentication not performed as card not enrolled, `secured_by_nets` - Secure by Nets authenticated
     *
     * @return $this
     */
    public function setStrongAuthenticationStatus($strongAuthenticationStatus)
    {
        $allowedValues = $this->getStrongAuthenticationStatusAllowableValues();
        if (!is_null($strongAuthenticationStatus) && !in_array($strongAuthenticationStatus, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'strongAuthenticationStatus', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['strongAuthenticationStatus'] = $strongAuthenticationStatus;

        return $this;
    }

    /**
     * Gets threeDSecureStatus
     *
     * @return string
     */
    public function getThreeDSecureStatus()
    {
        return $this->container['threeDSecureStatus'];
    }

    /**
     * Sets threeDSecureStatus
     *
     * @param string $threeDSecureStatus If 3D Secure authenticated the 3D status will either be `Y` (fully authenticated) or `A` (attempted authenticated). An attempted authentication means that card issuer (e.g. bank) does not support 3D Secure so no full authentication has been performed. Attempted authentication normally means liability shift, but this can differ between acquirers.
     *
     * @return $this
     */
    public function setThreeDSecureStatus($threeDSecureStatus)
    {
        $this->container['threeDSecureStatus'] = $threeDSecureStatus;

        return $this;
    }

    /**
     * Gets riskRule
     *
     * @return string
     */
    public function getRiskRule()
    {
        return $this->container['riskRule'];
    }

    /**
     * Sets riskRule
     *
     * @param string $riskRule If this parameter is set the charge has either been flagged or declined by a Reepay Risk Filter rule. For flag action rules the charge can be successful, but may require special attention. For block action rules the decline error will be `risk_filter_block`.
     *
     * @return $this
     */
    public function setRiskRule($riskRule)
    {
        $this->container['riskRule'] = $riskRule;

        return $this;
    }

    /**
     * Gets acquirerCode
     *
     * @return string
     */
    public function getAcquirerCode()
    {
        return $this->container['acquirerCode'];
    }

    /**
     * Sets acquirerCode
     *
     * @param string $acquirerCode Card acquirer error code in case of card error
     *
     * @return $this
     */
    public function setAcquirerCode($acquirerCode)
    {
        $this->container['acquirerCode'] = $acquirerCode;

        return $this;
    }

    /**
     * Gets acquirerMessage
     *
     * @return string
     */
    public function getAcquirerMessage()
    {
        return $this->container['acquirerMessage'];
    }

    /**
     * Sets acquirerMessage
     *
     * @param string $acquirerMessage Acquirer message in case of error
     *
     * @return $this
     */
    public function setAcquirerMessage($acquirerMessage)
    {
        $this->container['acquirerMessage'] = $acquirerMessage;

        return $this;
    }

    /**
     * Gets acquirerReference
     *
     * @return string
     */
    public function getAcquirerReference()
    {
        return $this->container['acquirerReference'];
    }

    /**
     * Sets acquirerReference
     *
     * @param string $acquirerReference Card acquirer reference to transaction in case of card source. E.g. Nets order id or Clearhaus reference.
     *
     * @return $this
     */
    public function setAcquirerReference($acquirerReference)
    {
        $this->container['acquirerReference'] = $acquirerReference;

        return $this;
    }

    /**
     * Gets textOnStatement
     *
     * @return string
     */
    public function getTextOnStatement()
    {
        return $this->container['textOnStatement'];
    }

    /**
     * Sets textOnStatement
     *
     * @param string $textOnStatement Resulting text on bank statement if known
     *
     * @return $this
     */
    public function setTextOnStatement($textOnStatement)
    {
        $this->container['textOnStatement'] = $textOnStatement;

        return $this;
    }

    /**
     * Gets surchargeFee
     *
     * @return int
     */
    public function getSurchargeFee()
    {
        return $this->container['surchargeFee'];
    }

    /**
     * Sets surchargeFee
     *
     * @param int $surchargeFee Potential card surcharge fee added to amount if surcharging enabled
     *
     * @return $this
     */
    public function setSurchargeFee($surchargeFee)
    {
        $this->container['surchargeFee'] = $surchargeFee;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


