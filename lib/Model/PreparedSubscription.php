<?php
/**
 * PreparedSubscription
 *
 * PHP version 5
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * API
 *
 * REST API to manage Reepay resources
 *
 * OpenAPI spec version: 1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.28
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Reepay\Model;

use \ArrayAccess;
use \Reepay\ObjectSerializer;

/**
 * PreparedSubscription Class Doc Comment
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PreparedSubscription implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'PreparedSubscription';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'handle' => 'string',
        'customer' => 'string',
        'plan' => 'string',
        'state' => 'string',
        'test' => 'bool',
        'amount' => 'int',
        'quantity' => 'int',
        'expires' => '\DateTime',
        'reactivated' => '\DateTime',
        'timezone' => 'string',
        'created' => '\DateTime',
        'activated' => '\DateTime',
        'renewing' => 'bool',
        'invoices' => '\Reepay\Model\Invoice[]',
        'planVersion' => 'int',
        'amountInclVat' => 'bool',
        'startDate' => '\DateTime',
        'endDate' => '\DateTime',
        'graceDuration' => 'int',
        'currentPeriodStart' => '\DateTime',
        'nextPeriodStart' => '\DateTime',
        'firstPeriodStart' => '\DateTime',
        'lastPeriodStart' => '\DateTime',
        'trialStart' => '\DateTime',
        'trialEnd' => '\DateTime',
        'isCancelled' => 'bool',
        'inTrial' => 'bool',
        'hasStarted' => 'bool',
        'renewalCount' => 'int',
        'cancelledDate' => '\DateTime',
        'expiredDate' => '\DateTime',
        'expireReason' => 'string',
        'onHoldDate' => '\DateTime',
        'onHoldReason' => 'string',
        'paymentMethodAdded' => 'bool',
        'scheduledPlanChange' => 'string',
        'reminderEmailSent' => '\DateTime',
        'failedInvoices' => 'int',
        'failedAmount' => 'int',
        'cancelledInvoices' => 'int',
        'cancelledAmount' => 'int',
        'pendingInvoices' => 'int',
        'pendingAmount' => 'int',
        'dunningInvoices' => 'int',
        'dunningAmount' => 'int',
        'settledInvoices' => 'int',
        'settledAmount' => 'int',
        'refundedAmount' => 'int',
        'pendingAdditionalCosts' => 'int',
        'pendingAdditionalCostAmount' => 'int',
        'transferredAdditionalCosts' => 'int',
        'transferredAdditionalCostAmount' => 'int',
        'pendingCredits' => 'int',
        'pendingCreditAmount' => 'int',
        'transferredCredits' => 'int',
        'transferredCreditAmount' => 'int',
        'hostedPageLinks' => '\Reepay\Model\SubscriptionLinks',
        'subscriptionDiscounts' => 'string[]',
        'pendingChange' => '\Reepay\Model\SubscriptionChange',
        'subscriptionChanges' => '\Reepay\Model\SubscriptionChange[]',
        'subscriptionAddOns' => 'string[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'handle' => null,
        'customer' => null,
        'plan' => null,
        'state' => null,
        'test' => null,
        'amount' => 'int32',
        'quantity' => 'int32',
        'expires' => 'date-time',
        'reactivated' => 'date-time',
        'timezone' => null,
        'created' => 'date-time',
        'activated' => 'date-time',
        'renewing' => null,
        'invoices' => null,
        'planVersion' => 'int32',
        'amountInclVat' => null,
        'startDate' => 'date-time',
        'endDate' => 'date-time',
        'graceDuration' => 'int64',
        'currentPeriodStart' => 'date-time',
        'nextPeriodStart' => 'date-time',
        'firstPeriodStart' => 'date-time',
        'lastPeriodStart' => 'date-time',
        'trialStart' => 'date-time',
        'trialEnd' => 'date-time',
        'isCancelled' => null,
        'inTrial' => null,
        'hasStarted' => null,
        'renewalCount' => 'int32',
        'cancelledDate' => 'date-time',
        'expiredDate' => 'date-time',
        'expireReason' => null,
        'onHoldDate' => 'date-time',
        'onHoldReason' => null,
        'paymentMethodAdded' => null,
        'scheduledPlanChange' => null,
        'reminderEmailSent' => 'date-time',
        'failedInvoices' => 'int32',
        'failedAmount' => 'int32',
        'cancelledInvoices' => 'int32',
        'cancelledAmount' => 'int32',
        'pendingInvoices' => 'int32',
        'pendingAmount' => 'int32',
        'dunningInvoices' => 'int32',
        'dunningAmount' => 'int32',
        'settledInvoices' => 'int32',
        'settledAmount' => 'int32',
        'refundedAmount' => 'int32',
        'pendingAdditionalCosts' => 'int32',
        'pendingAdditionalCostAmount' => 'int32',
        'transferredAdditionalCosts' => 'int32',
        'transferredAdditionalCostAmount' => 'int32',
        'pendingCredits' => 'int32',
        'pendingCreditAmount' => 'int32',
        'transferredCredits' => 'int32',
        'transferredCreditAmount' => 'int32',
        'hostedPageLinks' => null,
        'subscriptionDiscounts' => null,
        'pendingChange' => null,
        'subscriptionChanges' => null,
        'subscriptionAddOns' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'handle' => 'handle',
        'customer' => 'customer',
        'plan' => 'plan',
        'state' => 'state',
        'test' => 'test',
        'amount' => 'amount',
        'quantity' => 'quantity',
        'expires' => 'expires',
        'reactivated' => 'reactivated',
        'timezone' => 'timezone',
        'created' => 'created',
        'activated' => 'activated',
        'renewing' => 'renewing',
        'invoices' => 'invoices',
        'planVersion' => 'plan_version',
        'amountInclVat' => 'amount_incl_vat',
        'startDate' => 'start_date',
        'endDate' => 'end_date',
        'graceDuration' => 'grace_duration',
        'currentPeriodStart' => 'current_period_start',
        'nextPeriodStart' => 'next_period_start',
        'firstPeriodStart' => 'first_period_start',
        'lastPeriodStart' => 'last_period_start',
        'trialStart' => 'trial_start',
        'trialEnd' => 'trial_end',
        'isCancelled' => 'is_cancelled',
        'inTrial' => 'in_trial',
        'hasStarted' => 'has_started',
        'renewalCount' => 'renewal_count',
        'cancelledDate' => 'cancelled_date',
        'expiredDate' => 'expired_date',
        'expireReason' => 'expire_reason',
        'onHoldDate' => 'on_hold_date',
        'onHoldReason' => 'on_hold_reason',
        'paymentMethodAdded' => 'payment_method_added',
        'scheduledPlanChange' => 'scheduled_plan_change',
        'reminderEmailSent' => 'reminder_email_sent',
        'failedInvoices' => 'failed_invoices',
        'failedAmount' => 'failed_amount',
        'cancelledInvoices' => 'cancelled_invoices',
        'cancelledAmount' => 'cancelled_amount',
        'pendingInvoices' => 'pending_invoices',
        'pendingAmount' => 'pending_amount',
        'dunningInvoices' => 'dunning_invoices',
        'dunningAmount' => 'dunning_amount',
        'settledInvoices' => 'settled_invoices',
        'settledAmount' => 'settled_amount',
        'refundedAmount' => 'refunded_amount',
        'pendingAdditionalCosts' => 'pending_additional_costs',
        'pendingAdditionalCostAmount' => 'pending_additional_cost_amount',
        'transferredAdditionalCosts' => 'transferred_additional_costs',
        'transferredAdditionalCostAmount' => 'transferred_additional_cost_amount',
        'pendingCredits' => 'pending_credits',
        'pendingCreditAmount' => 'pending_credit_amount',
        'transferredCredits' => 'transferred_credits',
        'transferredCreditAmount' => 'transferred_credit_amount',
        'hostedPageLinks' => 'hosted_page_links',
        'subscriptionDiscounts' => 'subscription_discounts',
        'pendingChange' => 'pending_change',
        'subscriptionChanges' => 'subscription_changes',
        'subscriptionAddOns' => 'subscription_add_ons'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'handle' => 'setHandle',
        'customer' => 'setCustomer',
        'plan' => 'setPlan',
        'state' => 'setState',
        'test' => 'setTest',
        'amount' => 'setAmount',
        'quantity' => 'setQuantity',
        'expires' => 'setExpires',
        'reactivated' => 'setReactivated',
        'timezone' => 'setTimezone',
        'created' => 'setCreated',
        'activated' => 'setActivated',
        'renewing' => 'setRenewing',
        'invoices' => 'setInvoices',
        'planVersion' => 'setPlanVersion',
        'amountInclVat' => 'setAmountInclVat',
        'startDate' => 'setStartDate',
        'endDate' => 'setEndDate',
        'graceDuration' => 'setGraceDuration',
        'currentPeriodStart' => 'setCurrentPeriodStart',
        'nextPeriodStart' => 'setNextPeriodStart',
        'firstPeriodStart' => 'setFirstPeriodStart',
        'lastPeriodStart' => 'setLastPeriodStart',
        'trialStart' => 'setTrialStart',
        'trialEnd' => 'setTrialEnd',
        'isCancelled' => 'setIsCancelled',
        'inTrial' => 'setInTrial',
        'hasStarted' => 'setHasStarted',
        'renewalCount' => 'setRenewalCount',
        'cancelledDate' => 'setCancelledDate',
        'expiredDate' => 'setExpiredDate',
        'expireReason' => 'setExpireReason',
        'onHoldDate' => 'setOnHoldDate',
        'onHoldReason' => 'setOnHoldReason',
        'paymentMethodAdded' => 'setPaymentMethodAdded',
        'scheduledPlanChange' => 'setScheduledPlanChange',
        'reminderEmailSent' => 'setReminderEmailSent',
        'failedInvoices' => 'setFailedInvoices',
        'failedAmount' => 'setFailedAmount',
        'cancelledInvoices' => 'setCancelledInvoices',
        'cancelledAmount' => 'setCancelledAmount',
        'pendingInvoices' => 'setPendingInvoices',
        'pendingAmount' => 'setPendingAmount',
        'dunningInvoices' => 'setDunningInvoices',
        'dunningAmount' => 'setDunningAmount',
        'settledInvoices' => 'setSettledInvoices',
        'settledAmount' => 'setSettledAmount',
        'refundedAmount' => 'setRefundedAmount',
        'pendingAdditionalCosts' => 'setPendingAdditionalCosts',
        'pendingAdditionalCostAmount' => 'setPendingAdditionalCostAmount',
        'transferredAdditionalCosts' => 'setTransferredAdditionalCosts',
        'transferredAdditionalCostAmount' => 'setTransferredAdditionalCostAmount',
        'pendingCredits' => 'setPendingCredits',
        'pendingCreditAmount' => 'setPendingCreditAmount',
        'transferredCredits' => 'setTransferredCredits',
        'transferredCreditAmount' => 'setTransferredCreditAmount',
        'hostedPageLinks' => 'setHostedPageLinks',
        'subscriptionDiscounts' => 'setSubscriptionDiscounts',
        'pendingChange' => 'setPendingChange',
        'subscriptionChanges' => 'setSubscriptionChanges',
        'subscriptionAddOns' => 'setSubscriptionAddOns'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'handle' => 'getHandle',
        'customer' => 'getCustomer',
        'plan' => 'getPlan',
        'state' => 'getState',
        'test' => 'getTest',
        'amount' => 'getAmount',
        'quantity' => 'getQuantity',
        'expires' => 'getExpires',
        'reactivated' => 'getReactivated',
        'timezone' => 'getTimezone',
        'created' => 'getCreated',
        'activated' => 'getActivated',
        'renewing' => 'getRenewing',
        'invoices' => 'getInvoices',
        'planVersion' => 'getPlanVersion',
        'amountInclVat' => 'getAmountInclVat',
        'startDate' => 'getStartDate',
        'endDate' => 'getEndDate',
        'graceDuration' => 'getGraceDuration',
        'currentPeriodStart' => 'getCurrentPeriodStart',
        'nextPeriodStart' => 'getNextPeriodStart',
        'firstPeriodStart' => 'getFirstPeriodStart',
        'lastPeriodStart' => 'getLastPeriodStart',
        'trialStart' => 'getTrialStart',
        'trialEnd' => 'getTrialEnd',
        'isCancelled' => 'getIsCancelled',
        'inTrial' => 'getInTrial',
        'hasStarted' => 'getHasStarted',
        'renewalCount' => 'getRenewalCount',
        'cancelledDate' => 'getCancelledDate',
        'expiredDate' => 'getExpiredDate',
        'expireReason' => 'getExpireReason',
        'onHoldDate' => 'getOnHoldDate',
        'onHoldReason' => 'getOnHoldReason',
        'paymentMethodAdded' => 'getPaymentMethodAdded',
        'scheduledPlanChange' => 'getScheduledPlanChange',
        'reminderEmailSent' => 'getReminderEmailSent',
        'failedInvoices' => 'getFailedInvoices',
        'failedAmount' => 'getFailedAmount',
        'cancelledInvoices' => 'getCancelledInvoices',
        'cancelledAmount' => 'getCancelledAmount',
        'pendingInvoices' => 'getPendingInvoices',
        'pendingAmount' => 'getPendingAmount',
        'dunningInvoices' => 'getDunningInvoices',
        'dunningAmount' => 'getDunningAmount',
        'settledInvoices' => 'getSettledInvoices',
        'settledAmount' => 'getSettledAmount',
        'refundedAmount' => 'getRefundedAmount',
        'pendingAdditionalCosts' => 'getPendingAdditionalCosts',
        'pendingAdditionalCostAmount' => 'getPendingAdditionalCostAmount',
        'transferredAdditionalCosts' => 'getTransferredAdditionalCosts',
        'transferredAdditionalCostAmount' => 'getTransferredAdditionalCostAmount',
        'pendingCredits' => 'getPendingCredits',
        'pendingCreditAmount' => 'getPendingCreditAmount',
        'transferredCredits' => 'getTransferredCredits',
        'transferredCreditAmount' => 'getTransferredCreditAmount',
        'hostedPageLinks' => 'getHostedPageLinks',
        'subscriptionDiscounts' => 'getSubscriptionDiscounts',
        'pendingChange' => 'getPendingChange',
        'subscriptionChanges' => 'getSubscriptionChanges',
        'subscriptionAddOns' => 'getSubscriptionAddOns'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const STATE_ACTIVE = 'active';
    const STATE_EXPIRED = 'expired';
    const STATE_ON_HOLD = 'on_hold';
    const STATE_PENDING = 'pending';
    const EXPIRE_REASON_DUNNING = 'dunning';
    const EXPIRE_REASON_CANCELLED = 'cancelled';
    const EXPIRE_REASON_ONDEMAND = 'ondemand';
    const EXPIRE_REASON_FIXED = 'fixed';
    const ON_HOLD_REASON_DUNNING = 'dunning';
    const ON_HOLD_REASON_ONDEMAND = 'ondemand';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStateAllowableValues()
    {
        return [
            self::STATE_ACTIVE,
            self::STATE_EXPIRED,
            self::STATE_ON_HOLD,
            self::STATE_PENDING,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getExpireReasonAllowableValues()
    {
        return [
            self::EXPIRE_REASON_DUNNING,
            self::EXPIRE_REASON_CANCELLED,
            self::EXPIRE_REASON_ONDEMAND,
            self::EXPIRE_REASON_FIXED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getOnHoldReasonAllowableValues()
    {
        return [
            self::ON_HOLD_REASON_DUNNING,
            self::ON_HOLD_REASON_ONDEMAND,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['handle'] = isset($data['handle']) ? $data['handle'] : null;
        $this->container['customer'] = isset($data['customer']) ? $data['customer'] : null;
        $this->container['plan'] = isset($data['plan']) ? $data['plan'] : null;
        $this->container['state'] = isset($data['state']) ? $data['state'] : null;
        $this->container['test'] = isset($data['test']) ? $data['test'] : null;
        $this->container['amount'] = isset($data['amount']) ? $data['amount'] : null;
        $this->container['quantity'] = isset($data['quantity']) ? $data['quantity'] : null;
        $this->container['expires'] = isset($data['expires']) ? $data['expires'] : null;
        $this->container['reactivated'] = isset($data['reactivated']) ? $data['reactivated'] : null;
        $this->container['timezone'] = isset($data['timezone']) ? $data['timezone'] : null;
        $this->container['created'] = isset($data['created']) ? $data['created'] : null;
        $this->container['activated'] = isset($data['activated']) ? $data['activated'] : null;
        $this->container['renewing'] = isset($data['renewing']) ? $data['renewing'] : null;
        $this->container['invoices'] = isset($data['invoices']) ? $data['invoices'] : null;
        $this->container['planVersion'] = isset($data['planVersion']) ? $data['planVersion'] : null;
        $this->container['amountInclVat'] = isset($data['amountInclVat']) ? $data['amountInclVat'] : null;
        $this->container['startDate'] = isset($data['startDate']) ? $data['startDate'] : null;
        $this->container['endDate'] = isset($data['endDate']) ? $data['endDate'] : null;
        $this->container['graceDuration'] = isset($data['graceDuration']) ? $data['graceDuration'] : null;
        $this->container['currentPeriodStart'] = isset($data['currentPeriodStart']) ? $data['currentPeriodStart'] : null;
        $this->container['nextPeriodStart'] = isset($data['nextPeriodStart']) ? $data['nextPeriodStart'] : null;
        $this->container['firstPeriodStart'] = isset($data['firstPeriodStart']) ? $data['firstPeriodStart'] : null;
        $this->container['lastPeriodStart'] = isset($data['lastPeriodStart']) ? $data['lastPeriodStart'] : null;
        $this->container['trialStart'] = isset($data['trialStart']) ? $data['trialStart'] : null;
        $this->container['trialEnd'] = isset($data['trialEnd']) ? $data['trialEnd'] : null;
        $this->container['isCancelled'] = isset($data['isCancelled']) ? $data['isCancelled'] : null;
        $this->container['inTrial'] = isset($data['inTrial']) ? $data['inTrial'] : null;
        $this->container['hasStarted'] = isset($data['hasStarted']) ? $data['hasStarted'] : null;
        $this->container['renewalCount'] = isset($data['renewalCount']) ? $data['renewalCount'] : null;
        $this->container['cancelledDate'] = isset($data['cancelledDate']) ? $data['cancelledDate'] : null;
        $this->container['expiredDate'] = isset($data['expiredDate']) ? $data['expiredDate'] : null;
        $this->container['expireReason'] = isset($data['expireReason']) ? $data['expireReason'] : null;
        $this->container['onHoldDate'] = isset($data['onHoldDate']) ? $data['onHoldDate'] : null;
        $this->container['onHoldReason'] = isset($data['onHoldReason']) ? $data['onHoldReason'] : null;
        $this->container['paymentMethodAdded'] = isset($data['paymentMethodAdded']) ? $data['paymentMethodAdded'] : null;
        $this->container['scheduledPlanChange'] = isset($data['scheduledPlanChange']) ? $data['scheduledPlanChange'] : null;
        $this->container['reminderEmailSent'] = isset($data['reminderEmailSent']) ? $data['reminderEmailSent'] : null;
        $this->container['failedInvoices'] = isset($data['failedInvoices']) ? $data['failedInvoices'] : null;
        $this->container['failedAmount'] = isset($data['failedAmount']) ? $data['failedAmount'] : null;
        $this->container['cancelledInvoices'] = isset($data['cancelledInvoices']) ? $data['cancelledInvoices'] : null;
        $this->container['cancelledAmount'] = isset($data['cancelledAmount']) ? $data['cancelledAmount'] : null;
        $this->container['pendingInvoices'] = isset($data['pendingInvoices']) ? $data['pendingInvoices'] : null;
        $this->container['pendingAmount'] = isset($data['pendingAmount']) ? $data['pendingAmount'] : null;
        $this->container['dunningInvoices'] = isset($data['dunningInvoices']) ? $data['dunningInvoices'] : null;
        $this->container['dunningAmount'] = isset($data['dunningAmount']) ? $data['dunningAmount'] : null;
        $this->container['settledInvoices'] = isset($data['settledInvoices']) ? $data['settledInvoices'] : null;
        $this->container['settledAmount'] = isset($data['settledAmount']) ? $data['settledAmount'] : null;
        $this->container['refundedAmount'] = isset($data['refundedAmount']) ? $data['refundedAmount'] : null;
        $this->container['pendingAdditionalCosts'] = isset($data['pendingAdditionalCosts']) ? $data['pendingAdditionalCosts'] : null;
        $this->container['pendingAdditionalCostAmount'] = isset($data['pendingAdditionalCostAmount']) ? $data['pendingAdditionalCostAmount'] : null;
        $this->container['transferredAdditionalCosts'] = isset($data['transferredAdditionalCosts']) ? $data['transferredAdditionalCosts'] : null;
        $this->container['transferredAdditionalCostAmount'] = isset($data['transferredAdditionalCostAmount']) ? $data['transferredAdditionalCostAmount'] : null;
        $this->container['pendingCredits'] = isset($data['pendingCredits']) ? $data['pendingCredits'] : null;
        $this->container['pendingCreditAmount'] = isset($data['pendingCreditAmount']) ? $data['pendingCreditAmount'] : null;
        $this->container['transferredCredits'] = isset($data['transferredCredits']) ? $data['transferredCredits'] : null;
        $this->container['transferredCreditAmount'] = isset($data['transferredCreditAmount']) ? $data['transferredCreditAmount'] : null;
        $this->container['hostedPageLinks'] = isset($data['hostedPageLinks']) ? $data['hostedPageLinks'] : null;
        $this->container['subscriptionDiscounts'] = isset($data['subscriptionDiscounts']) ? $data['subscriptionDiscounts'] : null;
        $this->container['pendingChange'] = isset($data['pendingChange']) ? $data['pendingChange'] : null;
        $this->container['subscriptionChanges'] = isset($data['subscriptionChanges']) ? $data['subscriptionChanges'] : null;
        $this->container['subscriptionAddOns'] = isset($data['subscriptionAddOns']) ? $data['subscriptionAddOns'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['handle'] === null) {
            $invalidProperties[] = "'handle' can't be null";
        }
        if ($this->container['customer'] === null) {
            $invalidProperties[] = "'customer' can't be null";
        }
        if ($this->container['plan'] === null) {
            $invalidProperties[] = "'plan' can't be null";
        }
        if ($this->container['state'] === null) {
            $invalidProperties[] = "'state' can't be null";
        }
        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($this->container['state']) && !in_array($this->container['state'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'state', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['test'] === null) {
            $invalidProperties[] = "'test' can't be null";
        }
        if ($this->container['quantity'] === null) {
            $invalidProperties[] = "'quantity' can't be null";
        }
        if ($this->container['timezone'] === null) {
            $invalidProperties[] = "'timezone' can't be null";
        }
        if ($this->container['created'] === null) {
            $invalidProperties[] = "'created' can't be null";
        }
        if ($this->container['renewing'] === null) {
            $invalidProperties[] = "'renewing' can't be null";
        }
        if ($this->container['planVersion'] === null) {
            $invalidProperties[] = "'planVersion' can't be null";
        }
        if ($this->container['startDate'] === null) {
            $invalidProperties[] = "'startDate' can't be null";
        }
        if ($this->container['isCancelled'] === null) {
            $invalidProperties[] = "'isCancelled' can't be null";
        }
        if ($this->container['inTrial'] === null) {
            $invalidProperties[] = "'inTrial' can't be null";
        }
        if ($this->container['hasStarted'] === null) {
            $invalidProperties[] = "'hasStarted' can't be null";
        }
        if ($this->container['renewalCount'] === null) {
            $invalidProperties[] = "'renewalCount' can't be null";
        }
        if (($this->container['renewalCount'] < 0)) {
            $invalidProperties[] = "invalid value for 'renewalCount', must be bigger than or equal to 0.";
        }

        $allowedValues = $this->getExpireReasonAllowableValues();
        if (!is_null($this->container['expireReason']) && !in_array($this->container['expireReason'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'expireReason', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getOnHoldReasonAllowableValues();
        if (!is_null($this->container['onHoldReason']) && !in_array($this->container['onHoldReason'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'onHoldReason', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['paymentMethodAdded'] === null) {
            $invalidProperties[] = "'paymentMethodAdded' can't be null";
        }
        if ($this->container['reminderEmailSent'] === null) {
            $invalidProperties[] = "'reminderEmailSent' can't be null";
        }
        if ($this->container['failedInvoices'] === null) {
            $invalidProperties[] = "'failedInvoices' can't be null";
        }
        if ($this->container['failedAmount'] === null) {
            $invalidProperties[] = "'failedAmount' can't be null";
        }
        if ($this->container['cancelledInvoices'] === null) {
            $invalidProperties[] = "'cancelledInvoices' can't be null";
        }
        if ($this->container['cancelledAmount'] === null) {
            $invalidProperties[] = "'cancelledAmount' can't be null";
        }
        if ($this->container['pendingInvoices'] === null) {
            $invalidProperties[] = "'pendingInvoices' can't be null";
        }
        if ($this->container['pendingAmount'] === null) {
            $invalidProperties[] = "'pendingAmount' can't be null";
        }
        if ($this->container['dunningInvoices'] === null) {
            $invalidProperties[] = "'dunningInvoices' can't be null";
        }
        if ($this->container['dunningAmount'] === null) {
            $invalidProperties[] = "'dunningAmount' can't be null";
        }
        if ($this->container['settledInvoices'] === null) {
            $invalidProperties[] = "'settledInvoices' can't be null";
        }
        if ($this->container['settledAmount'] === null) {
            $invalidProperties[] = "'settledAmount' can't be null";
        }
        if ($this->container['refundedAmount'] === null) {
            $invalidProperties[] = "'refundedAmount' can't be null";
        }
        if ($this->container['pendingAdditionalCosts'] === null) {
            $invalidProperties[] = "'pendingAdditionalCosts' can't be null";
        }
        if ($this->container['pendingAdditionalCostAmount'] === null) {
            $invalidProperties[] = "'pendingAdditionalCostAmount' can't be null";
        }
        if ($this->container['transferredAdditionalCosts'] === null) {
            $invalidProperties[] = "'transferredAdditionalCosts' can't be null";
        }
        if ($this->container['transferredAdditionalCostAmount'] === null) {
            $invalidProperties[] = "'transferredAdditionalCostAmount' can't be null";
        }
        if ($this->container['pendingCredits'] === null) {
            $invalidProperties[] = "'pendingCredits' can't be null";
        }
        if ($this->container['pendingCreditAmount'] === null) {
            $invalidProperties[] = "'pendingCreditAmount' can't be null";
        }
        if ($this->container['transferredCredits'] === null) {
            $invalidProperties[] = "'transferredCredits' can't be null";
        }
        if ($this->container['transferredCreditAmount'] === null) {
            $invalidProperties[] = "'transferredCreditAmount' can't be null";
        }
        if ($this->container['hostedPageLinks'] === null) {
            $invalidProperties[] = "'hostedPageLinks' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets handle
     *
     * @return string
     */
    public function getHandle()
    {
        return $this->container['handle'];
    }

    /**
     * Sets handle
     *
     * @param string $handle Per account unique handle for subscription
     *
     * @return $this
     */
    public function setHandle($handle)
    {
        $this->container['handle'] = $handle;

        return $this;
    }

    /**
     * Gets customer
     *
     * @return string
     */
    public function getCustomer()
    {
        return $this->container['customer'];
    }

    /**
     * Sets customer
     *
     * @param string $customer Customer handle
     *
     * @return $this
     */
    public function setCustomer($customer)
    {
        $this->container['customer'] = $customer;

        return $this;
    }

    /**
     * Gets plan
     *
     * @return string
     */
    public function getPlan()
    {
        return $this->container['plan'];
    }

    /**
     * Sets plan
     *
     * @param string $plan Subscription plan handle
     *
     * @return $this
     */
    public function setPlan($plan)
    {
        $this->container['plan'] = $plan;

        return $this;
    }

    /**
     * Gets state
     *
     * @return string
     */
    public function getState()
    {
        return $this->container['state'];
    }

    /**
     * Sets state
     *
     * @param string $state State of the subscription, one of the following: `active`, `expired`, `on_hold` or `pending`. Active subscriptions can be cancelled and will expire at the end of the current billing period, or later depending on optional notice and fixation periods, this can be checked using the `is_cancelled` parameter and `expires`.
     *
     * @return $this
     */
    public function setState($state)
    {
        $allowedValues = $this->getStateAllowableValues();
        if (!in_array($state, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'state', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['state'] = $state;

        return $this;
    }

    /**
     * Gets test
     *
     * @return bool
     */
    public function getTest()
    {
        return $this->container['test'];
    }

    /**
     * Sets test
     *
     * @param bool $test Test flag
     *
     * @return $this
     */
    public function setTest($test)
    {
        $this->container['test'] = $test;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return int
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param int $amount Optional custom plan price. If defined the plan price billed for each billing period will be overridden by this price.
     *
     * @return $this
     */
    public function setAmount($amount)
    {
        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets quantity
     *
     * @return int
     */
    public function getQuantity()
    {
        return $this->container['quantity'];
    }

    /**
     * Sets quantity
     *
     * @param int $quantity Quantity of the plan product for this subscription.
     *
     * @return $this
     */
    public function setQuantity($quantity)
    {
        $this->container['quantity'] = $quantity;

        return $this;
    }

    /**
     * Gets expires
     *
     * @return \DateTime
     */
    public function getExpires()
    {
        return $this->container['expires'];
    }

    /**
     * Sets expires
     *
     * @param \DateTime $expires Fixed date when the subscription will expire because of cancellation. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setExpires($expires)
    {
        $this->container['expires'] = $expires;

        return $this;
    }

    /**
     * Gets reactivated
     *
     * @return \DateTime
     */
    public function getReactivated()
    {
        return $this->container['reactivated'];
    }

    /**
     * Sets reactivated
     *
     * @param \DateTime $reactivated Date when the subscription was reactivated from on hold. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setReactivated($reactivated)
    {
        $this->container['reactivated'] = $reactivated;

        return $this;
    }

    /**
     * Gets timezone
     *
     * @return string
     */
    public function getTimezone()
    {
        return $this->container['timezone'];
    }

    /**
     * Sets timezone
     *
     * @param string $timezone Time zone for the subscription as standard time zone id. See [Wikipedia](http://en.wikipedia.org/wiki/List_of_tz_database_time_zones)
     *
     * @return $this
     */
    public function setTimezone($timezone)
    {
        $this->container['timezone'] = $timezone;

        return $this;
    }

    /**
     * Gets created
     *
     * @return \DateTime
     */
    public function getCreated()
    {
        return $this->container['created'];
    }

    /**
     * Sets created
     *
     * @param \DateTime $created Date when the subscription was created. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setCreated($created)
    {
        $this->container['created'] = $created;

        return $this;
    }

    /**
     * Gets activated
     *
     * @return \DateTime
     */
    public function getActivated()
    {
        return $this->container['activated'];
    }

    /**
     * Sets activated
     *
     * @param \DateTime $activated Date when the subscription was activated. Will only differ from created in a two step prepared -> activated subscription create scenario. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setActivated($activated)
    {
        $this->container['activated'] = $activated;

        return $this;
    }

    /**
     * Gets renewing
     *
     * @return bool
     */
    public function getRenewing()
    {
        return $this->container['renewing'];
    }

    /**
     * Sets renewing
     *
     * @param bool $renewing If the subscription renews at current period end. Also true for subscriptions with manual scheduling.
     *
     * @return $this
     */
    public function setRenewing($renewing)
    {
        $this->container['renewing'] = $renewing;

        return $this;
    }

    /**
     * Gets invoices
     *
     * @return \Reepay\Model\Invoice[]
     */
    public function getInvoices()
    {
        return $this->container['invoices'];
    }

    /**
     * Sets invoices
     *
     * @param \Reepay\Model\Invoice[] $invoices List of created (prepared) invoices for prepared subscription
     *
     * @return $this
     */
    public function setInvoices($invoices)
    {
        $this->container['invoices'] = $invoices;

        return $this;
    }

    /**
     * Gets planVersion
     *
     * @return int
     */
    public function getPlanVersion()
    {
        return $this->container['planVersion'];
    }

    /**
     * Sets planVersion
     *
     * @param int $planVersion Subscription plan version
     *
     * @return $this
     */
    public function setPlanVersion($planVersion)
    {
        $this->container['planVersion'] = $planVersion;

        return $this;
    }

    /**
     * Gets amountInclVat
     *
     * @return bool
     */
    public function getAmountInclVat()
    {
        return $this->container['amountInclVat'];
    }

    /**
     * Sets amountInclVat
     *
     * @param bool $amountInclVat If optional custom plan price this parameter tells whether the amount is including VAT
     *
     * @return $this
     */
    public function setAmountInclVat($amountInclVat)
    {
        $this->container['amountInclVat'] = $amountInclVat;

        return $this;
    }

    /**
     * Gets startDate
     *
     * @return \DateTime
     */
    public function getStartDate()
    {
        return $this->container['startDate'];
    }

    /**
     * Sets startDate
     *
     * @param \DateTime $startDate Date and time from which the subscription is eligible to schedule invoices. Either from create or from the latest reactivate or subscription change. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setStartDate($startDate)
    {
        $this->container['startDate'] = $startDate;

        return $this;
    }

    /**
     * Gets endDate
     *
     * @return \DateTime
     */
    public function getEndDate()
    {
        return $this->container['endDate'];
    }

    /**
     * Sets endDate
     *
     * @param \DateTime $endDate Fixed end date and time. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setEndDate($endDate)
    {
        $this->container['endDate'] = $endDate;

        return $this;
    }

    /**
     * Gets graceDuration
     *
     * @return int
     */
    public function getGraceDuration()
    {
        return $this->container['graceDuration'];
    }

    /**
     * Sets graceDuration
     *
     * @param int $graceDuration Grace duration in seconds from the creation of a subscription where no dunning process is started for a failing invoice. This allows a certain amount of time for the customer to sign up with a payment method.
     *
     * @return $this
     */
    public function setGraceDuration($graceDuration)
    {
        $this->container['graceDuration'] = $graceDuration;

        return $this;
    }

    /**
     * Gets currentPeriodStart
     *
     * @return \DateTime
     */
    public function getCurrentPeriodStart()
    {
        return $this->container['currentPeriodStart'];
    }

    /**
     * Sets currentPeriodStart
     *
     * @param \DateTime $currentPeriodStart Start date and time for the current billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setCurrentPeriodStart($currentPeriodStart)
    {
        $this->container['currentPeriodStart'] = $currentPeriodStart;

        return $this;
    }

    /**
     * Gets nextPeriodStart
     *
     * @return \DateTime
     */
    public function getNextPeriodStart()
    {
        return $this->container['nextPeriodStart'];
    }

    /**
     * Sets nextPeriodStart
     *
     * @param \DateTime $nextPeriodStart Start date and time for the next billing period, and also end date and time for the current billing period. Is also the date and time for next invoice if the subscription is renewing. In ISO-8601 extended offset date-time format.
     *
     * @return $this
     */
    public function setNextPeriodStart($nextPeriodStart)
    {
        $this->container['nextPeriodStart'] = $nextPeriodStart;

        return $this;
    }

    /**
     * Gets firstPeriodStart
     *
     * @return \DateTime
     */
    public function getFirstPeriodStart()
    {
        return $this->container['firstPeriodStart'];
    }

    /**
     * Sets firstPeriodStart
     *
     * @param \DateTime $firstPeriodStart Start date and time for the first ever billing period. In ISO-8601 extended offset date-time format.
     *
     * @return $this
     */
    public function setFirstPeriodStart($firstPeriodStart)
    {
        $this->container['firstPeriodStart'] = $firstPeriodStart;

        return $this;
    }

    /**
     * Gets lastPeriodStart
     *
     * @return \DateTime
     */
    public function getLastPeriodStart()
    {
        return $this->container['lastPeriodStart'];
    }

    /**
     * Sets lastPeriodStart
     *
     * @param \DateTime $lastPeriodStart Start date and time for the previous billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setLastPeriodStart($lastPeriodStart)
    {
        $this->container['lastPeriodStart'] = $lastPeriodStart;

        return $this;
    }

    /**
     * Gets trialStart
     *
     * @return \DateTime
     */
    public function getTrialStart()
    {
        return $this->container['trialStart'];
    }

    /**
     * Sets trialStart
     *
     * @param \DateTime $trialStart Start date and time of free trial period. In ISO-8601 extended offset date-time format.
     *
     * @return $this
     */
    public function setTrialStart($trialStart)
    {
        $this->container['trialStart'] = $trialStart;

        return $this;
    }

    /**
     * Gets trialEnd
     *
     * @return \DateTime
     */
    public function getTrialEnd()
    {
        return $this->container['trialEnd'];
    }

    /**
     * Sets trialEnd
     *
     * @param \DateTime $trialEnd End date and time of free trial period. In ISO-8601 extended offset date-time format.
     *
     * @return $this
     */
    public function setTrialEnd($trialEnd)
    {
        $this->container['trialEnd'] = $trialEnd;

        return $this;
    }

    /**
     * Gets isCancelled
     *
     * @return bool
     */
    public function getIsCancelled()
    {
        return $this->container['isCancelled'];
    }

    /**
     * Sets isCancelled
     *
     * @param bool $isCancelled Whether the subscription has been cancelled. Cancelled subscriptions will expire at the end of the current billing period.
     *
     * @return $this
     */
    public function setIsCancelled($isCancelled)
    {
        $this->container['isCancelled'] = $isCancelled;

        return $this;
    }

    /**
     * Gets inTrial
     *
     * @return bool
     */
    public function getInTrial()
    {
        return $this->container['inTrial'];
    }

    /**
     * Sets inTrial
     *
     * @param bool $inTrial Whether the subscription is in its trial period, or if the subscription will start a trial period at a start date in the future. See `has_started` to determine if the actual trial period has started or not.
     *
     * @return $this
     */
    public function setInTrial($inTrial)
    {
        $this->container['inTrial'] = $inTrial;

        return $this;
    }

    /**
     * Gets hasStarted
     *
     * @return bool
     */
    public function getHasStarted()
    {
        return $this->container['hasStarted'];
    }

    /**
     * Sets hasStarted
     *
     * @param bool $hasStarted If subscription has a later start date, this parameter tells if the subscription has started. Use this in connection with state to determine if a subscription is active.
     *
     * @return $this
     */
    public function setHasStarted($hasStarted)
    {
        $this->container['hasStarted'] = $hasStarted;

        return $this;
    }

    /**
     * Gets renewalCount
     *
     * @return int
     */
    public function getRenewalCount()
    {
        return $this->container['renewalCount'];
    }

    /**
     * Sets renewalCount
     *
     * @param int $renewalCount Number of renewals for the subscription (number of invoices)
     *
     * @return $this
     */
    public function setRenewalCount($renewalCount)
    {

        if (($renewalCount < 0)) {
            throw new \InvalidArgumentException('invalid value for $renewalCount when calling PreparedSubscription., must be bigger than or equal to 0.');
        }

        $this->container['renewalCount'] = $renewalCount;

        return $this;
    }

    /**
     * Gets cancelledDate
     *
     * @return \DateTime
     */
    public function getCancelledDate()
    {
        return $this->container['cancelledDate'];
    }

    /**
     * Sets cancelledDate
     *
     * @param \DateTime $cancelledDate Date when the subscription was cancelled. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setCancelledDate($cancelledDate)
    {
        $this->container['cancelledDate'] = $cancelledDate;

        return $this;
    }

    /**
     * Gets expiredDate
     *
     * @return \DateTime
     */
    public function getExpiredDate()
    {
        return $this->container['expiredDate'];
    }

    /**
     * Sets expiredDate
     *
     * @param \DateTime $expiredDate Date when the subscription expired. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setExpiredDate($expiredDate)
    {
        $this->container['expiredDate'] = $expiredDate;

        return $this;
    }

    /**
     * Gets expireReason
     *
     * @return string
     */
    public function getExpireReason()
    {
        return $this->container['expireReason'];
    }

    /**
     * Sets expireReason
     *
     * @param string $expireReason Reason for expire. Can be `ondemand`, `cancelled`, `dunning` or `fixed`
     *
     * @return $this
     */
    public function setExpireReason($expireReason)
    {
        $allowedValues = $this->getExpireReasonAllowableValues();
        if (!is_null($expireReason) && !in_array($expireReason, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'expireReason', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['expireReason'] = $expireReason;

        return $this;
    }

    /**
     * Gets onHoldDate
     *
     * @return \DateTime
     */
    public function getOnHoldDate()
    {
        return $this->container['onHoldDate'];
    }

    /**
     * Sets onHoldDate
     *
     * @param \DateTime $onHoldDate Date when the subscription was put on hold. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setOnHoldDate($onHoldDate)
    {
        $this->container['onHoldDate'] = $onHoldDate;

        return $this;
    }

    /**
     * Gets onHoldReason
     *
     * @return string
     */
    public function getOnHoldReason()
    {
        return $this->container['onHoldReason'];
    }

    /**
     * Sets onHoldReason
     *
     * @param string $onHoldReason Reason for on hold. Can be `ondemand` or `dunning`
     *
     * @return $this
     */
    public function setOnHoldReason($onHoldReason)
    {
        $allowedValues = $this->getOnHoldReasonAllowableValues();
        if (!is_null($onHoldReason) && !in_array($onHoldReason, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'onHoldReason', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['onHoldReason'] = $onHoldReason;

        return $this;
    }

    /**
     * Gets paymentMethodAdded
     *
     * @return bool
     */
    public function getPaymentMethodAdded()
    {
        return $this->container['paymentMethodAdded'];
    }

    /**
     * Sets paymentMethodAdded
     *
     * @param bool $paymentMethodAdded Whether the customer at some point has added payment information to the subscription
     *
     * @return $this
     */
    public function setPaymentMethodAdded($paymentMethodAdded)
    {
        $this->container['paymentMethodAdded'] = $paymentMethodAdded;

        return $this;
    }

    /**
     * Gets scheduledPlanChange
     *
     * @return string
     */
    public function getScheduledPlanChange()
    {
        return $this->container['scheduledPlanChange'];
    }

    /**
     * Sets scheduledPlanChange
     *
     * @param string $scheduledPlanChange Deprecated - see `pending_change`. If set, a subscription plan change has been scheduled to follow the next renewal. The value is the subscription plan handle to update to.
     *
     * @return $this
     */
    public function setScheduledPlanChange($scheduledPlanChange)
    {
        $this->container['scheduledPlanChange'] = $scheduledPlanChange;

        return $this;
    }

    /**
     * Gets reminderEmailSent
     *
     * @return \DateTime
     */
    public function getReminderEmailSent()
    {
        return $this->container['reminderEmailSent'];
    }

    /**
     * Sets reminderEmailSent
     *
     * @param \DateTime $reminderEmailSent If defined the date a reminder email was sent for the current billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setReminderEmailSent($reminderEmailSent)
    {
        $this->container['reminderEmailSent'] = $reminderEmailSent;

        return $this;
    }

    /**
     * Gets failedInvoices
     *
     * @return int
     */
    public function getFailedInvoices()
    {
        return $this->container['failedInvoices'];
    }

    /**
     * Sets failedInvoices
     *
     * @param int $failedInvoices Number of failed invoices for this subscription
     *
     * @return $this
     */
    public function setFailedInvoices($failedInvoices)
    {
        $this->container['failedInvoices'] = $failedInvoices;

        return $this;
    }

    /**
     * Gets failedAmount
     *
     * @return int
     */
    public function getFailedAmount()
    {
        return $this->container['failedAmount'];
    }

    /**
     * Sets failedAmount
     *
     * @param int $failedAmount Summed amount for failed invoices
     *
     * @return $this
     */
    public function setFailedAmount($failedAmount)
    {
        $this->container['failedAmount'] = $failedAmount;

        return $this;
    }

    /**
     * Gets cancelledInvoices
     *
     * @return int
     */
    public function getCancelledInvoices()
    {
        return $this->container['cancelledInvoices'];
    }

    /**
     * Sets cancelledInvoices
     *
     * @param int $cancelledInvoices Number of cancelled invoices for this subscription
     *
     * @return $this
     */
    public function setCancelledInvoices($cancelledInvoices)
    {
        $this->container['cancelledInvoices'] = $cancelledInvoices;

        return $this;
    }

    /**
     * Gets cancelledAmount
     *
     * @return int
     */
    public function getCancelledAmount()
    {
        return $this->container['cancelledAmount'];
    }

    /**
     * Sets cancelledAmount
     *
     * @param int $cancelledAmount Summed amount for cancelled invoices
     *
     * @return $this
     */
    public function setCancelledAmount($cancelledAmount)
    {
        $this->container['cancelledAmount'] = $cancelledAmount;

        return $this;
    }

    /**
     * Gets pendingInvoices
     *
     * @return int
     */
    public function getPendingInvoices()
    {
        return $this->container['pendingInvoices'];
    }

    /**
     * Sets pendingInvoices
     *
     * @param int $pendingInvoices Number of pending invoices for this subscription
     *
     * @return $this
     */
    public function setPendingInvoices($pendingInvoices)
    {
        $this->container['pendingInvoices'] = $pendingInvoices;

        return $this;
    }

    /**
     * Gets pendingAmount
     *
     * @return int
     */
    public function getPendingAmount()
    {
        return $this->container['pendingAmount'];
    }

    /**
     * Sets pendingAmount
     *
     * @param int $pendingAmount Summed amount for pending invoices
     *
     * @return $this
     */
    public function setPendingAmount($pendingAmount)
    {
        $this->container['pendingAmount'] = $pendingAmount;

        return $this;
    }

    /**
     * Gets dunningInvoices
     *
     * @return int
     */
    public function getDunningInvoices()
    {
        return $this->container['dunningInvoices'];
    }

    /**
     * Sets dunningInvoices
     *
     * @param int $dunningInvoices Number of dunning invoices for this subscription
     *
     * @return $this
     */
    public function setDunningInvoices($dunningInvoices)
    {
        $this->container['dunningInvoices'] = $dunningInvoices;

        return $this;
    }

    /**
     * Gets dunningAmount
     *
     * @return int
     */
    public function getDunningAmount()
    {
        return $this->container['dunningAmount'];
    }

    /**
     * Sets dunningAmount
     *
     * @param int $dunningAmount Summed amount for dunning invoices
     *
     * @return $this
     */
    public function setDunningAmount($dunningAmount)
    {
        $this->container['dunningAmount'] = $dunningAmount;

        return $this;
    }

    /**
     * Gets settledInvoices
     *
     * @return int
     */
    public function getSettledInvoices()
    {
        return $this->container['settledInvoices'];
    }

    /**
     * Sets settledInvoices
     *
     * @param int $settledInvoices Number of settled invoices for this subscription
     *
     * @return $this
     */
    public function setSettledInvoices($settledInvoices)
    {
        $this->container['settledInvoices'] = $settledInvoices;

        return $this;
    }

    /**
     * Gets settledAmount
     *
     * @return int
     */
    public function getSettledAmount()
    {
        return $this->container['settledAmount'];
    }

    /**
     * Sets settledAmount
     *
     * @param int $settledAmount Summed settled amount
     *
     * @return $this
     */
    public function setSettledAmount($settledAmount)
    {
        $this->container['settledAmount'] = $settledAmount;

        return $this;
    }

    /**
     * Gets refundedAmount
     *
     * @return int
     */
    public function getRefundedAmount()
    {
        return $this->container['refundedAmount'];
    }

    /**
     * Sets refundedAmount
     *
     * @param int $refundedAmount Summed refunded amount
     *
     * @return $this
     */
    public function setRefundedAmount($refundedAmount)
    {
        $this->container['refundedAmount'] = $refundedAmount;

        return $this;
    }

    /**
     * Gets pendingAdditionalCosts
     *
     * @return int
     */
    public function getPendingAdditionalCosts()
    {
        return $this->container['pendingAdditionalCosts'];
    }

    /**
     * Sets pendingAdditionalCosts
     *
     * @param int $pendingAdditionalCosts Number of pending additional costs
     *
     * @return $this
     */
    public function setPendingAdditionalCosts($pendingAdditionalCosts)
    {
        $this->container['pendingAdditionalCosts'] = $pendingAdditionalCosts;

        return $this;
    }

    /**
     * Gets pendingAdditionalCostAmount
     *
     * @return int
     */
    public function getPendingAdditionalCostAmount()
    {
        return $this->container['pendingAdditionalCostAmount'];
    }

    /**
     * Sets pendingAdditionalCostAmount
     *
     * @param int $pendingAdditionalCostAmount Summed amount of pending additional costs incl vat
     *
     * @return $this
     */
    public function setPendingAdditionalCostAmount($pendingAdditionalCostAmount)
    {
        $this->container['pendingAdditionalCostAmount'] = $pendingAdditionalCostAmount;

        return $this;
    }

    /**
     * Gets transferredAdditionalCosts
     *
     * @return int
     */
    public function getTransferredAdditionalCosts()
    {
        return $this->container['transferredAdditionalCosts'];
    }

    /**
     * Sets transferredAdditionalCosts
     *
     * @param int $transferredAdditionalCosts Number of additional costs that have been applied to invoices
     *
     * @return $this
     */
    public function setTransferredAdditionalCosts($transferredAdditionalCosts)
    {
        $this->container['transferredAdditionalCosts'] = $transferredAdditionalCosts;

        return $this;
    }

    /**
     * Gets transferredAdditionalCostAmount
     *
     * @return int
     */
    public function getTransferredAdditionalCostAmount()
    {
        return $this->container['transferredAdditionalCostAmount'];
    }

    /**
     * Sets transferredAdditionalCostAmount
     *
     * @param int $transferredAdditionalCostAmount Summed amount of additional costs that have been applied to invoices
     *
     * @return $this
     */
    public function setTransferredAdditionalCostAmount($transferredAdditionalCostAmount)
    {
        $this->container['transferredAdditionalCostAmount'] = $transferredAdditionalCostAmount;

        return $this;
    }

    /**
     * Gets pendingCredits
     *
     * @return int
     */
    public function getPendingCredits()
    {
        return $this->container['pendingCredits'];
    }

    /**
     * Sets pendingCredits
     *
     * @param int $pendingCredits Number of credits that have not fully been applied to invoices
     *
     * @return $this
     */
    public function setPendingCredits($pendingCredits)
    {
        $this->container['pendingCredits'] = $pendingCredits;

        return $this;
    }

    /**
     * Gets pendingCreditAmount
     *
     * @return int
     */
    public function getPendingCreditAmount()
    {
        return $this->container['pendingCreditAmount'];
    }

    /**
     * Sets pendingCreditAmount
     *
     * @param int $pendingCreditAmount Summed credit amount not yet applied to invoices
     *
     * @return $this
     */
    public function setPendingCreditAmount($pendingCreditAmount)
    {
        $this->container['pendingCreditAmount'] = $pendingCreditAmount;

        return $this;
    }

    /**
     * Gets transferredCredits
     *
     * @return int
     */
    public function getTransferredCredits()
    {
        return $this->container['transferredCredits'];
    }

    /**
     * Sets transferredCredits
     *
     * @param int $transferredCredits Number of credits that have fully been applied to invoices
     *
     * @return $this
     */
    public function setTransferredCredits($transferredCredits)
    {
        $this->container['transferredCredits'] = $transferredCredits;

        return $this;
    }

    /**
     * Gets transferredCreditAmount
     *
     * @return int
     */
    public function getTransferredCreditAmount()
    {
        return $this->container['transferredCreditAmount'];
    }

    /**
     * Sets transferredCreditAmount
     *
     * @param int $transferredCreditAmount Summed credit amount that have been applied to invoices
     *
     * @return $this
     */
    public function setTransferredCreditAmount($transferredCreditAmount)
    {
        $this->container['transferredCreditAmount'] = $transferredCreditAmount;

        return $this;
    }

    /**
     * Gets hostedPageLinks
     *
     * @return \Reepay\Model\SubscriptionLinks
     */
    public function getHostedPageLinks()
    {
        return $this->container['hostedPageLinks'];
    }

    /**
     * Sets hostedPageLinks
     *
     * @param \Reepay\Model\SubscriptionLinks $hostedPageLinks Links to hosted pages relating to subscription
     *
     * @return $this
     */
    public function setHostedPageLinks($hostedPageLinks)
    {
        $this->container['hostedPageLinks'] = $hostedPageLinks;

        return $this;
    }

    /**
     * Gets subscriptionDiscounts
     *
     * @return string[]
     */
    public function getSubscriptionDiscounts()
    {
        return $this->container['subscriptionDiscounts'];
    }

    /**
     * Sets subscriptionDiscounts
     *
     * @param string[] $subscriptionDiscounts List of subscription discounts handles attached to subscription
     *
     * @return $this
     */
    public function setSubscriptionDiscounts($subscriptionDiscounts)
    {
        $this->container['subscriptionDiscounts'] = $subscriptionDiscounts;

        return $this;
    }

    /**
     * Gets pendingChange
     *
     * @return \Reepay\Model\SubscriptionChange
     */
    public function getPendingChange()
    {
        return $this->container['pendingChange'];
    }

    /**
     * Sets pendingChange
     *
     * @param \Reepay\Model\SubscriptionChange $pendingChange Pending subscription change to be applied at next renewal
     *
     * @return $this
     */
    public function setPendingChange($pendingChange)
    {
        $this->container['pendingChange'] = $pendingChange;

        return $this;
    }

    /**
     * Gets subscriptionChanges
     *
     * @return \Reepay\Model\SubscriptionChange[]
     */
    public function getSubscriptionChanges()
    {
        return $this->container['subscriptionChanges'];
    }

    /**
     * Sets subscriptionChanges
     *
     * @param \Reepay\Model\SubscriptionChange[] $subscriptionChanges List of subscription changes both at most one pending and previously applied
     *
     * @return $this
     */
    public function setSubscriptionChanges($subscriptionChanges)
    {
        $this->container['subscriptionChanges'] = $subscriptionChanges;

        return $this;
    }

    /**
     * Gets subscriptionAddOns
     *
     * @return string[]
     */
    public function getSubscriptionAddOns()
    {
        return $this->container['subscriptionAddOns'];
    }

    /**
     * Sets subscriptionAddOns
     *
     * @param string[] $subscriptionAddOns List of subscription add-on handles attached to subscription
     *
     * @return $this
     */
    public function setSubscriptionAddOns($subscriptionAddOns)
    {
        $this->container['subscriptionAddOns'] = $subscriptionAddOns;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


