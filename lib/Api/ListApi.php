<?php
/**
 * ListApi
 * PHP version 5
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * API
 *
 * REST API to manage Reepay resources
 *
 * OpenAPI spec version: 1
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.41
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Reepay\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Reepay\ApiException;
use Reepay\Configuration;
use Reepay\HeaderSelector;
use Reepay\ObjectSerializer;

/**
 * ListApi Class Doc Comment
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ListApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getAddOnList
     *
     * Get list of add-ons
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param  string $handle Add-on handle prefix (optional)
     * @param  string $state Add-on state. Accepted values &#x60;active&#x60; or &#x60;deleted&#x60; (optional, default to active)
     * @param  string $type Type of add-on. Accepted values: &#x60;on_off&#x60; or &#x60;quantity&#x60;. An on_off type cannot be given a quantity when attached to subscription. For quantity type it is possible.&#x60; (optional)
     * @param  string $name Name of add-on. Used as order line text. (optional)
     * @param  string $description Optional description of add-on (optional)
     * @param  string $amount Add-on amount interval. See documentation of intervals. (optional)
     * @param  string $amountInclVat Amount incl vat flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $allPlans Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\AddOnList
     */
    public function getAddOnList($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = 'active', $type = null, $name = null, $description = null, $amount = null, $amountInclVat = null, $allPlans = null)
    {
        list($response) = $this->getAddOnListWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $state, $type, $name, $description, $amount, $amountInclVat, $allPlans);
        return $response;
    }

    /**
     * Operation getAddOnListWithHttpInfo
     *
     * Get list of add-ons
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param  string $handle Add-on handle prefix (optional)
     * @param  string $state Add-on state. Accepted values &#x60;active&#x60; or &#x60;deleted&#x60; (optional, default to active)
     * @param  string $type Type of add-on. Accepted values: &#x60;on_off&#x60; or &#x60;quantity&#x60;. An on_off type cannot be given a quantity when attached to subscription. For quantity type it is possible.&#x60; (optional)
     * @param  string $name Name of add-on. Used as order line text. (optional)
     * @param  string $description Optional description of add-on (optional)
     * @param  string $amount Add-on amount interval. See documentation of intervals. (optional)
     * @param  string $amountInclVat Amount incl vat flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $allPlans Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\AddOnList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAddOnListWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = 'active', $type = null, $name = null, $description = null, $amount = null, $amountInclVat = null, $allPlans = null)
    {
        $returnType = '\Reepay\Model\AddOnList';
        $request = $this->getAddOnListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $state, $type, $name, $description, $amount, $amountInclVat, $allPlans);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\AddOnList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAddOnListAsync
     *
     * Get list of add-ons
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param  string $handle Add-on handle prefix (optional)
     * @param  string $state Add-on state. Accepted values &#x60;active&#x60; or &#x60;deleted&#x60; (optional, default to active)
     * @param  string $type Type of add-on. Accepted values: &#x60;on_off&#x60; or &#x60;quantity&#x60;. An on_off type cannot be given a quantity when attached to subscription. For quantity type it is possible.&#x60; (optional)
     * @param  string $name Name of add-on. Used as order line text. (optional)
     * @param  string $description Optional description of add-on (optional)
     * @param  string $amount Add-on amount interval. See documentation of intervals. (optional)
     * @param  string $amountInclVat Amount incl vat flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $allPlans Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAddOnListAsync($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = 'active', $type = null, $name = null, $description = null, $amount = null, $amountInclVat = null, $allPlans = null)
    {
        return $this->getAddOnListAsyncWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $state, $type, $name, $description, $amount, $amountInclVat, $allPlans)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAddOnListAsyncWithHttpInfo
     *
     * Get list of add-ons
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param  string $handle Add-on handle prefix (optional)
     * @param  string $state Add-on state. Accepted values &#x60;active&#x60; or &#x60;deleted&#x60; (optional, default to active)
     * @param  string $type Type of add-on. Accepted values: &#x60;on_off&#x60; or &#x60;quantity&#x60;. An on_off type cannot be given a quantity when attached to subscription. For quantity type it is possible.&#x60; (optional)
     * @param  string $name Name of add-on. Used as order line text. (optional)
     * @param  string $description Optional description of add-on (optional)
     * @param  string $amount Add-on amount interval. See documentation of intervals. (optional)
     * @param  string $amountInclVat Amount incl vat flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $allPlans Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAddOnListAsyncWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = 'active', $type = null, $name = null, $description = null, $amount = null, $amountInclVat = null, $allPlans = null)
    {
        $returnType = '\Reepay\Model\AddOnList';
        $request = $this->getAddOnListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $state, $type, $name, $description, $amount, $amountInclVat, $allPlans);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAddOnList'
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param  string $handle Add-on handle prefix (optional)
     * @param  string $state Add-on state. Accepted values &#x60;active&#x60; or &#x60;deleted&#x60; (optional, default to active)
     * @param  string $type Type of add-on. Accepted values: &#x60;on_off&#x60; or &#x60;quantity&#x60;. An on_off type cannot be given a quantity when attached to subscription. For quantity type it is possible.&#x60; (optional)
     * @param  string $name Name of add-on. Used as order line text. (optional)
     * @param  string $description Optional description of add-on (optional)
     * @param  string $amount Add-on amount interval. See documentation of intervals. (optional)
     * @param  string $amountInclVat Amount incl vat flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $allPlans Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAddOnListRequest($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = 'active', $type = null, $name = null, $description = null, $amount = null, $amountInclVat = null, $allPlans = null)
    {

        $resourcePath = '/v1/list/add_on';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($nextPageToken !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($nextPageToken, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if ($amountInclVat !== null) {
            $queryParams['amount_incl_vat'] = ObjectSerializer::toQueryValue($amountInclVat, null);
        }
        // query params
        if ($allPlans !== null) {
            $queryParams['all_plans'] = ObjectSerializer::toQueryValue($allPlans, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChargeList
     *
     * Get list of charges
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Invoice handle prefix (optional)
     * @param  string $handleContains Invoice handle contains (optional)
     * @param  string[] $state Invoice state, multiple can be defined (optional)
     * @param  string[] $excludeState Invoice state to exclude, multiple can be defined (optional)
     * @param  string $customer Invoices for customer by customer handle (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $authorizedAmount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  bool $partialSettled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\ChargeList
     */
    public function getChargeList($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $state = null, $excludeState = null, $customer = null, $amount = null, $refundedAmount = null, $authorizedAmount = null, $currency = null, $partialSettled = null)
    {
        list($response) = $this->getChargeListWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $state, $excludeState, $customer, $amount, $refundedAmount, $authorizedAmount, $currency, $partialSettled);
        return $response;
    }

    /**
     * Operation getChargeListWithHttpInfo
     *
     * Get list of charges
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Invoice handle prefix (optional)
     * @param  string $handleContains Invoice handle contains (optional)
     * @param  string[] $state Invoice state, multiple can be defined (optional)
     * @param  string[] $excludeState Invoice state to exclude, multiple can be defined (optional)
     * @param  string $customer Invoices for customer by customer handle (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $authorizedAmount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  bool $partialSettled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\ChargeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChargeListWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $state = null, $excludeState = null, $customer = null, $amount = null, $refundedAmount = null, $authorizedAmount = null, $currency = null, $partialSettled = null)
    {
        $returnType = '\Reepay\Model\ChargeList';
        $request = $this->getChargeListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $state, $excludeState, $customer, $amount, $refundedAmount, $authorizedAmount, $currency, $partialSettled);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ChargeList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getChargeListAsync
     *
     * Get list of charges
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Invoice handle prefix (optional)
     * @param  string $handleContains Invoice handle contains (optional)
     * @param  string[] $state Invoice state, multiple can be defined (optional)
     * @param  string[] $excludeState Invoice state to exclude, multiple can be defined (optional)
     * @param  string $customer Invoices for customer by customer handle (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $authorizedAmount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  bool $partialSettled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChargeListAsync($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $state = null, $excludeState = null, $customer = null, $amount = null, $refundedAmount = null, $authorizedAmount = null, $currency = null, $partialSettled = null)
    {
        return $this->getChargeListAsyncWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $state, $excludeState, $customer, $amount, $refundedAmount, $authorizedAmount, $currency, $partialSettled)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChargeListAsyncWithHttpInfo
     *
     * Get list of charges
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Invoice handle prefix (optional)
     * @param  string $handleContains Invoice handle contains (optional)
     * @param  string[] $state Invoice state, multiple can be defined (optional)
     * @param  string[] $excludeState Invoice state to exclude, multiple can be defined (optional)
     * @param  string $customer Invoices for customer by customer handle (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $authorizedAmount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  bool $partialSettled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChargeListAsyncWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $state = null, $excludeState = null, $customer = null, $amount = null, $refundedAmount = null, $authorizedAmount = null, $currency = null, $partialSettled = null)
    {
        $returnType = '\Reepay\Model\ChargeList';
        $request = $this->getChargeListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $state, $excludeState, $customer, $amount, $refundedAmount, $authorizedAmount, $currency, $partialSettled);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChargeList'
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Invoice handle prefix (optional)
     * @param  string $handleContains Invoice handle contains (optional)
     * @param  string[] $state Invoice state, multiple can be defined (optional)
     * @param  string[] $excludeState Invoice state to exclude, multiple can be defined (optional)
     * @param  string $customer Invoices for customer by customer handle (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $authorizedAmount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  bool $partialSettled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getChargeListRequest($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $state = null, $excludeState = null, $customer = null, $amount = null, $refundedAmount = null, $authorizedAmount = null, $currency = null, $partialSettled = null)
    {

        $resourcePath = '/v1/list/charge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($nextPageToken !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($nextPageToken, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($handleContains !== null) {
            $queryParams['handle_contains'] = ObjectSerializer::toQueryValue($handleContains, null);
        }
        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, 'multi', true);
        }
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if (is_array($excludeState)) {
            $excludeState = ObjectSerializer::serializeCollection($excludeState, 'multi', true);
        }
        if ($excludeState !== null) {
            $queryParams['exclude_state'] = ObjectSerializer::toQueryValue($excludeState, null);
        }
        // query params
        if ($customer !== null) {
            $queryParams['customer'] = ObjectSerializer::toQueryValue($customer, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if ($refundedAmount !== null) {
            $queryParams['refunded_amount'] = ObjectSerializer::toQueryValue($refundedAmount, null);
        }
        // query params
        if ($authorizedAmount !== null) {
            $queryParams['authorized_amount'] = ObjectSerializer::toQueryValue($authorizedAmount, null);
        }
        // query params
        if (is_array($currency)) {
            $currency = ObjectSerializer::serializeCollection($currency, 'multi', true);
        }
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency, null);
        }
        // query params
        if ($partialSettled !== null) {
            $queryParams['partial_settled'] = ObjectSerializer::toQueryValue($partialSettled, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCouponList
     *
     * Get list of coupons
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can be the &#x60;created&#x60; or &#x60;expired&#x60; (optional, default to created)
     * @param  string $handle Coupon handle prefix (optional)
     * @param  string $type Type of coupon. Accepted values: &#x60;single&#x60; or &#x60;set&#x60; (optional)
     * @param  string[] $expireReason The expire reason if expired, multiple can be defined. Possible values: &#x60;early&#x60;, &#x60;valid_until&#x60; or &#x60;max&#x60; (optional)
     * @param  string $discountHandle Handle of discount to use for coupon (optional)
     * @param  string $code The coupon code. Maximum 128 characters. (optional)
     * @param  string $name Internal name for the coupon. (optional)
     * @param  string $allPlans Whether all plans are eligible for this coupon. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $maxRedemptions Optional maximum number of times this coupon can be redeemed. (optional)
     * @param  string $redemptions Number of times the coupon has been redeemed. (optional)
     * @param  string $validUntil Valid-until period date interval (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\CouponList
     */
    public function getCouponList($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $type = null, $expireReason = null, $discountHandle = null, $code = null, $name = null, $allPlans = null, $maxRedemptions = null, $redemptions = null, $validUntil = null)
    {
        list($response) = $this->getCouponListWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $type, $expireReason, $discountHandle, $code, $name, $allPlans, $maxRedemptions, $redemptions, $validUntil);
        return $response;
    }

    /**
     * Operation getCouponListWithHttpInfo
     *
     * Get list of coupons
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can be the &#x60;created&#x60; or &#x60;expired&#x60; (optional, default to created)
     * @param  string $handle Coupon handle prefix (optional)
     * @param  string $type Type of coupon. Accepted values: &#x60;single&#x60; or &#x60;set&#x60; (optional)
     * @param  string[] $expireReason The expire reason if expired, multiple can be defined. Possible values: &#x60;early&#x60;, &#x60;valid_until&#x60; or &#x60;max&#x60; (optional)
     * @param  string $discountHandle Handle of discount to use for coupon (optional)
     * @param  string $code The coupon code. Maximum 128 characters. (optional)
     * @param  string $name Internal name for the coupon. (optional)
     * @param  string $allPlans Whether all plans are eligible for this coupon. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $maxRedemptions Optional maximum number of times this coupon can be redeemed. (optional)
     * @param  string $redemptions Number of times the coupon has been redeemed. (optional)
     * @param  string $validUntil Valid-until period date interval (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\CouponList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCouponListWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $type = null, $expireReason = null, $discountHandle = null, $code = null, $name = null, $allPlans = null, $maxRedemptions = null, $redemptions = null, $validUntil = null)
    {
        $returnType = '\Reepay\Model\CouponList';
        $request = $this->getCouponListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $type, $expireReason, $discountHandle, $code, $name, $allPlans, $maxRedemptions, $redemptions, $validUntil);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\CouponList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCouponListAsync
     *
     * Get list of coupons
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can be the &#x60;created&#x60; or &#x60;expired&#x60; (optional, default to created)
     * @param  string $handle Coupon handle prefix (optional)
     * @param  string $type Type of coupon. Accepted values: &#x60;single&#x60; or &#x60;set&#x60; (optional)
     * @param  string[] $expireReason The expire reason if expired, multiple can be defined. Possible values: &#x60;early&#x60;, &#x60;valid_until&#x60; or &#x60;max&#x60; (optional)
     * @param  string $discountHandle Handle of discount to use for coupon (optional)
     * @param  string $code The coupon code. Maximum 128 characters. (optional)
     * @param  string $name Internal name for the coupon. (optional)
     * @param  string $allPlans Whether all plans are eligible for this coupon. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $maxRedemptions Optional maximum number of times this coupon can be redeemed. (optional)
     * @param  string $redemptions Number of times the coupon has been redeemed. (optional)
     * @param  string $validUntil Valid-until period date interval (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponListAsync($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $type = null, $expireReason = null, $discountHandle = null, $code = null, $name = null, $allPlans = null, $maxRedemptions = null, $redemptions = null, $validUntil = null)
    {
        return $this->getCouponListAsyncWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $type, $expireReason, $discountHandle, $code, $name, $allPlans, $maxRedemptions, $redemptions, $validUntil)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCouponListAsyncWithHttpInfo
     *
     * Get list of coupons
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can be the &#x60;created&#x60; or &#x60;expired&#x60; (optional, default to created)
     * @param  string $handle Coupon handle prefix (optional)
     * @param  string $type Type of coupon. Accepted values: &#x60;single&#x60; or &#x60;set&#x60; (optional)
     * @param  string[] $expireReason The expire reason if expired, multiple can be defined. Possible values: &#x60;early&#x60;, &#x60;valid_until&#x60; or &#x60;max&#x60; (optional)
     * @param  string $discountHandle Handle of discount to use for coupon (optional)
     * @param  string $code The coupon code. Maximum 128 characters. (optional)
     * @param  string $name Internal name for the coupon. (optional)
     * @param  string $allPlans Whether all plans are eligible for this coupon. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $maxRedemptions Optional maximum number of times this coupon can be redeemed. (optional)
     * @param  string $redemptions Number of times the coupon has been redeemed. (optional)
     * @param  string $validUntil Valid-until period date interval (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponListAsyncWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $type = null, $expireReason = null, $discountHandle = null, $code = null, $name = null, $allPlans = null, $maxRedemptions = null, $redemptions = null, $validUntil = null)
    {
        $returnType = '\Reepay\Model\CouponList';
        $request = $this->getCouponListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $type, $expireReason, $discountHandle, $code, $name, $allPlans, $maxRedemptions, $redemptions, $validUntil);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCouponList'
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can be the &#x60;created&#x60; or &#x60;expired&#x60; (optional, default to created)
     * @param  string $handle Coupon handle prefix (optional)
     * @param  string $type Type of coupon. Accepted values: &#x60;single&#x60; or &#x60;set&#x60; (optional)
     * @param  string[] $expireReason The expire reason if expired, multiple can be defined. Possible values: &#x60;early&#x60;, &#x60;valid_until&#x60; or &#x60;max&#x60; (optional)
     * @param  string $discountHandle Handle of discount to use for coupon (optional)
     * @param  string $code The coupon code. Maximum 128 characters. (optional)
     * @param  string $name Internal name for the coupon. (optional)
     * @param  string $allPlans Whether all plans are eligible for this coupon. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $maxRedemptions Optional maximum number of times this coupon can be redeemed. (optional)
     * @param  string $redemptions Number of times the coupon has been redeemed. (optional)
     * @param  string $validUntil Valid-until period date interval (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCouponListRequest($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $type = null, $expireReason = null, $discountHandle = null, $code = null, $name = null, $allPlans = null, $maxRedemptions = null, $redemptions = null, $validUntil = null)
    {

        $resourcePath = '/v1/list/coupon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($nextPageToken !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($nextPageToken, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if (is_array($expireReason)) {
            $expireReason = ObjectSerializer::serializeCollection($expireReason, 'multi', true);
        }
        if ($expireReason !== null) {
            $queryParams['expire_reason'] = ObjectSerializer::toQueryValue($expireReason, null);
        }
        // query params
        if ($discountHandle !== null) {
            $queryParams['discount_handle'] = ObjectSerializer::toQueryValue($discountHandle, null);
        }
        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($allPlans !== null) {
            $queryParams['all_plans'] = ObjectSerializer::toQueryValue($allPlans, null);
        }
        // query params
        if ($maxRedemptions !== null) {
            $queryParams['max_redemptions'] = ObjectSerializer::toQueryValue($maxRedemptions, null);
        }
        // query params
        if ($redemptions !== null) {
            $queryParams['redemptions'] = ObjectSerializer::toQueryValue($redemptions, null);
        }
        // query params
        if ($validUntil !== null) {
            $queryParams['valid_until'] = ObjectSerializer::toQueryValue($validUntil, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomerList
     *
     * Get list of customers
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param  string $handle Customer handle prefix (optional)
     * @param  string $handleContains Customer handle contains (optional)
     * @param  string $name Search for name contained in first name concatenated with last name (optional)
     * @param  string $email Customer email (optional)
     * @param  string $emailPrefix Customer email prefix (optional)
     * @param  string $firstName Contained in customer first name (optional)
     * @param  string $lastName Contained in customer last name (optional)
     * @param  string $address Contained in customer address (optional)
     * @param  string $address2 Contained in customer address2 (optional)
     * @param  string $postalCode Contained in customer postal code (optional)
     * @param  string $city Contained in customer city (optional)
     * @param  string $country Customer country in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (optional)
     * @param  string $phone Contained in customer phone (optional)
     * @param  string $company Contained in customer company (optional)
     * @param  string $vat Contained in customer vat code (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\CustomerList
     */
    public function getCustomerList($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $name = null, $email = null, $emailPrefix = null, $firstName = null, $lastName = null, $address = null, $address2 = null, $postalCode = null, $city = null, $country = null, $phone = null, $company = null, $vat = null)
    {
        list($response) = $this->getCustomerListWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $name, $email, $emailPrefix, $firstName, $lastName, $address, $address2, $postalCode, $city, $country, $phone, $company, $vat);
        return $response;
    }

    /**
     * Operation getCustomerListWithHttpInfo
     *
     * Get list of customers
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param  string $handle Customer handle prefix (optional)
     * @param  string $handleContains Customer handle contains (optional)
     * @param  string $name Search for name contained in first name concatenated with last name (optional)
     * @param  string $email Customer email (optional)
     * @param  string $emailPrefix Customer email prefix (optional)
     * @param  string $firstName Contained in customer first name (optional)
     * @param  string $lastName Contained in customer last name (optional)
     * @param  string $address Contained in customer address (optional)
     * @param  string $address2 Contained in customer address2 (optional)
     * @param  string $postalCode Contained in customer postal code (optional)
     * @param  string $city Contained in customer city (optional)
     * @param  string $country Customer country in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (optional)
     * @param  string $phone Contained in customer phone (optional)
     * @param  string $company Contained in customer company (optional)
     * @param  string $vat Contained in customer vat code (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\CustomerList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomerListWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $name = null, $email = null, $emailPrefix = null, $firstName = null, $lastName = null, $address = null, $address2 = null, $postalCode = null, $city = null, $country = null, $phone = null, $company = null, $vat = null)
    {
        $returnType = '\Reepay\Model\CustomerList';
        $request = $this->getCustomerListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $name, $email, $emailPrefix, $firstName, $lastName, $address, $address2, $postalCode, $city, $country, $phone, $company, $vat);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\CustomerList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCustomerListAsync
     *
     * Get list of customers
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param  string $handle Customer handle prefix (optional)
     * @param  string $handleContains Customer handle contains (optional)
     * @param  string $name Search for name contained in first name concatenated with last name (optional)
     * @param  string $email Customer email (optional)
     * @param  string $emailPrefix Customer email prefix (optional)
     * @param  string $firstName Contained in customer first name (optional)
     * @param  string $lastName Contained in customer last name (optional)
     * @param  string $address Contained in customer address (optional)
     * @param  string $address2 Contained in customer address2 (optional)
     * @param  string $postalCode Contained in customer postal code (optional)
     * @param  string $city Contained in customer city (optional)
     * @param  string $country Customer country in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (optional)
     * @param  string $phone Contained in customer phone (optional)
     * @param  string $company Contained in customer company (optional)
     * @param  string $vat Contained in customer vat code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerListAsync($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $name = null, $email = null, $emailPrefix = null, $firstName = null, $lastName = null, $address = null, $address2 = null, $postalCode = null, $city = null, $country = null, $phone = null, $company = null, $vat = null)
    {
        return $this->getCustomerListAsyncWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $name, $email, $emailPrefix, $firstName, $lastName, $address, $address2, $postalCode, $city, $country, $phone, $company, $vat)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomerListAsyncWithHttpInfo
     *
     * Get list of customers
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param  string $handle Customer handle prefix (optional)
     * @param  string $handleContains Customer handle contains (optional)
     * @param  string $name Search for name contained in first name concatenated with last name (optional)
     * @param  string $email Customer email (optional)
     * @param  string $emailPrefix Customer email prefix (optional)
     * @param  string $firstName Contained in customer first name (optional)
     * @param  string $lastName Contained in customer last name (optional)
     * @param  string $address Contained in customer address (optional)
     * @param  string $address2 Contained in customer address2 (optional)
     * @param  string $postalCode Contained in customer postal code (optional)
     * @param  string $city Contained in customer city (optional)
     * @param  string $country Customer country in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (optional)
     * @param  string $phone Contained in customer phone (optional)
     * @param  string $company Contained in customer company (optional)
     * @param  string $vat Contained in customer vat code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerListAsyncWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $name = null, $email = null, $emailPrefix = null, $firstName = null, $lastName = null, $address = null, $address2 = null, $postalCode = null, $city = null, $country = null, $phone = null, $company = null, $vat = null)
    {
        $returnType = '\Reepay\Model\CustomerList';
        $request = $this->getCustomerListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $name, $email, $emailPrefix, $firstName, $lastName, $address, $address2, $postalCode, $city, $country, $phone, $company, $vat);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomerList'
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param  string $handle Customer handle prefix (optional)
     * @param  string $handleContains Customer handle contains (optional)
     * @param  string $name Search for name contained in first name concatenated with last name (optional)
     * @param  string $email Customer email (optional)
     * @param  string $emailPrefix Customer email prefix (optional)
     * @param  string $firstName Contained in customer first name (optional)
     * @param  string $lastName Contained in customer last name (optional)
     * @param  string $address Contained in customer address (optional)
     * @param  string $address2 Contained in customer address2 (optional)
     * @param  string $postalCode Contained in customer postal code (optional)
     * @param  string $city Contained in customer city (optional)
     * @param  string $country Customer country in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (optional)
     * @param  string $phone Contained in customer phone (optional)
     * @param  string $company Contained in customer company (optional)
     * @param  string $vat Contained in customer vat code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCustomerListRequest($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $name = null, $email = null, $emailPrefix = null, $firstName = null, $lastName = null, $address = null, $address2 = null, $postalCode = null, $city = null, $country = null, $phone = null, $company = null, $vat = null)
    {

        $resourcePath = '/v1/list/customer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($nextPageToken !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($nextPageToken, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($handleContains !== null) {
            $queryParams['handle_contains'] = ObjectSerializer::toQueryValue($handleContains, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email, null);
        }
        // query params
        if ($emailPrefix !== null) {
            $queryParams['email_prefix'] = ObjectSerializer::toQueryValue($emailPrefix, null);
        }
        // query params
        if ($firstName !== null) {
            $queryParams['first_name'] = ObjectSerializer::toQueryValue($firstName, null);
        }
        // query params
        if ($lastName !== null) {
            $queryParams['last_name'] = ObjectSerializer::toQueryValue($lastName, null);
        }
        // query params
        if ($address !== null) {
            $queryParams['address'] = ObjectSerializer::toQueryValue($address, null);
        }
        // query params
        if ($address2 !== null) {
            $queryParams['address2'] = ObjectSerializer::toQueryValue($address2, null);
        }
        // query params
        if ($postalCode !== null) {
            $queryParams['postal_code'] = ObjectSerializer::toQueryValue($postalCode, null);
        }
        // query params
        if ($city !== null) {
            $queryParams['city'] = ObjectSerializer::toQueryValue($city, null);
        }
        // query params
        if ($country !== null) {
            $queryParams['country'] = ObjectSerializer::toQueryValue($country, null);
        }
        // query params
        if ($phone !== null) {
            $queryParams['phone'] = ObjectSerializer::toQueryValue($phone, null);
        }
        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company, null);
        }
        // query params
        if ($vat !== null) {
            $queryParams['vat'] = ObjectSerializer::toQueryValue($vat, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDiscountList
     *
     * Get list of discounts
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute for time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param  string $handle Discount handle prefix (optional)
     * @param  string $state State of discount. States: &#x60;active&#x60; or &#x60;deleted&#x60; (optional)
     * @param  string[] $applyTo Which order lines the discount is applicable to: &#x60;all&#x60;, &#x60;setup_fee&#x60;, &#x60;plan&#x60;, &#x60;additional_cost&#x60;, &#x60;add_on&#x60; and &#x60;ondemand&#x60;. Multiple can be defined. (optional)
     * @param  string $name Name of discount. Used as order line text. (optional)
     * @param  string $description Optional description of discount (optional)
     * @param  string $amount Fixed amount discount deducted from order line amounts including VAT. (optional)
     * @param  string $percentage Percentage discount applied to each applicable order line. (optional)
     * @param  string $fixedCount Apply discount to a fixed number of invoices (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\DiscountList
     */
    public function getDiscountList($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = null, $applyTo = null, $name = null, $description = null, $amount = null, $percentage = null, $fixedCount = null)
    {
        list($response) = $this->getDiscountListWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $state, $applyTo, $name, $description, $amount, $percentage, $fixedCount);
        return $response;
    }

    /**
     * Operation getDiscountListWithHttpInfo
     *
     * Get list of discounts
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute for time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param  string $handle Discount handle prefix (optional)
     * @param  string $state State of discount. States: &#x60;active&#x60; or &#x60;deleted&#x60; (optional)
     * @param  string[] $applyTo Which order lines the discount is applicable to: &#x60;all&#x60;, &#x60;setup_fee&#x60;, &#x60;plan&#x60;, &#x60;additional_cost&#x60;, &#x60;add_on&#x60; and &#x60;ondemand&#x60;. Multiple can be defined. (optional)
     * @param  string $name Name of discount. Used as order line text. (optional)
     * @param  string $description Optional description of discount (optional)
     * @param  string $amount Fixed amount discount deducted from order line amounts including VAT. (optional)
     * @param  string $percentage Percentage discount applied to each applicable order line. (optional)
     * @param  string $fixedCount Apply discount to a fixed number of invoices (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\DiscountList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDiscountListWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = null, $applyTo = null, $name = null, $description = null, $amount = null, $percentage = null, $fixedCount = null)
    {
        $returnType = '\Reepay\Model\DiscountList';
        $request = $this->getDiscountListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $state, $applyTo, $name, $description, $amount, $percentage, $fixedCount);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\DiscountList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDiscountListAsync
     *
     * Get list of discounts
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute for time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param  string $handle Discount handle prefix (optional)
     * @param  string $state State of discount. States: &#x60;active&#x60; or &#x60;deleted&#x60; (optional)
     * @param  string[] $applyTo Which order lines the discount is applicable to: &#x60;all&#x60;, &#x60;setup_fee&#x60;, &#x60;plan&#x60;, &#x60;additional_cost&#x60;, &#x60;add_on&#x60; and &#x60;ondemand&#x60;. Multiple can be defined. (optional)
     * @param  string $name Name of discount. Used as order line text. (optional)
     * @param  string $description Optional description of discount (optional)
     * @param  string $amount Fixed amount discount deducted from order line amounts including VAT. (optional)
     * @param  string $percentage Percentage discount applied to each applicable order line. (optional)
     * @param  string $fixedCount Apply discount to a fixed number of invoices (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDiscountListAsync($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = null, $applyTo = null, $name = null, $description = null, $amount = null, $percentage = null, $fixedCount = null)
    {
        return $this->getDiscountListAsyncWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $state, $applyTo, $name, $description, $amount, $percentage, $fixedCount)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDiscountListAsyncWithHttpInfo
     *
     * Get list of discounts
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute for time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param  string $handle Discount handle prefix (optional)
     * @param  string $state State of discount. States: &#x60;active&#x60; or &#x60;deleted&#x60; (optional)
     * @param  string[] $applyTo Which order lines the discount is applicable to: &#x60;all&#x60;, &#x60;setup_fee&#x60;, &#x60;plan&#x60;, &#x60;additional_cost&#x60;, &#x60;add_on&#x60; and &#x60;ondemand&#x60;. Multiple can be defined. (optional)
     * @param  string $name Name of discount. Used as order line text. (optional)
     * @param  string $description Optional description of discount (optional)
     * @param  string $amount Fixed amount discount deducted from order line amounts including VAT. (optional)
     * @param  string $percentage Percentage discount applied to each applicable order line. (optional)
     * @param  string $fixedCount Apply discount to a fixed number of invoices (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDiscountListAsyncWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = null, $applyTo = null, $name = null, $description = null, $amount = null, $percentage = null, $fixedCount = null)
    {
        $returnType = '\Reepay\Model\DiscountList';
        $request = $this->getDiscountListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $state, $applyTo, $name, $description, $amount, $percentage, $fixedCount);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDiscountList'
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute for time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param  string $handle Discount handle prefix (optional)
     * @param  string $state State of discount. States: &#x60;active&#x60; or &#x60;deleted&#x60; (optional)
     * @param  string[] $applyTo Which order lines the discount is applicable to: &#x60;all&#x60;, &#x60;setup_fee&#x60;, &#x60;plan&#x60;, &#x60;additional_cost&#x60;, &#x60;add_on&#x60; and &#x60;ondemand&#x60;. Multiple can be defined. (optional)
     * @param  string $name Name of discount. Used as order line text. (optional)
     * @param  string $description Optional description of discount (optional)
     * @param  string $amount Fixed amount discount deducted from order line amounts including VAT. (optional)
     * @param  string $percentage Percentage discount applied to each applicable order line. (optional)
     * @param  string $fixedCount Apply discount to a fixed number of invoices (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDiscountListRequest($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = null, $applyTo = null, $name = null, $description = null, $amount = null, $percentage = null, $fixedCount = null)
    {

        $resourcePath = '/v1/list/discount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($nextPageToken !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($nextPageToken, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if (is_array($applyTo)) {
            $applyTo = ObjectSerializer::serializeCollection($applyTo, 'multi', true);
        }
        if ($applyTo !== null) {
            $queryParams['apply_to'] = ObjectSerializer::toQueryValue($applyTo, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if ($percentage !== null) {
            $queryParams['percentage'] = ObjectSerializer::toQueryValue($percentage, null);
        }
        // query params
        if ($fixedCount !== null) {
            $queryParams['fixed_count'] = ObjectSerializer::toQueryValue($fixedCount, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceList
     *
     * Get list of invoices
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Invoice handle prefix (optional)
     * @param  string $handleContains Invoice handle contains (optional)
     * @param  string[] $state Invoice state, multiple can be defined (optional)
     * @param  string[] $excludeState Invoice state to exclude, multiple can be defined (optional)
     * @param  string $customer Invoices for customer by customer handle (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $authorizedAmount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  bool $partialSettled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     * @param  string[] $type Invoice type, multiple can be defined. &#x60;s&#x60; - subscription recurring, &#x60;so&#x60; - subscription one-time, &#x60;soi&#x60; - subscription one-time instant, &#x60;co&#x60; - customer one-time, &#x60;ch&#x60; - charge (optional)
     * @param  string $subscription Invoices for subscription by subscription handle (optional)
     * @param  string $plan Invoices for subscription plan by subscription plan handle (optional)
     * @param  string $dunningStart Dunning start date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param  string $dunningSuccess Dunning success date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param  int $number Invoice number if subscription invoice (optional)
     * @param  string $due Due date if due date defined for subscription invoice (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\InvoiceList
     */
    public function getInvoiceList($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $state = null, $excludeState = null, $customer = null, $amount = null, $refundedAmount = null, $authorizedAmount = null, $currency = null, $partialSettled = null, $type = null, $subscription = null, $plan = null, $dunningStart = null, $dunningSuccess = null, $number = null, $due = null)
    {
        list($response) = $this->getInvoiceListWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $state, $excludeState, $customer, $amount, $refundedAmount, $authorizedAmount, $currency, $partialSettled, $type, $subscription, $plan, $dunningStart, $dunningSuccess, $number, $due);
        return $response;
    }

    /**
     * Operation getInvoiceListWithHttpInfo
     *
     * Get list of invoices
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Invoice handle prefix (optional)
     * @param  string $handleContains Invoice handle contains (optional)
     * @param  string[] $state Invoice state, multiple can be defined (optional)
     * @param  string[] $excludeState Invoice state to exclude, multiple can be defined (optional)
     * @param  string $customer Invoices for customer by customer handle (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $authorizedAmount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  bool $partialSettled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     * @param  string[] $type Invoice type, multiple can be defined. &#x60;s&#x60; - subscription recurring, &#x60;so&#x60; - subscription one-time, &#x60;soi&#x60; - subscription one-time instant, &#x60;co&#x60; - customer one-time, &#x60;ch&#x60; - charge (optional)
     * @param  string $subscription Invoices for subscription by subscription handle (optional)
     * @param  string $plan Invoices for subscription plan by subscription plan handle (optional)
     * @param  string $dunningStart Dunning start date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param  string $dunningSuccess Dunning success date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param  int $number Invoice number if subscription invoice (optional)
     * @param  string $due Due date if due date defined for subscription invoice (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\InvoiceList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceListWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $state = null, $excludeState = null, $customer = null, $amount = null, $refundedAmount = null, $authorizedAmount = null, $currency = null, $partialSettled = null, $type = null, $subscription = null, $plan = null, $dunningStart = null, $dunningSuccess = null, $number = null, $due = null)
    {
        $returnType = '\Reepay\Model\InvoiceList';
        $request = $this->getInvoiceListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $state, $excludeState, $customer, $amount, $refundedAmount, $authorizedAmount, $currency, $partialSettled, $type, $subscription, $plan, $dunningStart, $dunningSuccess, $number, $due);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\InvoiceList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceListAsync
     *
     * Get list of invoices
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Invoice handle prefix (optional)
     * @param  string $handleContains Invoice handle contains (optional)
     * @param  string[] $state Invoice state, multiple can be defined (optional)
     * @param  string[] $excludeState Invoice state to exclude, multiple can be defined (optional)
     * @param  string $customer Invoices for customer by customer handle (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $authorizedAmount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  bool $partialSettled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     * @param  string[] $type Invoice type, multiple can be defined. &#x60;s&#x60; - subscription recurring, &#x60;so&#x60; - subscription one-time, &#x60;soi&#x60; - subscription one-time instant, &#x60;co&#x60; - customer one-time, &#x60;ch&#x60; - charge (optional)
     * @param  string $subscription Invoices for subscription by subscription handle (optional)
     * @param  string $plan Invoices for subscription plan by subscription plan handle (optional)
     * @param  string $dunningStart Dunning start date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param  string $dunningSuccess Dunning success date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param  int $number Invoice number if subscription invoice (optional)
     * @param  string $due Due date if due date defined for subscription invoice (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceListAsync($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $state = null, $excludeState = null, $customer = null, $amount = null, $refundedAmount = null, $authorizedAmount = null, $currency = null, $partialSettled = null, $type = null, $subscription = null, $plan = null, $dunningStart = null, $dunningSuccess = null, $number = null, $due = null)
    {
        return $this->getInvoiceListAsyncWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $state, $excludeState, $customer, $amount, $refundedAmount, $authorizedAmount, $currency, $partialSettled, $type, $subscription, $plan, $dunningStart, $dunningSuccess, $number, $due)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceListAsyncWithHttpInfo
     *
     * Get list of invoices
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Invoice handle prefix (optional)
     * @param  string $handleContains Invoice handle contains (optional)
     * @param  string[] $state Invoice state, multiple can be defined (optional)
     * @param  string[] $excludeState Invoice state to exclude, multiple can be defined (optional)
     * @param  string $customer Invoices for customer by customer handle (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $authorizedAmount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  bool $partialSettled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     * @param  string[] $type Invoice type, multiple can be defined. &#x60;s&#x60; - subscription recurring, &#x60;so&#x60; - subscription one-time, &#x60;soi&#x60; - subscription one-time instant, &#x60;co&#x60; - customer one-time, &#x60;ch&#x60; - charge (optional)
     * @param  string $subscription Invoices for subscription by subscription handle (optional)
     * @param  string $plan Invoices for subscription plan by subscription plan handle (optional)
     * @param  string $dunningStart Dunning start date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param  string $dunningSuccess Dunning success date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param  int $number Invoice number if subscription invoice (optional)
     * @param  string $due Due date if due date defined for subscription invoice (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceListAsyncWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $state = null, $excludeState = null, $customer = null, $amount = null, $refundedAmount = null, $authorizedAmount = null, $currency = null, $partialSettled = null, $type = null, $subscription = null, $plan = null, $dunningStart = null, $dunningSuccess = null, $number = null, $due = null)
    {
        $returnType = '\Reepay\Model\InvoiceList';
        $request = $this->getInvoiceListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $state, $excludeState, $customer, $amount, $refundedAmount, $authorizedAmount, $currency, $partialSettled, $type, $subscription, $plan, $dunningStart, $dunningSuccess, $number, $due);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceList'
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Invoice handle prefix (optional)
     * @param  string $handleContains Invoice handle contains (optional)
     * @param  string[] $state Invoice state, multiple can be defined (optional)
     * @param  string[] $excludeState Invoice state to exclude, multiple can be defined (optional)
     * @param  string $customer Invoices for customer by customer handle (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string $authorizedAmount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  bool $partialSettled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     * @param  string[] $type Invoice type, multiple can be defined. &#x60;s&#x60; - subscription recurring, &#x60;so&#x60; - subscription one-time, &#x60;soi&#x60; - subscription one-time instant, &#x60;co&#x60; - customer one-time, &#x60;ch&#x60; - charge (optional)
     * @param  string $subscription Invoices for subscription by subscription handle (optional)
     * @param  string $plan Invoices for subscription plan by subscription plan handle (optional)
     * @param  string $dunningStart Dunning start date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param  string $dunningSuccess Dunning success date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param  int $number Invoice number if subscription invoice (optional)
     * @param  string $due Due date if due date defined for subscription invoice (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceListRequest($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $state = null, $excludeState = null, $customer = null, $amount = null, $refundedAmount = null, $authorizedAmount = null, $currency = null, $partialSettled = null, $type = null, $subscription = null, $plan = null, $dunningStart = null, $dunningSuccess = null, $number = null, $due = null)
    {

        $resourcePath = '/v1/list/invoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($nextPageToken !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($nextPageToken, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($handleContains !== null) {
            $queryParams['handle_contains'] = ObjectSerializer::toQueryValue($handleContains, null);
        }
        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, 'multi', true);
        }
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if (is_array($excludeState)) {
            $excludeState = ObjectSerializer::serializeCollection($excludeState, 'multi', true);
        }
        if ($excludeState !== null) {
            $queryParams['exclude_state'] = ObjectSerializer::toQueryValue($excludeState, null);
        }
        // query params
        if ($customer !== null) {
            $queryParams['customer'] = ObjectSerializer::toQueryValue($customer, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if ($refundedAmount !== null) {
            $queryParams['refunded_amount'] = ObjectSerializer::toQueryValue($refundedAmount, null);
        }
        // query params
        if ($authorizedAmount !== null) {
            $queryParams['authorized_amount'] = ObjectSerializer::toQueryValue($authorizedAmount, null);
        }
        // query params
        if (is_array($currency)) {
            $currency = ObjectSerializer::serializeCollection($currency, 'multi', true);
        }
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency, null);
        }
        // query params
        if ($partialSettled !== null) {
            $queryParams['partial_settled'] = ObjectSerializer::toQueryValue($partialSettled, null);
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, 'multi', true);
        }
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($subscription !== null) {
            $queryParams['subscription'] = ObjectSerializer::toQueryValue($subscription, null);
        }
        // query params
        if ($plan !== null) {
            $queryParams['plan'] = ObjectSerializer::toQueryValue($plan, null);
        }
        // query params
        if ($dunningStart !== null) {
            $queryParams['dunning_start'] = ObjectSerializer::toQueryValue($dunningStart, null);
        }
        // query params
        if ($dunningSuccess !== null) {
            $queryParams['dunning_success'] = ObjectSerializer::toQueryValue($dunningSuccess, null);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number, 'int32');
        }
        // query params
        if ($due !== null) {
            $queryParams['due'] = ObjectSerializer::toQueryValue($due, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentMethodList
     *
     * Get list of payment methods
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param  string $id Payment method id (optional)
     * @param  string[] $state Payment state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;active&#x60;, &#x60;inactivated&#x60;, &#x60;failed&#x60; and &#x60;deleted&#x60; (optional)
     * @param  string[] $paymentType Payment method payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param  string $customer Customer owning payment method (optional)
     * @param  string $subscription Payment methods for subscription (optional)
     * @param  string $reference Payment method reference (optional)
     * @param  string $failed Failed date interval (optional)
     * @param  string[] $cardType Card payment methods with card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string[] $transactionCardType Card payment methods with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string $cardPrefix Card payment methods with card with prefix (optional)
     * @param  string $cardPostfix Card payment methods with card number postfix (optional)
     * @param  string $cardFingerprint Card payment methods with card number postfix (optional)
     * @param  string[] $cardCountry Card payment methods with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param  string $cardGateway Card payment methods tied to card gateway (optional)
     * @param  string $cardAgreement Card payment methods tied to card agreement with id (optional)
     * @param  string $mpsExternalId MobilePay Subscription external id (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\PaymentMethodList
     */
    public function getPaymentMethodList($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $id = null, $state = null, $paymentType = null, $customer = null, $subscription = null, $reference = null, $failed = null, $cardType = null, $transactionCardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null, $cardCountry = null, $cardGateway = null, $cardAgreement = null, $mpsExternalId = null)
    {
        list($response) = $this->getPaymentMethodListWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $id, $state, $paymentType, $customer, $subscription, $reference, $failed, $cardType, $transactionCardType, $cardPrefix, $cardPostfix, $cardFingerprint, $cardCountry, $cardGateway, $cardAgreement, $mpsExternalId);
        return $response;
    }

    /**
     * Operation getPaymentMethodListWithHttpInfo
     *
     * Get list of payment methods
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param  string $id Payment method id (optional)
     * @param  string[] $state Payment state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;active&#x60;, &#x60;inactivated&#x60;, &#x60;failed&#x60; and &#x60;deleted&#x60; (optional)
     * @param  string[] $paymentType Payment method payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param  string $customer Customer owning payment method (optional)
     * @param  string $subscription Payment methods for subscription (optional)
     * @param  string $reference Payment method reference (optional)
     * @param  string $failed Failed date interval (optional)
     * @param  string[] $cardType Card payment methods with card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string[] $transactionCardType Card payment methods with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string $cardPrefix Card payment methods with card with prefix (optional)
     * @param  string $cardPostfix Card payment methods with card number postfix (optional)
     * @param  string $cardFingerprint Card payment methods with card number postfix (optional)
     * @param  string[] $cardCountry Card payment methods with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param  string $cardGateway Card payment methods tied to card gateway (optional)
     * @param  string $cardAgreement Card payment methods tied to card agreement with id (optional)
     * @param  string $mpsExternalId MobilePay Subscription external id (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\PaymentMethodList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentMethodListWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $id = null, $state = null, $paymentType = null, $customer = null, $subscription = null, $reference = null, $failed = null, $cardType = null, $transactionCardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null, $cardCountry = null, $cardGateway = null, $cardAgreement = null, $mpsExternalId = null)
    {
        $returnType = '\Reepay\Model\PaymentMethodList';
        $request = $this->getPaymentMethodListRequest($from, $to, $interval, $size, $nextPageToken, $range, $id, $state, $paymentType, $customer, $subscription, $reference, $failed, $cardType, $transactionCardType, $cardPrefix, $cardPostfix, $cardFingerprint, $cardCountry, $cardGateway, $cardAgreement, $mpsExternalId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\PaymentMethodList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentMethodListAsync
     *
     * Get list of payment methods
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param  string $id Payment method id (optional)
     * @param  string[] $state Payment state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;active&#x60;, &#x60;inactivated&#x60;, &#x60;failed&#x60; and &#x60;deleted&#x60; (optional)
     * @param  string[] $paymentType Payment method payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param  string $customer Customer owning payment method (optional)
     * @param  string $subscription Payment methods for subscription (optional)
     * @param  string $reference Payment method reference (optional)
     * @param  string $failed Failed date interval (optional)
     * @param  string[] $cardType Card payment methods with card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string[] $transactionCardType Card payment methods with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string $cardPrefix Card payment methods with card with prefix (optional)
     * @param  string $cardPostfix Card payment methods with card number postfix (optional)
     * @param  string $cardFingerprint Card payment methods with card number postfix (optional)
     * @param  string[] $cardCountry Card payment methods with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param  string $cardGateway Card payment methods tied to card gateway (optional)
     * @param  string $cardAgreement Card payment methods tied to card agreement with id (optional)
     * @param  string $mpsExternalId MobilePay Subscription external id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentMethodListAsync($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $id = null, $state = null, $paymentType = null, $customer = null, $subscription = null, $reference = null, $failed = null, $cardType = null, $transactionCardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null, $cardCountry = null, $cardGateway = null, $cardAgreement = null, $mpsExternalId = null)
    {
        return $this->getPaymentMethodListAsyncWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $id, $state, $paymentType, $customer, $subscription, $reference, $failed, $cardType, $transactionCardType, $cardPrefix, $cardPostfix, $cardFingerprint, $cardCountry, $cardGateway, $cardAgreement, $mpsExternalId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentMethodListAsyncWithHttpInfo
     *
     * Get list of payment methods
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param  string $id Payment method id (optional)
     * @param  string[] $state Payment state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;active&#x60;, &#x60;inactivated&#x60;, &#x60;failed&#x60; and &#x60;deleted&#x60; (optional)
     * @param  string[] $paymentType Payment method payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param  string $customer Customer owning payment method (optional)
     * @param  string $subscription Payment methods for subscription (optional)
     * @param  string $reference Payment method reference (optional)
     * @param  string $failed Failed date interval (optional)
     * @param  string[] $cardType Card payment methods with card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string[] $transactionCardType Card payment methods with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string $cardPrefix Card payment methods with card with prefix (optional)
     * @param  string $cardPostfix Card payment methods with card number postfix (optional)
     * @param  string $cardFingerprint Card payment methods with card number postfix (optional)
     * @param  string[] $cardCountry Card payment methods with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param  string $cardGateway Card payment methods tied to card gateway (optional)
     * @param  string $cardAgreement Card payment methods tied to card agreement with id (optional)
     * @param  string $mpsExternalId MobilePay Subscription external id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentMethodListAsyncWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $id = null, $state = null, $paymentType = null, $customer = null, $subscription = null, $reference = null, $failed = null, $cardType = null, $transactionCardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null, $cardCountry = null, $cardGateway = null, $cardAgreement = null, $mpsExternalId = null)
    {
        $returnType = '\Reepay\Model\PaymentMethodList';
        $request = $this->getPaymentMethodListRequest($from, $to, $interval, $size, $nextPageToken, $range, $id, $state, $paymentType, $customer, $subscription, $reference, $failed, $cardType, $transactionCardType, $cardPrefix, $cardPostfix, $cardFingerprint, $cardCountry, $cardGateway, $cardAgreement, $mpsExternalId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentMethodList'
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param  string $id Payment method id (optional)
     * @param  string[] $state Payment state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;active&#x60;, &#x60;inactivated&#x60;, &#x60;failed&#x60; and &#x60;deleted&#x60; (optional)
     * @param  string[] $paymentType Payment method payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param  string $customer Customer owning payment method (optional)
     * @param  string $subscription Payment methods for subscription (optional)
     * @param  string $reference Payment method reference (optional)
     * @param  string $failed Failed date interval (optional)
     * @param  string[] $cardType Card payment methods with card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string[] $transactionCardType Card payment methods with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string $cardPrefix Card payment methods with card with prefix (optional)
     * @param  string $cardPostfix Card payment methods with card number postfix (optional)
     * @param  string $cardFingerprint Card payment methods with card number postfix (optional)
     * @param  string[] $cardCountry Card payment methods with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param  string $cardGateway Card payment methods tied to card gateway (optional)
     * @param  string $cardAgreement Card payment methods tied to card agreement with id (optional)
     * @param  string $mpsExternalId MobilePay Subscription external id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPaymentMethodListRequest($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $id = null, $state = null, $paymentType = null, $customer = null, $subscription = null, $reference = null, $failed = null, $cardType = null, $transactionCardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null, $cardCountry = null, $cardGateway = null, $cardAgreement = null, $mpsExternalId = null)
    {

        $resourcePath = '/v1/list/payment_method';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($nextPageToken !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($nextPageToken, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id, null);
        }
        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, 'multi', true);
        }
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if (is_array($paymentType)) {
            $paymentType = ObjectSerializer::serializeCollection($paymentType, 'multi', true);
        }
        if ($paymentType !== null) {
            $queryParams['payment_type'] = ObjectSerializer::toQueryValue($paymentType, null);
        }
        // query params
        if ($customer !== null) {
            $queryParams['customer'] = ObjectSerializer::toQueryValue($customer, null);
        }
        // query params
        if ($subscription !== null) {
            $queryParams['subscription'] = ObjectSerializer::toQueryValue($subscription, null);
        }
        // query params
        if ($reference !== null) {
            $queryParams['reference'] = ObjectSerializer::toQueryValue($reference, null);
        }
        // query params
        if ($failed !== null) {
            $queryParams['failed'] = ObjectSerializer::toQueryValue($failed, null);
        }
        // query params
        if (is_array($cardType)) {
            $cardType = ObjectSerializer::serializeCollection($cardType, 'multi', true);
        }
        if ($cardType !== null) {
            $queryParams['card_type'] = ObjectSerializer::toQueryValue($cardType, null);
        }
        // query params
        if (is_array($transactionCardType)) {
            $transactionCardType = ObjectSerializer::serializeCollection($transactionCardType, 'multi', true);
        }
        if ($transactionCardType !== null) {
            $queryParams['transaction_card_type'] = ObjectSerializer::toQueryValue($transactionCardType, null);
        }
        // query params
        if ($cardPrefix !== null) {
            $queryParams['card_prefix'] = ObjectSerializer::toQueryValue($cardPrefix, null);
        }
        // query params
        if ($cardPostfix !== null) {
            $queryParams['card_postfix'] = ObjectSerializer::toQueryValue($cardPostfix, null);
        }
        // query params
        if ($cardFingerprint !== null) {
            $queryParams['card_fingerprint'] = ObjectSerializer::toQueryValue($cardFingerprint, null);
        }
        // query params
        if (is_array($cardCountry)) {
            $cardCountry = ObjectSerializer::serializeCollection($cardCountry, 'multi', true);
        }
        if ($cardCountry !== null) {
            $queryParams['card_country'] = ObjectSerializer::toQueryValue($cardCountry, null);
        }
        // query params
        if ($cardGateway !== null) {
            $queryParams['card_gateway'] = ObjectSerializer::toQueryValue($cardGateway, null);
        }
        // query params
        if ($cardAgreement !== null) {
            $queryParams['card_agreement'] = ObjectSerializer::toQueryValue($cardAgreement, null);
        }
        // query params
        if ($mpsExternalId !== null) {
            $queryParams['mps_external_id'] = ObjectSerializer::toQueryValue($mpsExternalId, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPayoutList
     *
     * Get list of payouts
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;paid&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Payout handle prefix (optional)
     * @param  string $handleContains Payout handle contains (optional)
     * @param  string $customer Payouts for customer by customer handle (optional)
     * @param  string[] $state Payout transaction state, multiple can be defined (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Payout currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  string $card Payouts for saved card (optional)
     * @param  string $cardType Payouts for card type (optional)
     * @param  string $cardPrefix Payouts for card with prefix (optional)
     * @param  string $cardPostfix Payouts for card with postfix (optional)
     * @param  string $cardFingerprint Payouts for card with postfix (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\PayoutList
     */
    public function getPayoutList($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $customer = null, $state = null, $amount = null, $currency = null, $card = null, $cardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null)
    {
        list($response) = $this->getPayoutListWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $customer, $state, $amount, $currency, $card, $cardType, $cardPrefix, $cardPostfix, $cardFingerprint);
        return $response;
    }

    /**
     * Operation getPayoutListWithHttpInfo
     *
     * Get list of payouts
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;paid&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Payout handle prefix (optional)
     * @param  string $handleContains Payout handle contains (optional)
     * @param  string $customer Payouts for customer by customer handle (optional)
     * @param  string[] $state Payout transaction state, multiple can be defined (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Payout currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  string $card Payouts for saved card (optional)
     * @param  string $cardType Payouts for card type (optional)
     * @param  string $cardPrefix Payouts for card with prefix (optional)
     * @param  string $cardPostfix Payouts for card with postfix (optional)
     * @param  string $cardFingerprint Payouts for card with postfix (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\PayoutList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPayoutListWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $customer = null, $state = null, $amount = null, $currency = null, $card = null, $cardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null)
    {
        $returnType = '\Reepay\Model\PayoutList';
        $request = $this->getPayoutListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $customer, $state, $amount, $currency, $card, $cardType, $cardPrefix, $cardPostfix, $cardFingerprint);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\PayoutList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPayoutListAsync
     *
     * Get list of payouts
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;paid&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Payout handle prefix (optional)
     * @param  string $handleContains Payout handle contains (optional)
     * @param  string $customer Payouts for customer by customer handle (optional)
     * @param  string[] $state Payout transaction state, multiple can be defined (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Payout currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  string $card Payouts for saved card (optional)
     * @param  string $cardType Payouts for card type (optional)
     * @param  string $cardPrefix Payouts for card with prefix (optional)
     * @param  string $cardPostfix Payouts for card with postfix (optional)
     * @param  string $cardFingerprint Payouts for card with postfix (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPayoutListAsync($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $customer = null, $state = null, $amount = null, $currency = null, $card = null, $cardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null)
    {
        return $this->getPayoutListAsyncWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $customer, $state, $amount, $currency, $card, $cardType, $cardPrefix, $cardPostfix, $cardFingerprint)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPayoutListAsyncWithHttpInfo
     *
     * Get list of payouts
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;paid&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Payout handle prefix (optional)
     * @param  string $handleContains Payout handle contains (optional)
     * @param  string $customer Payouts for customer by customer handle (optional)
     * @param  string[] $state Payout transaction state, multiple can be defined (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Payout currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  string $card Payouts for saved card (optional)
     * @param  string $cardType Payouts for card type (optional)
     * @param  string $cardPrefix Payouts for card with prefix (optional)
     * @param  string $cardPostfix Payouts for card with postfix (optional)
     * @param  string $cardFingerprint Payouts for card with postfix (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPayoutListAsyncWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $customer = null, $state = null, $amount = null, $currency = null, $card = null, $cardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null)
    {
        $returnType = '\Reepay\Model\PayoutList';
        $request = $this->getPayoutListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $handleContains, $customer, $state, $amount, $currency, $card, $cardType, $cardPrefix, $cardPostfix, $cardFingerprint);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPayoutList'
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;paid&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string $handle Payout handle prefix (optional)
     * @param  string $handleContains Payout handle contains (optional)
     * @param  string $customer Payouts for customer by customer handle (optional)
     * @param  string[] $state Payout transaction state, multiple can be defined (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $currency Payout currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  string $card Payouts for saved card (optional)
     * @param  string $cardType Payouts for card type (optional)
     * @param  string $cardPrefix Payouts for card with prefix (optional)
     * @param  string $cardPostfix Payouts for card with postfix (optional)
     * @param  string $cardFingerprint Payouts for card with postfix (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPayoutListRequest($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $handleContains = null, $customer = null, $state = null, $amount = null, $currency = null, $card = null, $cardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null)
    {

        $resourcePath = '/v1/list/payout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($nextPageToken !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($nextPageToken, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($handleContains !== null) {
            $queryParams['handle_contains'] = ObjectSerializer::toQueryValue($handleContains, null);
        }
        // query params
        if ($customer !== null) {
            $queryParams['customer'] = ObjectSerializer::toQueryValue($customer, null);
        }
        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, 'multi', true);
        }
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if (is_array($currency)) {
            $currency = ObjectSerializer::serializeCollection($currency, 'multi', true);
        }
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency, null);
        }
        // query params
        if ($card !== null) {
            $queryParams['card'] = ObjectSerializer::toQueryValue($card, null);
        }
        // query params
        if ($cardType !== null) {
            $queryParams['card_type'] = ObjectSerializer::toQueryValue($cardType, null);
        }
        // query params
        if ($cardPrefix !== null) {
            $queryParams['card_prefix'] = ObjectSerializer::toQueryValue($cardPrefix, null);
        }
        // query params
        if ($cardPostfix !== null) {
            $queryParams['card_postfix'] = ObjectSerializer::toQueryValue($cardPostfix, null);
        }
        // query params
        if ($cardFingerprint !== null) {
            $queryParams['card_fingerprint'] = ObjectSerializer::toQueryValue($cardFingerprint, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPlanList
     *
     * Get list of plans
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute for time limit. Accepted value &#x60;created&#x60; (optional, default to created)
     * @param  string $handle Plan handle prefix (optional)
     * @param  string[] $state State of the subscription plan, one of the following: &#x60;active&#x60;, &#x60;superseded&#x60; or &#x60;deleted&#x60;. Multiple can be defined. (optional)
     * @param  string[] $scheduleType Scheduling type, one of the following: &#x60;manual&#x60;, &#x60;daily&#x60;, &#x60;weekly_fixedday&#x60;, &#x60;month_startdate&#x60;, &#x60;month_fixedday&#x60;, &#x60;month_lastday&#x60;. Multiple can be defined. (optional)
     * @param  string[] $partialPeriodHandling The way to bill initial (not full) period. Options: &#x60;bill_full&#x60;, &#x60;bill_prorated&#x60;, &#x60;bill_zero_amount&#x60;, &#x60;no_bill&#x60;. Multiple can be defined. (optional)
     * @param  string[] $setupFeeHandling How the billing of the setup fee should be done. Accepted values: &#x60;first&#x60;, &#x60;separate&#x60;, &#x60;separate_conditional&#x60;. Multiple can be defined. (optional)
     * @param  string[] $fixedLifeTimeUnit Time unit use for fixed life time. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param  string[] $trialIntervalUnit Time unit for free trial period. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param  string $dunningPlanHandle Dunning plan handle (optional)
     * @param  string $name Name of plan. Used as order line text. (optional)
     * @param  string $description Optional description of plan (optional)
     * @param  string $setupFeeText Optional invoice order text for the setup fee (optional)
     * @param  string $amount Fixed amount plan deducted from order line amounts including VAT. (optional)
     * @param  string $quantity Optional default quantity of the subscription plan product for new subscriptions. Default is 1. (optional)
     * @param  string $fixedCount Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices. (optional)
     * @param  string $fixedLifeTimeLength The number of days/months for which the subscription is live. (optional)
     * @param  string $trialIntervalLength The number of days/months for how long the free trial period lasts (optional)
     * @param  string $intervalLength The length of subscription intervals. E.g. every second month or every 14 days. (optional)
     * @param  string $scheduleFixedDay The number of day for &#x60;weekly_fixedday&#x60; and &#x60;month_fixedday&#x60; schedule types. For months the allowed values are 1-28 for weeks 1-7 (optional)
     * @param  string $renewalReminderEmailDays Number of days before next billing to send a reminder email. (optional)
     * @param  string $trialReminderEmailDays Number of days before end of trial to send a reminder email. (optional)
     * @param string $baseMonth Base month for fixed month schedule type (optional)
     * @param string $noticePeriods Number of notice periods before a cancellation. (optional)
     * @param string $minimumProratedAmount Minimum amount for prorated invoice. If the amount is less, 0 is charged (optional)
     * @param string $fixationPeriods Number of paid periods before expiring after a cancellation. (optional)
     * @param string $setupFee Optional one-time setup fee billed with the first invoice. (optional)
     * @param string $amountInclVat Whether the amount is including VAT. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $noticePeriodsAfterCurrent Is cancelled flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixationPeriodsFull If fixation periods are defined, and the subscription can have a partial prorated first period,this parameter controls if the the last period should be full, or partial. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $includeZeroAmount Whether to add a zero amount order line to subscription invoices. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $partialProrationDays If proration should be day based (instead of minute). Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixedTrialDays Controls if trial expires at midnight or it&#x27;s down to the minute. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\PlanList
     */
    public function getPlanList($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = null, $scheduleType = null, $partialPeriodHandling = null, $setupFeeHandling = null, $fixedLifeTimeUnit = null, $trialIntervalUnit = null, $dunningPlanHandle = null, $name = null, $description = null, $setupFeeText = null, $amount = null, $quantity = null, $fixedCount = null, $fixedLifeTimeLength = null, $trialIntervalLength = null, $intervalLength = null, $scheduleFixedDay = null, $renewalReminderEmailDays = null, $trialReminderEmailDays = null, $baseMonth = null, $noticePeriods = null, $minimumProratedAmount = null, $fixationPeriods = null, $setupFee = null, $amountInclVat = null, $noticePeriodsAfterCurrent = null, $fixationPeriodsFull = null, $includeZeroAmount = null, $partialProrationDays = null, $fixedTrialDays = null)
    {
        list($response) = $this->getPlanListWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $state, $scheduleType, $partialPeriodHandling, $setupFeeHandling, $fixedLifeTimeUnit, $trialIntervalUnit, $dunningPlanHandle, $name, $description, $setupFeeText, $amount, $quantity, $fixedCount, $fixedLifeTimeLength, $trialIntervalLength, $intervalLength, $scheduleFixedDay, $renewalReminderEmailDays, $trialReminderEmailDays, $baseMonth, $noticePeriods, $minimumProratedAmount, $fixationPeriods, $setupFee, $amountInclVat, $noticePeriodsAfterCurrent, $fixationPeriodsFull, $includeZeroAmount, $partialProrationDays, $fixedTrialDays);
        return $response;
    }

    /**
     * Operation getPlanListWithHttpInfo
     *
     * Get list of plans
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute for time limit. Accepted value &#x60;created&#x60; (optional, default to created)
     * @param  string $handle Plan handle prefix (optional)
     * @param  string[] $state State of the subscription plan, one of the following: &#x60;active&#x60;, &#x60;superseded&#x60; or &#x60;deleted&#x60;. Multiple can be defined. (optional)
     * @param  string[] $scheduleType Scheduling type, one of the following: &#x60;manual&#x60;, &#x60;daily&#x60;, &#x60;weekly_fixedday&#x60;, &#x60;month_startdate&#x60;, &#x60;month_fixedday&#x60;, &#x60;month_lastday&#x60;. Multiple can be defined. (optional)
     * @param  string[] $partialPeriodHandling The way to bill initial (not full) period. Options: &#x60;bill_full&#x60;, &#x60;bill_prorated&#x60;, &#x60;bill_zero_amount&#x60;, &#x60;no_bill&#x60;. Multiple can be defined. (optional)
     * @param  string[] $setupFeeHandling How the billing of the setup fee should be done. Accepted values: &#x60;first&#x60;, &#x60;separate&#x60;, &#x60;separate_conditional&#x60;. Multiple can be defined. (optional)
     * @param  string[] $fixedLifeTimeUnit Time unit use for fixed life time. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param  string[] $trialIntervalUnit Time unit for free trial period. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param  string $dunningPlanHandle Dunning plan handle (optional)
     * @param  string $name Name of plan. Used as order line text. (optional)
     * @param  string $description Optional description of plan (optional)
     * @param  string $setupFeeText Optional invoice order text for the setup fee (optional)
     * @param  string $amount Fixed amount plan deducted from order line amounts including VAT. (optional)
     * @param  string $quantity Optional default quantity of the subscription plan product for new subscriptions. Default is 1. (optional)
     * @param  string $fixedCount Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices. (optional)
     * @param  string $fixedLifeTimeLength The number of days/months for which the subscription is live. (optional)
     * @param  string $trialIntervalLength The number of days/months for how long the free trial period lasts (optional)
     * @param  string $intervalLength The length of subscription intervals. E.g. every second month or every 14 days. (optional)
     * @param  string $scheduleFixedDay The number of day for &#x60;weekly_fixedday&#x60; and &#x60;month_fixedday&#x60; schedule types. For months the allowed values are 1-28 for weeks 1-7 (optional)
     * @param  string $renewalReminderEmailDays Number of days before next billing to send a reminder email. (optional)
     * @param  string $trialReminderEmailDays Number of days before end of trial to send a reminder email. (optional)
     * @param string $baseMonth Base month for fixed month schedule type (optional)
     * @param string $noticePeriods Number of notice periods before a cancellation. (optional)
     * @param string $minimumProratedAmount Minimum amount for prorated invoice. If the amount is less, 0 is charged (optional)
     * @param string $fixationPeriods Number of paid periods before expiring after a cancellation. (optional)
     * @param string $setupFee Optional one-time setup fee billed with the first invoice. (optional)
     * @param string $amountInclVat Whether the amount is including VAT. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $noticePeriodsAfterCurrent Is cancelled flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixationPeriodsFull If fixation periods are defined, and the subscription can have a partial prorated first period,this parameter controls if the the last period should be full, or partial. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $includeZeroAmount Whether to add a zero amount order line to subscription invoices. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $partialProrationDays If proration should be day based (instead of minute). Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixedTrialDays Controls if trial expires at midnight or it&#x27;s down to the minute. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\PlanList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPlanListWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = null, $scheduleType = null, $partialPeriodHandling = null, $setupFeeHandling = null, $fixedLifeTimeUnit = null, $trialIntervalUnit = null, $dunningPlanHandle = null, $name = null, $description = null, $setupFeeText = null, $amount = null, $quantity = null, $fixedCount = null, $fixedLifeTimeLength = null, $trialIntervalLength = null, $intervalLength = null, $scheduleFixedDay = null, $renewalReminderEmailDays = null, $trialReminderEmailDays = null, $baseMonth = null, $noticePeriods = null, $minimumProratedAmount = null, $fixationPeriods = null, $setupFee = null, $amountInclVat = null, $noticePeriodsAfterCurrent = null, $fixationPeriodsFull = null, $includeZeroAmount = null, $partialProrationDays = null, $fixedTrialDays = null)
    {
        $returnType = '\Reepay\Model\PlanList';
        $request = $this->getPlanListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $state, $scheduleType, $partialPeriodHandling, $setupFeeHandling, $fixedLifeTimeUnit, $trialIntervalUnit, $dunningPlanHandle, $name, $description, $setupFeeText, $amount, $quantity, $fixedCount, $fixedLifeTimeLength, $trialIntervalLength, $intervalLength, $scheduleFixedDay, $renewalReminderEmailDays, $trialReminderEmailDays, $baseMonth, $noticePeriods, $minimumProratedAmount, $fixationPeriods, $setupFee, $amountInclVat, $noticePeriodsAfterCurrent, $fixationPeriodsFull, $includeZeroAmount, $partialProrationDays, $fixedTrialDays);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\PlanList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPlanListAsync
     *
     * Get list of plans
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute for time limit. Accepted value &#x60;created&#x60; (optional, default to created)
     * @param  string $handle Plan handle prefix (optional)
     * @param  string[] $state State of the subscription plan, one of the following: &#x60;active&#x60;, &#x60;superseded&#x60; or &#x60;deleted&#x60;. Multiple can be defined. (optional)
     * @param  string[] $scheduleType Scheduling type, one of the following: &#x60;manual&#x60;, &#x60;daily&#x60;, &#x60;weekly_fixedday&#x60;, &#x60;month_startdate&#x60;, &#x60;month_fixedday&#x60;, &#x60;month_lastday&#x60;. Multiple can be defined. (optional)
     * @param  string[] $partialPeriodHandling The way to bill initial (not full) period. Options: &#x60;bill_full&#x60;, &#x60;bill_prorated&#x60;, &#x60;bill_zero_amount&#x60;, &#x60;no_bill&#x60;. Multiple can be defined. (optional)
     * @param  string[] $setupFeeHandling How the billing of the setup fee should be done. Accepted values: &#x60;first&#x60;, &#x60;separate&#x60;, &#x60;separate_conditional&#x60;. Multiple can be defined. (optional)
     * @param  string[] $fixedLifeTimeUnit Time unit use for fixed life time. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param  string[] $trialIntervalUnit Time unit for free trial period. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param  string $dunningPlanHandle Dunning plan handle (optional)
     * @param  string $name Name of plan. Used as order line text. (optional)
     * @param  string $description Optional description of plan (optional)
     * @param  string $setupFeeText Optional invoice order text for the setup fee (optional)
     * @param  string $amount Fixed amount plan deducted from order line amounts including VAT. (optional)
     * @param  string $quantity Optional default quantity of the subscription plan product for new subscriptions. Default is 1. (optional)
     * @param  string $fixedCount Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices. (optional)
     * @param  string $fixedLifeTimeLength The number of days/months for which the subscription is live. (optional)
     * @param  string $trialIntervalLength The number of days/months for how long the free trial period lasts (optional)
     * @param  string $intervalLength The length of subscription intervals. E.g. every second month or every 14 days. (optional)
     * @param  string $scheduleFixedDay The number of day for &#x60;weekly_fixedday&#x60; and &#x60;month_fixedday&#x60; schedule types. For months the allowed values are 1-28 for weeks 1-7 (optional)
     * @param  string $renewalReminderEmailDays Number of days before next billing to send a reminder email. (optional)
     * @param  string $trialReminderEmailDays Number of days before end of trial to send a reminder email. (optional)
     * @param string $baseMonth Base month for fixed month schedule type (optional)
     * @param string $noticePeriods Number of notice periods before a cancellation. (optional)
     * @param string $minimumProratedAmount Minimum amount for prorated invoice. If the amount is less, 0 is charged (optional)
     * @param string $fixationPeriods Number of paid periods before expiring after a cancellation. (optional)
     * @param string $setupFee Optional one-time setup fee billed with the first invoice. (optional)
     * @param string $amountInclVat Whether the amount is including VAT. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $noticePeriodsAfterCurrent Is cancelled flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixationPeriodsFull If fixation periods are defined, and the subscription can have a partial prorated first period,this parameter controls if the the last period should be full, or partial. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $includeZeroAmount Whether to add a zero amount order line to subscription invoices. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $partialProrationDays If proration should be day based (instead of minute). Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixedTrialDays Controls if trial expires at midnight or it&#x27;s down to the minute. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPlanListAsync($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = null, $scheduleType = null, $partialPeriodHandling = null, $setupFeeHandling = null, $fixedLifeTimeUnit = null, $trialIntervalUnit = null, $dunningPlanHandle = null, $name = null, $description = null, $setupFeeText = null, $amount = null, $quantity = null, $fixedCount = null, $fixedLifeTimeLength = null, $trialIntervalLength = null, $intervalLength = null, $scheduleFixedDay = null, $renewalReminderEmailDays = null, $trialReminderEmailDays = null, $baseMonth = null, $noticePeriods = null, $minimumProratedAmount = null, $fixationPeriods = null, $setupFee = null, $amountInclVat = null, $noticePeriodsAfterCurrent = null, $fixationPeriodsFull = null, $includeZeroAmount = null, $partialProrationDays = null, $fixedTrialDays = null)
    {
        return $this->getPlanListAsyncWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $handle, $state, $scheduleType, $partialPeriodHandling, $setupFeeHandling, $fixedLifeTimeUnit, $trialIntervalUnit, $dunningPlanHandle, $name, $description, $setupFeeText, $amount, $quantity, $fixedCount, $fixedLifeTimeLength, $trialIntervalLength, $intervalLength, $scheduleFixedDay, $renewalReminderEmailDays, $trialReminderEmailDays, $baseMonth, $noticePeriods, $minimumProratedAmount, $fixationPeriods, $setupFee, $amountInclVat, $noticePeriodsAfterCurrent, $fixationPeriodsFull, $includeZeroAmount, $partialProrationDays, $fixedTrialDays)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPlanListAsyncWithHttpInfo
     *
     * Get list of plans
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute for time limit. Accepted value &#x60;created&#x60; (optional, default to created)
     * @param  string $handle Plan handle prefix (optional)
     * @param  string[] $state State of the subscription plan, one of the following: &#x60;active&#x60;, &#x60;superseded&#x60; or &#x60;deleted&#x60;. Multiple can be defined. (optional)
     * @param  string[] $scheduleType Scheduling type, one of the following: &#x60;manual&#x60;, &#x60;daily&#x60;, &#x60;weekly_fixedday&#x60;, &#x60;month_startdate&#x60;, &#x60;month_fixedday&#x60;, &#x60;month_lastday&#x60;. Multiple can be defined. (optional)
     * @param  string[] $partialPeriodHandling The way to bill initial (not full) period. Options: &#x60;bill_full&#x60;, &#x60;bill_prorated&#x60;, &#x60;bill_zero_amount&#x60;, &#x60;no_bill&#x60;. Multiple can be defined. (optional)
     * @param  string[] $setupFeeHandling How the billing of the setup fee should be done. Accepted values: &#x60;first&#x60;, &#x60;separate&#x60;, &#x60;separate_conditional&#x60;. Multiple can be defined. (optional)
     * @param  string[] $fixedLifeTimeUnit Time unit use for fixed life time. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param  string[] $trialIntervalUnit Time unit for free trial period. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param  string $dunningPlanHandle Dunning plan handle (optional)
     * @param  string $name Name of plan. Used as order line text. (optional)
     * @param  string $description Optional description of plan (optional)
     * @param  string $setupFeeText Optional invoice order text for the setup fee (optional)
     * @param  string $amount Fixed amount plan deducted from order line amounts including VAT. (optional)
     * @param  string $quantity Optional default quantity of the subscription plan product for new subscriptions. Default is 1. (optional)
     * @param  string $fixedCount Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices. (optional)
     * @param  string $fixedLifeTimeLength The number of days/months for which the subscription is live. (optional)
     * @param  string $trialIntervalLength The number of days/months for how long the free trial period lasts (optional)
     * @param  string $intervalLength The length of subscription intervals. E.g. every second month or every 14 days. (optional)
     * @param  string $scheduleFixedDay The number of day for &#x60;weekly_fixedday&#x60; and &#x60;month_fixedday&#x60; schedule types. For months the allowed values are 1-28 for weeks 1-7 (optional)
     * @param  string $renewalReminderEmailDays Number of days before next billing to send a reminder email. (optional)
     * @param  string $trialReminderEmailDays Number of days before end of trial to send a reminder email. (optional)
     * @param string $baseMonth Base month for fixed month schedule type (optional)
     * @param string $noticePeriods Number of notice periods before a cancellation. (optional)
     * @param string $minimumProratedAmount Minimum amount for prorated invoice. If the amount is less, 0 is charged (optional)
     * @param string $fixationPeriods Number of paid periods before expiring after a cancellation. (optional)
     * @param string $setupFee Optional one-time setup fee billed with the first invoice. (optional)
     * @param string $amountInclVat Whether the amount is including VAT. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $noticePeriodsAfterCurrent Is cancelled flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixationPeriodsFull If fixation periods are defined, and the subscription can have a partial prorated first period,this parameter controls if the the last period should be full, or partial. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $includeZeroAmount Whether to add a zero amount order line to subscription invoices. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $partialProrationDays If proration should be day based (instead of minute). Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixedTrialDays Controls if trial expires at midnight or it&#x27;s down to the minute. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPlanListAsyncWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = null, $scheduleType = null, $partialPeriodHandling = null, $setupFeeHandling = null, $fixedLifeTimeUnit = null, $trialIntervalUnit = null, $dunningPlanHandle = null, $name = null, $description = null, $setupFeeText = null, $amount = null, $quantity = null, $fixedCount = null, $fixedLifeTimeLength = null, $trialIntervalLength = null, $intervalLength = null, $scheduleFixedDay = null, $renewalReminderEmailDays = null, $trialReminderEmailDays = null, $baseMonth = null, $noticePeriods = null, $minimumProratedAmount = null, $fixationPeriods = null, $setupFee = null, $amountInclVat = null, $noticePeriodsAfterCurrent = null, $fixationPeriodsFull = null, $includeZeroAmount = null, $partialProrationDays = null, $fixedTrialDays = null)
    {
        $returnType = '\Reepay\Model\PlanList';
        $request = $this->getPlanListRequest($from, $to, $interval, $size, $nextPageToken, $range, $handle, $state, $scheduleType, $partialPeriodHandling, $setupFeeHandling, $fixedLifeTimeUnit, $trialIntervalUnit, $dunningPlanHandle, $name, $description, $setupFeeText, $amount, $quantity, $fixedCount, $fixedLifeTimeLength, $trialIntervalLength, $intervalLength, $scheduleFixedDay, $renewalReminderEmailDays, $trialReminderEmailDays, $baseMonth, $noticePeriods, $minimumProratedAmount, $fixationPeriods, $setupFee, $amountInclVat, $noticePeriodsAfterCurrent, $fixationPeriodsFull, $includeZeroAmount, $partialProrationDays, $fixedTrialDays);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPlanList'
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute for time limit. Accepted value &#x60;created&#x60; (optional, default to created)
     * @param  string $handle Plan handle prefix (optional)
     * @param  string[] $state State of the subscription plan, one of the following: &#x60;active&#x60;, &#x60;superseded&#x60; or &#x60;deleted&#x60;. Multiple can be defined. (optional)
     * @param  string[] $scheduleType Scheduling type, one of the following: &#x60;manual&#x60;, &#x60;daily&#x60;, &#x60;weekly_fixedday&#x60;, &#x60;month_startdate&#x60;, &#x60;month_fixedday&#x60;, &#x60;month_lastday&#x60;. Multiple can be defined. (optional)
     * @param  string[] $partialPeriodHandling The way to bill initial (not full) period. Options: &#x60;bill_full&#x60;, &#x60;bill_prorated&#x60;, &#x60;bill_zero_amount&#x60;, &#x60;no_bill&#x60;. Multiple can be defined. (optional)
     * @param  string[] $setupFeeHandling How the billing of the setup fee should be done. Accepted values: &#x60;first&#x60;, &#x60;separate&#x60;, &#x60;separate_conditional&#x60;. Multiple can be defined. (optional)
     * @param  string[] $fixedLifeTimeUnit Time unit use for fixed life time. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param  string[] $trialIntervalUnit Time unit for free trial period. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param  string $dunningPlanHandle Dunning plan handle (optional)
     * @param  string $name Name of plan. Used as order line text. (optional)
     * @param  string $description Optional description of plan (optional)
     * @param  string $setupFeeText Optional invoice order text for the setup fee (optional)
     * @param  string $amount Fixed amount plan deducted from order line amounts including VAT. (optional)
     * @param  string $quantity Optional default quantity of the subscription plan product for new subscriptions. Default is 1. (optional)
     * @param  string $fixedCount Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices. (optional)
     * @param  string $fixedLifeTimeLength The number of days/months for which the subscription is live. (optional)
     * @param  string $trialIntervalLength The number of days/months for how long the free trial period lasts (optional)
     * @param  string $intervalLength The length of subscription intervals. E.g. every second month or every 14 days. (optional)
     * @param  string $scheduleFixedDay The number of day for &#x60;weekly_fixedday&#x60; and &#x60;month_fixedday&#x60; schedule types. For months the allowed values are 1-28 for weeks 1-7 (optional)
     * @param  string $renewalReminderEmailDays Number of days before next billing to send a reminder email. (optional)
     * @param  string $trialReminderEmailDays Number of days before end of trial to send a reminder email. (optional)
     * @param string $baseMonth Base month for fixed month schedule type (optional)
     * @param string $noticePeriods Number of notice periods before a cancellation. (optional)
     * @param string $minimumProratedAmount Minimum amount for prorated invoice. If the amount is less, 0 is charged (optional)
     * @param string $fixationPeriods Number of paid periods before expiring after a cancellation. (optional)
     * @param string $setupFee Optional one-time setup fee billed with the first invoice. (optional)
     * @param string $amountInclVat Whether the amount is including VAT. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $noticePeriodsAfterCurrent Is cancelled flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixationPeriodsFull If fixation periods are defined, and the subscription can have a partial prorated first period,this parameter controls if the the last period should be full, or partial. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $includeZeroAmount Whether to add a zero amount order line to subscription invoices. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $partialProrationDays If proration should be day based (instead of minute). Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixedTrialDays Controls if trial expires at midnight or it&#x27;s down to the minute. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPlanListRequest($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $handle = null, $state = null, $scheduleType = null, $partialPeriodHandling = null, $setupFeeHandling = null, $fixedLifeTimeUnit = null, $trialIntervalUnit = null, $dunningPlanHandle = null, $name = null, $description = null, $setupFeeText = null, $amount = null, $quantity = null, $fixedCount = null, $fixedLifeTimeLength = null, $trialIntervalLength = null, $intervalLength = null, $scheduleFixedDay = null, $renewalReminderEmailDays = null, $trialReminderEmailDays = null, $baseMonth = null, $noticePeriods = null, $minimumProratedAmount = null, $fixationPeriods = null, $setupFee = null, $amountInclVat = null, $noticePeriodsAfterCurrent = null, $fixationPeriodsFull = null, $includeZeroAmount = null, $partialProrationDays = null, $fixedTrialDays = null)
    {

        $resourcePath = '/v1/list/plan';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($nextPageToken !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($nextPageToken, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, 'multi', true);
        }
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if (is_array($scheduleType)) {
            $scheduleType = ObjectSerializer::serializeCollection($scheduleType, 'multi', true);
        }
        if ($scheduleType !== null) {
            $queryParams['schedule_type'] = ObjectSerializer::toQueryValue($scheduleType, null);
        }
        // query params
        if (is_array($partialPeriodHandling)) {
            $partialPeriodHandling = ObjectSerializer::serializeCollection($partialPeriodHandling, 'multi', true);
        }
        if ($partialPeriodHandling !== null) {
            $queryParams['partial_period_handling'] = ObjectSerializer::toQueryValue($partialPeriodHandling, null);
        }
        // query params
        if (is_array($setupFeeHandling)) {
            $setupFeeHandling = ObjectSerializer::serializeCollection($setupFeeHandling, 'multi', true);
        }
        if ($setupFeeHandling !== null) {
            $queryParams['setup_fee_handling'] = ObjectSerializer::toQueryValue($setupFeeHandling, null);
        }
        // query params
        if (is_array($fixedLifeTimeUnit)) {
            $fixedLifeTimeUnit = ObjectSerializer::serializeCollection($fixedLifeTimeUnit, 'multi', true);
        }
        if ($fixedLifeTimeUnit !== null) {
            $queryParams['fixed_life_time_unit'] = ObjectSerializer::toQueryValue($fixedLifeTimeUnit, null);
        }
        // query params
        if (is_array($trialIntervalUnit)) {
            $trialIntervalUnit = ObjectSerializer::serializeCollection($trialIntervalUnit, 'multi', true);
        }
        if ($trialIntervalUnit !== null) {
            $queryParams['trial_interval_unit'] = ObjectSerializer::toQueryValue($trialIntervalUnit, null);
        }
        // query params
        if ($dunningPlanHandle !== null) {
            $queryParams['dunning_plan_handle'] = ObjectSerializer::toQueryValue($dunningPlanHandle, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description, null);
        }
        // query params
        if ($setupFeeText !== null) {
            $queryParams['setup_fee_text'] = ObjectSerializer::toQueryValue($setupFeeText, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if ($quantity !== null) {
            $queryParams['quantity'] = ObjectSerializer::toQueryValue($quantity, null);
        }
        // query params
        if ($fixedCount !== null) {
            $queryParams['fixed_count'] = ObjectSerializer::toQueryValue($fixedCount, null);
        }
        // query params
        if ($fixedLifeTimeLength !== null) {
            $queryParams['fixed_life_time_length'] = ObjectSerializer::toQueryValue($fixedLifeTimeLength, null);
        }
        // query params
        if ($trialIntervalLength !== null) {
            $queryParams['trial_interval_length'] = ObjectSerializer::toQueryValue($trialIntervalLength, null);
        }
        // query params
        if ($intervalLength !== null) {
            $queryParams['interval_length'] = ObjectSerializer::toQueryValue($intervalLength, null);
        }
        // query params
        if ($scheduleFixedDay !== null) {
            $queryParams['schedule_fixed_day'] = ObjectSerializer::toQueryValue($scheduleFixedDay, null);
        }
        // query params
        if ($renewalReminderEmailDays !== null) {
            $queryParams['renewal_reminder_email_days'] = ObjectSerializer::toQueryValue(
                $renewalReminderEmailDays,
                null
            );
        }
        // query params
        if ($trialReminderEmailDays !== null) {
            $queryParams['trial_reminder_email_days'] = ObjectSerializer::toQueryValue($trialReminderEmailDays, null);
        }
        // query params
        if ($baseMonth !== null) {
            $queryParams['base_month'] = ObjectSerializer::toQueryValue($baseMonth, null);
        }
        // query params
        if ($noticePeriods !== null) {
            $queryParams['notice_periods'] = ObjectSerializer::toQueryValue($noticePeriods, null);
        }
        // query params
        if ($minimumProratedAmount !== null) {
            $queryParams['minimum_prorated_amount'] = ObjectSerializer::toQueryValue($minimumProratedAmount, null);
        }
        // query params
        if ($fixationPeriods !== null) {
            $queryParams['fixation_periods'] = ObjectSerializer::toQueryValue($fixationPeriods, null);
        }
        // query params
        if ($setupFee !== null) {
            $queryParams['setup_fee'] = ObjectSerializer::toQueryValue($setupFee, null);
        }
        // query params
        if ($amountInclVat !== null) {
            $queryParams['amount_incl_vat'] = ObjectSerializer::toQueryValue($amountInclVat, null);
        }
        // query params
        if ($noticePeriodsAfterCurrent !== null) {
            $queryParams['notice_periods_after_current'] = ObjectSerializer::toQueryValue(
                $noticePeriodsAfterCurrent,
                null
            );
        }
        // query params
        if ($fixationPeriodsFull !== null) {
            $queryParams['fixation_periods_full'] = ObjectSerializer::toQueryValue($fixationPeriodsFull, null);
        }
        // query params
        if ($includeZeroAmount !== null) {
            $queryParams['include_zero_amount'] = ObjectSerializer::toQueryValue($includeZeroAmount, null);
        }
        // query params
        if ($partialProrationDays !== null) {
            $queryParams['partial_proration_days'] = ObjectSerializer::toQueryValue($partialProrationDays, null);
        }
        // query params
        if ($fixedTrialDays !== null) {
            $queryParams['fixed_trial_days'] = ObjectSerializer::toQueryValue($fixedTrialDays, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSubscriptionList
     *
     * Get list of subscriptions
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $nextPageToken Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60;, &#x60;activated&#x60;, &#x60;expired&#x60;, &#x60;cancelled&#x60;, &#x60;on_hold&#x60; or &#x60;reactivated&#x60; (optional, default to created)
     * @param string $handle Subscription handle prefix (optional)
     * @param string $handleContains Subscription handle contains (optional)
     * @param string $customer Customer owning subscription (optional)
     * @param string $plan Plan owning subscription (optional)
     * @param string[] $state Subscription state, multiple can be defined. States: &#x60;active&#x60;, &#x60;expired&#x60;, &#x60;on_hold&#x60; or &#x60;pending&#x60; (optional)
     * @param string $amount Custom amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $quantity Quantity. See documentation of intervals. (optional)
     * @param string $activated Activated date interval (optional)
     * @param string $cancelledDate Cancelled date interval (optional)
     * @param string $reactivated Reactivated date interval (optional)
     * @param  string $created Created date interval (optional)
     * @param  string $renewing Renewing flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  int $planVersion Plan version (optional)
     * @param  string $amountInclVat Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $startDate Start date interval (optional)
     * @param  string $endDate End date interval (optional)
     * @param  string $graceDuration Grace duration in seconds. See documentation of intervals. (optional)
     * @param  string $currentPeriodStart Current period start date interval (optional)
     * @param  string $nextPeriodStart Next period start date interval (optional)
     * @param  string $firstPeriodStart First period start date interval (optional)
     * @param  string $lastPeriodStart Last period start date interval (optional)
     * @param  string $trialStart Trial period start date interval (optional)
     * @param  string $trialEnd Trial period end date interval (optional)
     * @param  string $inTrial In trial flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $hasStarted Has started flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $renewalCount Renewal Count. See documentation of intervals. (optional)
     * @param  string $expiredDate Expired period date interval (optional)
     * @param  string[] $expireReason On hold reason, multiple can be defined. Types: &#x60;dunning&#x60;, &#x60;cancelled&#x60;,&#x60;ondemand&#x60;, and &#x60;fixed&#x60; (optional)
     * @param  string $onHoldDate On hold period date interval (optional)
     * @param  string[] $onHoldReason On hold reason, multiple can be defined. Types: &#x60;ondemand&#x60;, and &#x60;dunning&#x60; (optional)
     * @param  string $paymentMethodAdded Payment method added flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $reminderEmailSent Reminder email sent period date interval (optional)
     * @param  string $failedInvoices Failed invoices. See documentation of intervals. (optional)
     * @param  string $failedAmount Failed amount. See documentation of intervals. (optional)
     * @param  string $cancelledInvoices Cancelled invoices. See documentation of intervals. (optional)
     * @param  string $cancelledAmount Cancelled amount. See documentation of intervals. (optional)
     * @param  string $pendingInvoices Pending invoices. See documentation of intervals. (optional)
     * @param  string $pendingAmount Pending amount invoices. See documentation of intervals. (optional)
     * @param  string $dunningInvoices Dunning invoices. See documentation of intervals. (optional)
     * @param  string $dunningAmount Dunning amount. See documentation of intervals. (optional)
     * @param  string $settledInvoices Settled invoices. See documentation of intervals. (optional)
     * @param  string $settledAmount Settled amount. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount. See documentation of intervals. (optional)
     * @param  string $pendingAdditionalCosts Pending additional costs. See documentation of intervals. (optional)
     * @param string $pendingAdditionalCostAmount Pending additional cost amount. See documentation of intervals. (optional)
     * @param string $transferredAdditionalCosts Transferred additional costs. See documentation of intervals. (optional)
     * @param string $transferredAdditionalCostAmount Transferred additional cost amount. See documentation of intervals. (optional)
     * @param string $pendingCredits Pending credits. See documentation of intervals. (optional)
     * @param string $pendingCreditAmount Pending credit amount. See documentation of intervals. (optional)
     * @param string $transferredCredits Transferred credits. See documentation of intervals. (optional)
     * @param string $transferredCreditAmount Transferred credit amount. See documentation of intervals. (optional)
     * @param string $subscriptionAddOnHandle Subscription add-on handle (optional)
     * @param string $addOnHandle Add-on handle (optional)
     * @param string $subscriptionDiscountHandle Subscription discount handle (optional)
     * @param string $discountHandle Discount handle (optional)
     * @param string $couponHandle Coupon handle (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\SubscriptionList
     */
    public function getSubscriptionList(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $nextPageToken = null,
        $range = 'created',
        $handle = null,
        $handleContains = null,
        $customer = null,
        $plan = null,
        $state = null,
        $amount = null,
        $quantity = null,
        $activated = null,
        $cancelledDate = null,
        $reactivated = null,
        $created = null,
        $renewing = null,
        $planVersion = null,
        $amountInclVat = null,
        $startDate = null,
        $endDate = null,
        $graceDuration = null,
        $currentPeriodStart = null,
        $nextPeriodStart = null,
        $firstPeriodStart = null,
        $lastPeriodStart = null,
        $trialStart = null,
        $trialEnd = null,
        $inTrial = null,
        $hasStarted = null,
        $renewalCount = null,
        $expiredDate = null,
        $expireReason = null,
        $onHoldDate = null,
        $onHoldReason = null,
        $paymentMethodAdded = null,
        $reminderEmailSent = null,
        $failedInvoices = null,
        $failedAmount = null,
        $cancelledInvoices = null,
        $cancelledAmount = null,
        $pendingInvoices = null,
        $pendingAmount = null,
        $dunningInvoices = null,
        $dunningAmount = null,
        $settledInvoices = null,
        $settledAmount = null,
        $refundedAmount = null,
        $pendingAdditionalCosts = null,
        $pendingAdditionalCostAmount = null,
        $transferredAdditionalCosts = null,
        $transferredAdditionalCostAmount = null,
        $pendingCredits = null,
        $pendingCreditAmount = null,
        $transferredCredits = null,
        $transferredCreditAmount = null,
        $subscriptionAddOnHandle = null,
        $addOnHandle = null,
        $subscriptionDiscountHandle = null,
        $discountHandle = null,
        $couponHandle = null
    ) {
        list($response) = $this->getSubscriptionListWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $nextPageToken,
            $range,
            $handle,
            $handleContains,
            $customer,
            $plan,
            $state,
            $amount,
            $quantity,
            $activated,
            $cancelledDate,
            $reactivated,
            $created,
            $renewing,
            $planVersion,
            $amountInclVat,
            $startDate,
            $endDate,
            $graceDuration,
            $currentPeriodStart,
            $nextPeriodStart,
            $firstPeriodStart,
            $lastPeriodStart,
            $trialStart,
            $trialEnd,
            $inTrial,
            $hasStarted,
            $renewalCount,
            $expiredDate,
            $expireReason,
            $onHoldDate,
            $onHoldReason,
            $paymentMethodAdded,
            $reminderEmailSent,
            $failedInvoices,
            $failedAmount,
            $cancelledInvoices,
            $cancelledAmount,
            $pendingInvoices,
            $pendingAmount,
            $dunningInvoices,
            $dunningAmount,
            $settledInvoices,
            $settledAmount,
            $refundedAmount,
            $pendingAdditionalCosts,
            $pendingAdditionalCostAmount,
            $transferredAdditionalCosts,
            $transferredAdditionalCostAmount,
            $pendingCredits,
            $pendingCreditAmount,
            $transferredCredits,
            $transferredCreditAmount,
            $subscriptionAddOnHandle,
            $addOnHandle,
            $subscriptionDiscountHandle,
            $discountHandle,
            $couponHandle
        );
        return $response;
    }

    /**
     * Operation getSubscriptionListWithHttpInfo
     *
     * Get list of subscriptions
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $nextPageToken Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60;, &#x60;activated&#x60;, &#x60;expired&#x60;, &#x60;cancelled&#x60;, &#x60;on_hold&#x60; or &#x60;reactivated&#x60; (optional, default to created)
     * @param string $handle Subscription handle prefix (optional)
     * @param string $handleContains Subscription handle contains (optional)
     * @param string $customer Customer owning subscription (optional)
     * @param string $plan Plan owning subscription (optional)
     * @param string[] $state Subscription state, multiple can be defined. States: &#x60;active&#x60;, &#x60;expired&#x60;, &#x60;on_hold&#x60; or &#x60;pending&#x60; (optional)
     * @param string $amount Custom amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $quantity Quantity. See documentation of intervals. (optional)
     * @param string $activated Activated date interval (optional)
     * @param string $cancelledDate Cancelled date interval (optional)
     * @param string $reactivated Reactivated date interval (optional)
     * @param  string $created Created date interval (optional)
     * @param  string $renewing Renewing flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  int $planVersion Plan version (optional)
     * @param  string $amountInclVat Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $startDate Start date interval (optional)
     * @param  string $endDate End date interval (optional)
     * @param  string $graceDuration Grace duration in seconds. See documentation of intervals. (optional)
     * @param  string $currentPeriodStart Current period start date interval (optional)
     * @param  string $nextPeriodStart Next period start date interval (optional)
     * @param  string $firstPeriodStart First period start date interval (optional)
     * @param  string $lastPeriodStart Last period start date interval (optional)
     * @param  string $trialStart Trial period start date interval (optional)
     * @param  string $trialEnd Trial period end date interval (optional)
     * @param  string $inTrial In trial flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $hasStarted Has started flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $renewalCount Renewal Count. See documentation of intervals. (optional)
     * @param  string $expiredDate Expired period date interval (optional)
     * @param  string[] $expireReason On hold reason, multiple can be defined. Types: &#x60;dunning&#x60;, &#x60;cancelled&#x60;,&#x60;ondemand&#x60;, and &#x60;fixed&#x60; (optional)
     * @param  string $onHoldDate On hold period date interval (optional)
     * @param  string[] $onHoldReason On hold reason, multiple can be defined. Types: &#x60;ondemand&#x60;, and &#x60;dunning&#x60; (optional)
     * @param  string $paymentMethodAdded Payment method added flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $reminderEmailSent Reminder email sent period date interval (optional)
     * @param  string $failedInvoices Failed invoices. See documentation of intervals. (optional)
     * @param  string $failedAmount Failed amount. See documentation of intervals. (optional)
     * @param  string $cancelledInvoices Cancelled invoices. See documentation of intervals. (optional)
     * @param  string $cancelledAmount Cancelled amount. See documentation of intervals. (optional)
     * @param  string $pendingInvoices Pending invoices. See documentation of intervals. (optional)
     * @param  string $pendingAmount Pending amount invoices. See documentation of intervals. (optional)
     * @param  string $dunningInvoices Dunning invoices. See documentation of intervals. (optional)
     * @param  string $dunningAmount Dunning amount. See documentation of intervals. (optional)
     * @param  string $settledInvoices Settled invoices. See documentation of intervals. (optional)
     * @param  string $settledAmount Settled amount. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount. See documentation of intervals. (optional)
     * @param  string $pendingAdditionalCosts Pending additional costs. See documentation of intervals. (optional)
     * @param string $pendingAdditionalCostAmount Pending additional cost amount. See documentation of intervals. (optional)
     * @param string $transferredAdditionalCosts Transferred additional costs. See documentation of intervals. (optional)
     * @param string $transferredAdditionalCostAmount Transferred additional cost amount. See documentation of intervals. (optional)
     * @param string $pendingCredits Pending credits. See documentation of intervals. (optional)
     * @param string $pendingCreditAmount Pending credit amount. See documentation of intervals. (optional)
     * @param string $transferredCredits Transferred credits. See documentation of intervals. (optional)
     * @param string $transferredCreditAmount Transferred credit amount. See documentation of intervals. (optional)
     * @param string $subscriptionAddOnHandle Subscription add-on handle (optional)
     * @param string $addOnHandle Add-on handle (optional)
     * @param string $subscriptionDiscountHandle Subscription discount handle (optional)
     * @param string $discountHandle Discount handle (optional)
     * @param string $couponHandle Coupon handle (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\SubscriptionList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSubscriptionListWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $nextPageToken = null,
        $range = 'created',
        $handle = null,
        $handleContains = null,
        $customer = null,
        $plan = null,
        $state = null,
        $amount = null,
        $quantity = null,
        $activated = null,
        $cancelledDate = null,
        $reactivated = null,
        $created = null,
        $renewing = null,
        $planVersion = null,
        $amountInclVat = null,
        $startDate = null,
        $endDate = null,
        $graceDuration = null,
        $currentPeriodStart = null,
        $nextPeriodStart = null,
        $firstPeriodStart = null,
        $lastPeriodStart = null,
        $trialStart = null,
        $trialEnd = null,
        $inTrial = null,
        $hasStarted = null,
        $renewalCount = null,
        $expiredDate = null,
        $expireReason = null,
        $onHoldDate = null,
        $onHoldReason = null,
        $paymentMethodAdded = null,
        $reminderEmailSent = null,
        $failedInvoices = null,
        $failedAmount = null,
        $cancelledInvoices = null,
        $cancelledAmount = null,
        $pendingInvoices = null,
        $pendingAmount = null,
        $dunningInvoices = null,
        $dunningAmount = null,
        $settledInvoices = null,
        $settledAmount = null,
        $refundedAmount = null,
        $pendingAdditionalCosts = null,
        $pendingAdditionalCostAmount = null,
        $transferredAdditionalCosts = null,
        $transferredAdditionalCostAmount = null,
        $pendingCredits = null,
        $pendingCreditAmount = null,
        $transferredCredits = null,
        $transferredCreditAmount = null,
        $subscriptionAddOnHandle = null,
        $addOnHandle = null,
        $subscriptionDiscountHandle = null,
        $discountHandle = null,
        $couponHandle = null
    ) {
        $returnType = '\Reepay\Model\SubscriptionList';
        $request = $this->getSubscriptionListRequest(
            $from,
            $to,
            $interval,
            $size,
            $nextPageToken,
            $range,
            $handle,
            $handleContains,
            $customer,
            $plan,
            $state,
            $amount,
            $quantity,
            $activated,
            $cancelledDate,
            $reactivated,
            $created,
            $renewing,
            $planVersion,
            $amountInclVat,
            $startDate,
            $endDate,
            $graceDuration,
            $currentPeriodStart,
            $nextPeriodStart,
            $firstPeriodStart,
            $lastPeriodStart,
            $trialStart,
            $trialEnd,
            $inTrial,
            $hasStarted,
            $renewalCount,
            $expiredDate,
            $expireReason,
            $onHoldDate,
            $onHoldReason,
            $paymentMethodAdded,
            $reminderEmailSent,
            $failedInvoices,
            $failedAmount,
            $cancelledInvoices,
            $cancelledAmount,
            $pendingInvoices,
            $pendingAmount,
            $dunningInvoices,
            $dunningAmount,
            $settledInvoices,
            $settledAmount,
            $refundedAmount,
            $pendingAdditionalCosts,
            $pendingAdditionalCostAmount,
            $transferredAdditionalCosts,
            $transferredAdditionalCostAmount,
            $pendingCredits,
            $pendingCreditAmount,
            $transferredCredits,
            $transferredCreditAmount,
            $subscriptionAddOnHandle,
            $addOnHandle,
            $subscriptionDiscountHandle,
            $discountHandle,
            $couponHandle
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\SubscriptionList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSubscriptionListAsync
     *
     * Get list of subscriptions
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $nextPageToken Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60;, &#x60;activated&#x60;, &#x60;expired&#x60;, &#x60;cancelled&#x60;, &#x60;on_hold&#x60; or &#x60;reactivated&#x60; (optional, default to created)
     * @param string $handle Subscription handle prefix (optional)
     * @param string $handleContains Subscription handle contains (optional)
     * @param string $customer Customer owning subscription (optional)
     * @param string $plan Plan owning subscription (optional)
     * @param string[] $state Subscription state, multiple can be defined. States: &#x60;active&#x60;, &#x60;expired&#x60;, &#x60;on_hold&#x60; or &#x60;pending&#x60; (optional)
     * @param string $amount Custom amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $quantity Quantity. See documentation of intervals. (optional)
     * @param string $activated Activated date interval (optional)
     * @param string $cancelledDate Cancelled date interval (optional)
     * @param string $reactivated Reactivated date interval (optional)
     * @param  string $created Created date interval (optional)
     * @param  string $renewing Renewing flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  int $planVersion Plan version (optional)
     * @param  string $amountInclVat Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $startDate Start date interval (optional)
     * @param  string $endDate End date interval (optional)
     * @param  string $graceDuration Grace duration in seconds. See documentation of intervals. (optional)
     * @param  string $currentPeriodStart Current period start date interval (optional)
     * @param  string $nextPeriodStart Next period start date interval (optional)
     * @param  string $firstPeriodStart First period start date interval (optional)
     * @param  string $lastPeriodStart Last period start date interval (optional)
     * @param  string $trialStart Trial period start date interval (optional)
     * @param  string $trialEnd Trial period end date interval (optional)
     * @param  string $inTrial In trial flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $hasStarted Has started flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $renewalCount Renewal Count. See documentation of intervals. (optional)
     * @param  string $expiredDate Expired period date interval (optional)
     * @param  string[] $expireReason On hold reason, multiple can be defined. Types: &#x60;dunning&#x60;, &#x60;cancelled&#x60;,&#x60;ondemand&#x60;, and &#x60;fixed&#x60; (optional)
     * @param  string $onHoldDate On hold period date interval (optional)
     * @param  string[] $onHoldReason On hold reason, multiple can be defined. Types: &#x60;ondemand&#x60;, and &#x60;dunning&#x60; (optional)
     * @param  string $paymentMethodAdded Payment method added flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $reminderEmailSent Reminder email sent period date interval (optional)
     * @param  string $failedInvoices Failed invoices. See documentation of intervals. (optional)
     * @param  string $failedAmount Failed amount. See documentation of intervals. (optional)
     * @param  string $cancelledInvoices Cancelled invoices. See documentation of intervals. (optional)
     * @param  string $cancelledAmount Cancelled amount. See documentation of intervals. (optional)
     * @param  string $pendingInvoices Pending invoices. See documentation of intervals. (optional)
     * @param  string $pendingAmount Pending amount invoices. See documentation of intervals. (optional)
     * @param  string $dunningInvoices Dunning invoices. See documentation of intervals. (optional)
     * @param  string $dunningAmount Dunning amount. See documentation of intervals. (optional)
     * @param  string $settledInvoices Settled invoices. See documentation of intervals. (optional)
     * @param  string $settledAmount Settled amount. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount. See documentation of intervals. (optional)
     * @param  string $pendingAdditionalCosts Pending additional costs. See documentation of intervals. (optional)
     * @param string $pendingAdditionalCostAmount Pending additional cost amount. See documentation of intervals. (optional)
     * @param string $transferredAdditionalCosts Transferred additional costs. See documentation of intervals. (optional)
     * @param string $transferredAdditionalCostAmount Transferred additional cost amount. See documentation of intervals. (optional)
     * @param string $pendingCredits Pending credits. See documentation of intervals. (optional)
     * @param string $pendingCreditAmount Pending credit amount. See documentation of intervals. (optional)
     * @param string $transferredCredits Transferred credits. See documentation of intervals. (optional)
     * @param string $transferredCreditAmount Transferred credit amount. See documentation of intervals. (optional)
     * @param string $subscriptionAddOnHandle Subscription add-on handle (optional)
     * @param string $addOnHandle Add-on handle (optional)
     * @param string $subscriptionDiscountHandle Subscription discount handle (optional)
     * @param string $discountHandle Discount handle (optional)
     * @param string $couponHandle Coupon handle (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubscriptionListAsync(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $nextPageToken = null,
        $range = 'created',
        $handle = null,
        $handleContains = null,
        $customer = null,
        $plan = null,
        $state = null,
        $amount = null,
        $quantity = null,
        $activated = null,
        $cancelledDate = null,
        $reactivated = null,
        $created = null,
        $renewing = null,
        $planVersion = null,
        $amountInclVat = null,
        $startDate = null,
        $endDate = null,
        $graceDuration = null,
        $currentPeriodStart = null,
        $nextPeriodStart = null,
        $firstPeriodStart = null,
        $lastPeriodStart = null,
        $trialStart = null,
        $trialEnd = null,
        $inTrial = null,
        $hasStarted = null,
        $renewalCount = null,
        $expiredDate = null,
        $expireReason = null,
        $onHoldDate = null,
        $onHoldReason = null,
        $paymentMethodAdded = null,
        $reminderEmailSent = null,
        $failedInvoices = null,
        $failedAmount = null,
        $cancelledInvoices = null,
        $cancelledAmount = null,
        $pendingInvoices = null,
        $pendingAmount = null,
        $dunningInvoices = null,
        $dunningAmount = null,
        $settledInvoices = null,
        $settledAmount = null,
        $refundedAmount = null,
        $pendingAdditionalCosts = null,
        $pendingAdditionalCostAmount = null,
        $transferredAdditionalCosts = null,
        $transferredAdditionalCostAmount = null,
        $pendingCredits = null,
        $pendingCreditAmount = null,
        $transferredCredits = null,
        $transferredCreditAmount = null,
        $subscriptionAddOnHandle = null,
        $addOnHandle = null,
        $subscriptionDiscountHandle = null,
        $discountHandle = null,
        $couponHandle = null
    ) {
        return $this->getSubscriptionListAsyncWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $nextPageToken,
            $range,
            $handle,
            $handleContains,
            $customer,
            $plan,
            $state,
            $amount,
            $quantity,
            $activated,
            $cancelledDate,
            $reactivated,
            $created,
            $renewing,
            $planVersion,
            $amountInclVat,
            $startDate,
            $endDate,
            $graceDuration,
            $currentPeriodStart,
            $nextPeriodStart,
            $firstPeriodStart,
            $lastPeriodStart,
            $trialStart,
            $trialEnd,
            $inTrial,
            $hasStarted,
            $renewalCount,
            $expiredDate,
            $expireReason,
            $onHoldDate,
            $onHoldReason,
            $paymentMethodAdded,
            $reminderEmailSent,
            $failedInvoices,
            $failedAmount,
            $cancelledInvoices,
            $cancelledAmount,
            $pendingInvoices,
            $pendingAmount,
            $dunningInvoices,
            $dunningAmount,
            $settledInvoices,
            $settledAmount,
            $refundedAmount,
            $pendingAdditionalCosts,
            $pendingAdditionalCostAmount,
            $transferredAdditionalCosts,
            $transferredAdditionalCostAmount,
            $pendingCredits,
            $pendingCreditAmount,
            $transferredCredits,
            $transferredCreditAmount,
            $subscriptionAddOnHandle,
            $addOnHandle,
            $subscriptionDiscountHandle,
            $discountHandle,
            $couponHandle
        )
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSubscriptionListAsyncWithHttpInfo
     *
     * Get list of subscriptions
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $nextPageToken Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60;, &#x60;activated&#x60;, &#x60;expired&#x60;, &#x60;cancelled&#x60;, &#x60;on_hold&#x60; or &#x60;reactivated&#x60; (optional, default to created)
     * @param string $handle Subscription handle prefix (optional)
     * @param string $handleContains Subscription handle contains (optional)
     * @param string $customer Customer owning subscription (optional)
     * @param string $plan Plan owning subscription (optional)
     * @param string[] $state Subscription state, multiple can be defined. States: &#x60;active&#x60;, &#x60;expired&#x60;, &#x60;on_hold&#x60; or &#x60;pending&#x60; (optional)
     * @param string $amount Custom amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $quantity Quantity. See documentation of intervals. (optional)
     * @param string $activated Activated date interval (optional)
     * @param string $cancelledDate Cancelled date interval (optional)
     * @param string $reactivated Reactivated date interval (optional)
     * @param  string $created Created date interval (optional)
     * @param  string $renewing Renewing flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  int $planVersion Plan version (optional)
     * @param  string $amountInclVat Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $startDate Start date interval (optional)
     * @param  string $endDate End date interval (optional)
     * @param  string $graceDuration Grace duration in seconds. See documentation of intervals. (optional)
     * @param  string $currentPeriodStart Current period start date interval (optional)
     * @param  string $nextPeriodStart Next period start date interval (optional)
     * @param  string $firstPeriodStart First period start date interval (optional)
     * @param  string $lastPeriodStart Last period start date interval (optional)
     * @param  string $trialStart Trial period start date interval (optional)
     * @param  string $trialEnd Trial period end date interval (optional)
     * @param  string $inTrial In trial flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $hasStarted Has started flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $renewalCount Renewal Count. See documentation of intervals. (optional)
     * @param  string $expiredDate Expired period date interval (optional)
     * @param  string[] $expireReason On hold reason, multiple can be defined. Types: &#x60;dunning&#x60;, &#x60;cancelled&#x60;,&#x60;ondemand&#x60;, and &#x60;fixed&#x60; (optional)
     * @param  string $onHoldDate On hold period date interval (optional)
     * @param  string[] $onHoldReason On hold reason, multiple can be defined. Types: &#x60;ondemand&#x60;, and &#x60;dunning&#x60; (optional)
     * @param  string $paymentMethodAdded Payment method added flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $reminderEmailSent Reminder email sent period date interval (optional)
     * @param  string $failedInvoices Failed invoices. See documentation of intervals. (optional)
     * @param  string $failedAmount Failed amount. See documentation of intervals. (optional)
     * @param  string $cancelledInvoices Cancelled invoices. See documentation of intervals. (optional)
     * @param  string $cancelledAmount Cancelled amount. See documentation of intervals. (optional)
     * @param  string $pendingInvoices Pending invoices. See documentation of intervals. (optional)
     * @param  string $pendingAmount Pending amount invoices. See documentation of intervals. (optional)
     * @param  string $dunningInvoices Dunning invoices. See documentation of intervals. (optional)
     * @param  string $dunningAmount Dunning amount. See documentation of intervals. (optional)
     * @param  string $settledInvoices Settled invoices. See documentation of intervals. (optional)
     * @param  string $settledAmount Settled amount. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount. See documentation of intervals. (optional)
     * @param  string $pendingAdditionalCosts Pending additional costs. See documentation of intervals. (optional)
     * @param string $pendingAdditionalCostAmount Pending additional cost amount. See documentation of intervals. (optional)
     * @param string $transferredAdditionalCosts Transferred additional costs. See documentation of intervals. (optional)
     * @param string $transferredAdditionalCostAmount Transferred additional cost amount. See documentation of intervals. (optional)
     * @param string $pendingCredits Pending credits. See documentation of intervals. (optional)
     * @param string $pendingCreditAmount Pending credit amount. See documentation of intervals. (optional)
     * @param string $transferredCredits Transferred credits. See documentation of intervals. (optional)
     * @param string $transferredCreditAmount Transferred credit amount. See documentation of intervals. (optional)
     * @param string $subscriptionAddOnHandle Subscription add-on handle (optional)
     * @param string $addOnHandle Add-on handle (optional)
     * @param string $subscriptionDiscountHandle Subscription discount handle (optional)
     * @param string $discountHandle Discount handle (optional)
     * @param string $couponHandle Coupon handle (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubscriptionListAsyncWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $nextPageToken = null,
        $range = 'created',
        $handle = null,
        $handleContains = null,
        $customer = null,
        $plan = null,
        $state = null,
        $amount = null,
        $quantity = null,
        $activated = null,
        $cancelledDate = null,
        $reactivated = null,
        $created = null,
        $renewing = null,
        $planVersion = null,
        $amountInclVat = null,
        $startDate = null,
        $endDate = null,
        $graceDuration = null,
        $currentPeriodStart = null,
        $nextPeriodStart = null,
        $firstPeriodStart = null,
        $lastPeriodStart = null,
        $trialStart = null,
        $trialEnd = null,
        $inTrial = null,
        $hasStarted = null,
        $renewalCount = null,
        $expiredDate = null,
        $expireReason = null,
        $onHoldDate = null,
        $onHoldReason = null,
        $paymentMethodAdded = null,
        $reminderEmailSent = null,
        $failedInvoices = null,
        $failedAmount = null,
        $cancelledInvoices = null,
        $cancelledAmount = null,
        $pendingInvoices = null,
        $pendingAmount = null,
        $dunningInvoices = null,
        $dunningAmount = null,
        $settledInvoices = null,
        $settledAmount = null,
        $refundedAmount = null,
        $pendingAdditionalCosts = null,
        $pendingAdditionalCostAmount = null,
        $transferredAdditionalCosts = null,
        $transferredAdditionalCostAmount = null,
        $pendingCredits = null,
        $pendingCreditAmount = null,
        $transferredCredits = null,
        $transferredCreditAmount = null,
        $subscriptionAddOnHandle = null,
        $addOnHandle = null,
        $subscriptionDiscountHandle = null,
        $discountHandle = null,
        $couponHandle = null
    ) {
        $returnType = '\Reepay\Model\SubscriptionList';
        $request = $this->getSubscriptionListRequest(
            $from,
            $to,
            $interval,
            $size,
            $nextPageToken,
            $range,
            $handle,
            $handleContains,
            $customer,
            $plan,
            $state,
            $amount,
            $quantity,
            $activated,
            $cancelledDate,
            $reactivated,
            $created,
            $renewing,
            $planVersion,
            $amountInclVat,
            $startDate,
            $endDate,
            $graceDuration,
            $currentPeriodStart,
            $nextPeriodStart,
            $firstPeriodStart,
            $lastPeriodStart,
            $trialStart,
            $trialEnd,
            $inTrial,
            $hasStarted,
            $renewalCount,
            $expiredDate,
            $expireReason,
            $onHoldDate,
            $onHoldReason,
            $paymentMethodAdded,
            $reminderEmailSent,
            $failedInvoices,
            $failedAmount,
            $cancelledInvoices,
            $cancelledAmount,
            $pendingInvoices,
            $pendingAmount,
            $dunningInvoices,
            $dunningAmount,
            $settledInvoices,
            $settledAmount,
            $refundedAmount,
            $pendingAdditionalCosts,
            $pendingAdditionalCostAmount,
            $transferredAdditionalCosts,
            $transferredAdditionalCostAmount,
            $pendingCredits,
            $pendingCreditAmount,
            $transferredCredits,
            $transferredCreditAmount,
            $subscriptionAddOnHandle,
            $addOnHandle,
            $subscriptionDiscountHandle,
            $discountHandle,
            $couponHandle
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSubscriptionList'
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $nextPageToken Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60;, &#x60;activated&#x60;, &#x60;expired&#x60;, &#x60;cancelled&#x60;, &#x60;on_hold&#x60; or &#x60;reactivated&#x60; (optional, default to created)
     * @param string $handle Subscription handle prefix (optional)
     * @param string $handleContains Subscription handle contains (optional)
     * @param string $customer Customer owning subscription (optional)
     * @param string $plan Plan owning subscription (optional)
     * @param string[] $state Subscription state, multiple can be defined. States: &#x60;active&#x60;, &#x60;expired&#x60;, &#x60;on_hold&#x60; or &#x60;pending&#x60; (optional)
     * @param string $amount Custom amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $quantity Quantity. See documentation of intervals. (optional)
     * @param string $activated Activated date interval (optional)
     * @param string $cancelledDate Cancelled date interval (optional)
     * @param string $reactivated Reactivated date interval (optional)
     * @param  string $created Created date interval (optional)
     * @param  string $renewing Renewing flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  int $planVersion Plan version (optional)
     * @param  string $amountInclVat Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $startDate Start date interval (optional)
     * @param  string $endDate End date interval (optional)
     * @param  string $graceDuration Grace duration in seconds. See documentation of intervals. (optional)
     * @param  string $currentPeriodStart Current period start date interval (optional)
     * @param  string $nextPeriodStart Next period start date interval (optional)
     * @param  string $firstPeriodStart First period start date interval (optional)
     * @param  string $lastPeriodStart Last period start date interval (optional)
     * @param  string $trialStart Trial period start date interval (optional)
     * @param  string $trialEnd Trial period end date interval (optional)
     * @param  string $inTrial In trial flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $hasStarted Has started flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $renewalCount Renewal Count. See documentation of intervals. (optional)
     * @param  string $expiredDate Expired period date interval (optional)
     * @param  string[] $expireReason On hold reason, multiple can be defined. Types: &#x60;dunning&#x60;, &#x60;cancelled&#x60;,&#x60;ondemand&#x60;, and &#x60;fixed&#x60; (optional)
     * @param  string $onHoldDate On hold period date interval (optional)
     * @param  string[] $onHoldReason On hold reason, multiple can be defined. Types: &#x60;ondemand&#x60;, and &#x60;dunning&#x60; (optional)
     * @param  string $paymentMethodAdded Payment method added flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param  string $reminderEmailSent Reminder email sent period date interval (optional)
     * @param  string $failedInvoices Failed invoices. See documentation of intervals. (optional)
     * @param  string $failedAmount Failed amount. See documentation of intervals. (optional)
     * @param  string $cancelledInvoices Cancelled invoices. See documentation of intervals. (optional)
     * @param  string $cancelledAmount Cancelled amount. See documentation of intervals. (optional)
     * @param  string $pendingInvoices Pending invoices. See documentation of intervals. (optional)
     * @param  string $pendingAmount Pending amount invoices. See documentation of intervals. (optional)
     * @param  string $dunningInvoices Dunning invoices. See documentation of intervals. (optional)
     * @param  string $dunningAmount Dunning amount. See documentation of intervals. (optional)
     * @param  string $settledInvoices Settled invoices. See documentation of intervals. (optional)
     * @param  string $settledAmount Settled amount. See documentation of intervals. (optional)
     * @param  string $refundedAmount Refunded amount. See documentation of intervals. (optional)
     * @param  string $pendingAdditionalCosts Pending additional costs. See documentation of intervals. (optional)
     * @param string $pendingAdditionalCostAmount Pending additional cost amount. See documentation of intervals. (optional)
     * @param string $transferredAdditionalCosts Transferred additional costs. See documentation of intervals. (optional)
     * @param string $transferredAdditionalCostAmount Transferred additional cost amount. See documentation of intervals. (optional)
     * @param string $pendingCredits Pending credits. See documentation of intervals. (optional)
     * @param string $pendingCreditAmount Pending credit amount. See documentation of intervals. (optional)
     * @param string $transferredCredits Transferred credits. See documentation of intervals. (optional)
     * @param string $transferredCreditAmount Transferred credit amount. See documentation of intervals. (optional)
     * @param string $subscriptionAddOnHandle Subscription add-on handle (optional)
     * @param string $addOnHandle Add-on handle (optional)
     * @param string $subscriptionDiscountHandle Subscription discount handle (optional)
     * @param string $discountHandle Discount handle (optional)
     * @param string $couponHandle Coupon handle (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSubscriptionListRequest(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $nextPageToken = null,
        $range = 'created',
        $handle = null,
        $handleContains = null,
        $customer = null,
        $plan = null,
        $state = null,
        $amount = null,
        $quantity = null,
        $activated = null,
        $cancelledDate = null,
        $reactivated = null,
        $created = null,
        $renewing = null,
        $planVersion = null,
        $amountInclVat = null,
        $startDate = null,
        $endDate = null,
        $graceDuration = null,
        $currentPeriodStart = null,
        $nextPeriodStart = null,
        $firstPeriodStart = null,
        $lastPeriodStart = null,
        $trialStart = null,
        $trialEnd = null,
        $inTrial = null,
        $hasStarted = null,
        $renewalCount = null,
        $expiredDate = null,
        $expireReason = null,
        $onHoldDate = null,
        $onHoldReason = null,
        $paymentMethodAdded = null,
        $reminderEmailSent = null,
        $failedInvoices = null,
        $failedAmount = null,
        $cancelledInvoices = null,
        $cancelledAmount = null,
        $pendingInvoices = null,
        $pendingAmount = null,
        $dunningInvoices = null,
        $dunningAmount = null,
        $settledInvoices = null,
        $settledAmount = null,
        $refundedAmount = null,
        $pendingAdditionalCosts = null,
        $pendingAdditionalCostAmount = null,
        $transferredAdditionalCosts = null,
        $transferredAdditionalCostAmount = null,
        $pendingCredits = null,
        $pendingCreditAmount = null,
        $transferredCredits = null,
        $transferredCreditAmount = null,
        $subscriptionAddOnHandle = null,
        $addOnHandle = null,
        $subscriptionDiscountHandle = null,
        $discountHandle = null,
        $couponHandle = null
    ) {
        $resourcePath = '/v1/list/subscription';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($nextPageToken !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($nextPageToken, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($handleContains !== null) {
            $queryParams['handle_contains'] = ObjectSerializer::toQueryValue($handleContains, null);
        }
        // query params
        if ($customer !== null) {
            $queryParams['customer'] = ObjectSerializer::toQueryValue($customer, null);
        }
        // query params
        if ($plan !== null) {
            $queryParams['plan'] = ObjectSerializer::toQueryValue($plan, null);
        }
        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, 'multi', true);
        }
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if ($quantity !== null) {
            $queryParams['quantity'] = ObjectSerializer::toQueryValue($quantity, null);
        }
        // query params
        if ($activated !== null) {
            $queryParams['activated'] = ObjectSerializer::toQueryValue($activated, null);
        }
        // query params
        if ($cancelledDate !== null) {
            $queryParams['cancelled_date'] = ObjectSerializer::toQueryValue($cancelledDate, null);
        }
        // query params
        if ($reactivated !== null) {
            $queryParams['reactivated'] = ObjectSerializer::toQueryValue($reactivated, null);
        }
        // query params
        if ($created !== null) {
            $queryParams['created'] = ObjectSerializer::toQueryValue($created, null);
        }
        // query params
        if ($renewing !== null) {
            $queryParams['renewing'] = ObjectSerializer::toQueryValue($renewing, null);
        }
        // query params
        if ($planVersion !== null) {
            $queryParams['plan_version'] = ObjectSerializer::toQueryValue($planVersion, 'int32');
        }
        // query params
        if ($amountInclVat !== null) {
            $queryParams['amount_incl_vat'] = ObjectSerializer::toQueryValue($amountInclVat, null);
        }
        // query params
        if ($startDate !== null) {
            $queryParams['start_date'] = ObjectSerializer::toQueryValue($startDate, null);
        }
        // query params
        if ($endDate !== null) {
            $queryParams['end_date'] = ObjectSerializer::toQueryValue($endDate, null);
        }
        // query params
        if ($graceDuration !== null) {
            $queryParams['grace_duration'] = ObjectSerializer::toQueryValue($graceDuration, null);
        }
        // query params
        if ($currentPeriodStart !== null) {
            $queryParams['current_period_start'] = ObjectSerializer::toQueryValue($currentPeriodStart, null);
        }
        // query params
        if ($nextPeriodStart !== null) {
            $queryParams['next_period_start'] = ObjectSerializer::toQueryValue($nextPeriodStart, null);
        }
        // query params
        if ($firstPeriodStart !== null) {
            $queryParams['first_period_start'] = ObjectSerializer::toQueryValue($firstPeriodStart, null);
        }
        // query params
        if ($lastPeriodStart !== null) {
            $queryParams['last_period_start'] = ObjectSerializer::toQueryValue($lastPeriodStart, null);
        }
        // query params
        if ($trialStart !== null) {
            $queryParams['trial_start'] = ObjectSerializer::toQueryValue($trialStart, null);
        }
        // query params
        if ($trialEnd !== null) {
            $queryParams['trial_end'] = ObjectSerializer::toQueryValue($trialEnd, null);
        }
        // query params
        if ($inTrial !== null) {
            $queryParams['in_trial'] = ObjectSerializer::toQueryValue($inTrial, null);
        }
        // query params
        if ($hasStarted !== null) {
            $queryParams['has_started'] = ObjectSerializer::toQueryValue($hasStarted, null);
        }
        // query params
        if ($renewalCount !== null) {
            $queryParams['renewal_count'] = ObjectSerializer::toQueryValue($renewalCount, null);
        }
        // query params
        if ($expiredDate !== null) {
            $queryParams['expired_date'] = ObjectSerializer::toQueryValue($expiredDate, null);
        }
        // query params
        if (is_array($expireReason)) {
            $expireReason = ObjectSerializer::serializeCollection($expireReason, 'multi', true);
        }
        if ($expireReason !== null) {
            $queryParams['expire_reason'] = ObjectSerializer::toQueryValue($expireReason, null);
        }
        // query params
        if ($onHoldDate !== null) {
            $queryParams['on_hold_date'] = ObjectSerializer::toQueryValue($onHoldDate, null);
        }
        // query params
        if (is_array($onHoldReason)) {
            $onHoldReason = ObjectSerializer::serializeCollection($onHoldReason, 'multi', true);
        }
        if ($onHoldReason !== null) {
            $queryParams['on_hold_reason'] = ObjectSerializer::toQueryValue($onHoldReason, null);
        }
        // query params
        if ($paymentMethodAdded !== null) {
            $queryParams['payment_method_added'] = ObjectSerializer::toQueryValue($paymentMethodAdded, null);
        }
        // query params
        if ($reminderEmailSent !== null) {
            $queryParams['reminder_email_sent'] = ObjectSerializer::toQueryValue($reminderEmailSent, null);
        }
        // query params
        if ($failedInvoices !== null) {
            $queryParams['failed_invoices'] = ObjectSerializer::toQueryValue($failedInvoices, null);
        }
        // query params
        if ($failedAmount !== null) {
            $queryParams['failed_amount'] = ObjectSerializer::toQueryValue($failedAmount, null);
        }
        // query params
        if ($cancelledInvoices !== null) {
            $queryParams['cancelled_invoices'] = ObjectSerializer::toQueryValue($cancelledInvoices, null);
        }
        // query params
        if ($cancelledAmount !== null) {
            $queryParams['cancelled_amount'] = ObjectSerializer::toQueryValue($cancelledAmount, null);
        }
        // query params
        if ($pendingInvoices !== null) {
            $queryParams['pending_invoices'] = ObjectSerializer::toQueryValue($pendingInvoices, null);
        }
        // query params
        if ($pendingAmount !== null) {
            $queryParams['pending_amount'] = ObjectSerializer::toQueryValue($pendingAmount, null);
        }
        // query params
        if ($dunningInvoices !== null) {
            $queryParams['dunning_invoices'] = ObjectSerializer::toQueryValue($dunningInvoices, null);
        }
        // query params
        if ($dunningAmount !== null) {
            $queryParams['dunning_amount'] = ObjectSerializer::toQueryValue($dunningAmount, null);
        }
        // query params
        if ($settledInvoices !== null) {
            $queryParams['settled_invoices'] = ObjectSerializer::toQueryValue($settledInvoices, null);
        }
        // query params
        if ($settledAmount !== null) {
            $queryParams['settled_amount'] = ObjectSerializer::toQueryValue($settledAmount, null);
        }
        // query params
        if ($refundedAmount !== null) {
            $queryParams['refunded_amount'] = ObjectSerializer::toQueryValue($refundedAmount, null);
        }
        // query params
        if ($pendingAdditionalCosts !== null) {
            $queryParams['pending_additional_costs'] = ObjectSerializer::toQueryValue($pendingAdditionalCosts, null);
        }
        // query params
        if ($pendingAdditionalCostAmount !== null) {
            $queryParams['pending_additional_cost_amount'] = ObjectSerializer::toQueryValue(
                $pendingAdditionalCostAmount,
                null
            );
        }
        // query params
        if ($transferredAdditionalCosts !== null) {
            $queryParams['transferred_additional_costs'] = ObjectSerializer::toQueryValue(
                $transferredAdditionalCosts,
                null
            );
        }
        // query params
        if ($transferredAdditionalCostAmount !== null) {
            $queryParams['transferred_additional_cost_amount'] = ObjectSerializer::toQueryValue(
                $transferredAdditionalCostAmount,
                null
            );
        }
        // query params
        if ($pendingCredits !== null) {
            $queryParams['pending_credits'] = ObjectSerializer::toQueryValue($pendingCredits, null);
        }
        // query params
        if ($pendingCreditAmount !== null) {
            $queryParams['pending_credit_amount'] = ObjectSerializer::toQueryValue($pendingCreditAmount, null);
        }
        // query params
        if ($transferredCredits !== null) {
            $queryParams['transferred_credits'] = ObjectSerializer::toQueryValue($transferredCredits, null);
        }
        // query params
        if ($transferredCreditAmount !== null) {
            $queryParams['transferred_credit_amount'] = ObjectSerializer::toQueryValue($transferredCreditAmount, null);
        }
        // query params
        if ($subscriptionAddOnHandle !== null) {
            $queryParams['subscription_add_on_handle'] = ObjectSerializer::toQueryValue($subscriptionAddOnHandle, null);
        }
        // query params
        if ($addOnHandle !== null) {
            $queryParams['add_on_handle'] = ObjectSerializer::toQueryValue($addOnHandle, null);
        }
        // query params
        if ($subscriptionDiscountHandle !== null) {
            $queryParams['subscription_discount_handle'] = ObjectSerializer::toQueryValue(
                $subscriptionDiscountHandle,
                null
            );
        }
        // query params
        if ($discountHandle !== null) {
            $queryParams['discount_handle'] = ObjectSerializer::toQueryValue($discountHandle, null);
        }
        // query params
        if ($couponHandle !== null) {
            $queryParams['coupon_handle'] = ObjectSerializer::toQueryValue($couponHandle, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransactionList
     *
     * Get list of transactions
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60;, &#x60;settled&#x60;, &#x60;authorized&#x60;, &#x60;refunded&#x60; or &#x60;failed&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string[] $type Transaction type, multiple can be defined. Types: &#x60;settle&#x60;, &#x60;refund&#x60; and &#x60;authorization&#x60; (optional)
     * @param  string[] $state Transaction state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;authorized&#x60;, &#x60;processing&#x60;, &#x60;settled&#x60;, &#x60;refunded&#x60;, &#x60;failed&#x60; and &#x60;cancelled&#x60; (optional)
     * @param  string[] $paymentType Transaction payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param  string $invoice Transactions for invoice by invoice handle (optional)
     * @param  string[] $currency Currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $cardType Transactions for card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string[] $transactionCardType Transactions with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string $cardPrefix Transactions for card with prefix (optional)
     * @param  string $cardPostfix Transactions for card with postfix (optional)
     * @param  string $cardFingerprint Transactions for card with postfix (optional)
     * @param  string[] $cardCountry Transactions with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param  string $cardGateway Transactions with card gateway. (optional)
     * @param  string $paymentMethod Transactions using saved payment method (optional)
     * @param  string $cardAcquirerCode Transaction using card acquirer code (optional)
     * @param  string $cardErrorState Transactions with card error state. &#x60;pending&#x60;, &#x60;accepted&#x60;, &#x60;soft_declined&#x60;, &#x60;hard_declined&#x60;, or &#x60;processing_error&#x60; (optional)
     * @param  string $cardError Transactions with card error state. &#x60;credit_card_expired&#x60;, &#x60;insufficient_funds&#x60;, &#x60;declined_by_acquirer&#x60;, &#x60;acquirer_communication_error&#x60;, &#x60;acquirer_error&#x60;, &#x60;acquirer_integration_error&#x60;, &#x60;acquirer_authentication_error&#x60;, &#x60;acquirer_configuration_error&#x60;, &#x60;acquirer_rejected_error&#x60;, &#x60;card_identifier_not_found&#x60;, &#x60;refund_amount_too_high&#x60;, &#x60;credit_card_lost_or_stolen&#x60;, &#x60;credit_card_suspected_fraud&#x60;, &#x60;authorization_expired&#x60;, &#x60;authorization_amount_exceeded&#x60;, &#x60;authorization_voided&#x60;, &#x60;settle_blocked&#x60;, &#x60;sca_required&#x60;, &#x60;risk_filter_block&#x60;, or &#x60;fraud_block&#x60; (optional)
     * @param  string $paymentContext Transaction payment context: cit - customer initiated, cit-cof customer initiated using stored information or mit - merchant initiated (optional)
     * @param  string $cardAcquirerReference Transaction with card acquirer reference (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\TransactionList
     */
    public function getTransactionList($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $type = null, $state = null, $paymentType = null, $invoice = null, $currency = null, $amount = null, $cardType = null, $transactionCardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null, $cardCountry = null, $cardGateway = null, $paymentMethod = null, $cardAcquirerCode = null, $cardErrorState = null, $cardError = null, $paymentContext = null, $cardAcquirerReference = null)
    {
        list($response) = $this->getTransactionListWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $type, $state, $paymentType, $invoice, $currency, $amount, $cardType, $transactionCardType, $cardPrefix, $cardPostfix, $cardFingerprint, $cardCountry, $cardGateway, $paymentMethod, $cardAcquirerCode, $cardErrorState, $cardError, $paymentContext, $cardAcquirerReference);
        return $response;
    }

    /**
     * Operation getTransactionListWithHttpInfo
     *
     * Get list of transactions
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60;, &#x60;settled&#x60;, &#x60;authorized&#x60;, &#x60;refunded&#x60; or &#x60;failed&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string[] $type Transaction type, multiple can be defined. Types: &#x60;settle&#x60;, &#x60;refund&#x60; and &#x60;authorization&#x60; (optional)
     * @param  string[] $state Transaction state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;authorized&#x60;, &#x60;processing&#x60;, &#x60;settled&#x60;, &#x60;refunded&#x60;, &#x60;failed&#x60; and &#x60;cancelled&#x60; (optional)
     * @param  string[] $paymentType Transaction payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param  string $invoice Transactions for invoice by invoice handle (optional)
     * @param  string[] $currency Currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $cardType Transactions for card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string[] $transactionCardType Transactions with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string $cardPrefix Transactions for card with prefix (optional)
     * @param  string $cardPostfix Transactions for card with postfix (optional)
     * @param  string $cardFingerprint Transactions for card with postfix (optional)
     * @param  string[] $cardCountry Transactions with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param  string $cardGateway Transactions with card gateway. (optional)
     * @param  string $paymentMethod Transactions using saved payment method (optional)
     * @param  string $cardAcquirerCode Transaction using card acquirer code (optional)
     * @param  string $cardErrorState Transactions with card error state. &#x60;pending&#x60;, &#x60;accepted&#x60;, &#x60;soft_declined&#x60;, &#x60;hard_declined&#x60;, or &#x60;processing_error&#x60; (optional)
     * @param  string $cardError Transactions with card error state. &#x60;credit_card_expired&#x60;, &#x60;insufficient_funds&#x60;, &#x60;declined_by_acquirer&#x60;, &#x60;acquirer_communication_error&#x60;, &#x60;acquirer_error&#x60;, &#x60;acquirer_integration_error&#x60;, &#x60;acquirer_authentication_error&#x60;, &#x60;acquirer_configuration_error&#x60;, &#x60;acquirer_rejected_error&#x60;, &#x60;card_identifier_not_found&#x60;, &#x60;refund_amount_too_high&#x60;, &#x60;credit_card_lost_or_stolen&#x60;, &#x60;credit_card_suspected_fraud&#x60;, &#x60;authorization_expired&#x60;, &#x60;authorization_amount_exceeded&#x60;, &#x60;authorization_voided&#x60;, &#x60;settle_blocked&#x60;, &#x60;sca_required&#x60;, &#x60;risk_filter_block&#x60;, or &#x60;fraud_block&#x60; (optional)
     * @param  string $paymentContext Transaction payment context: cit - customer initiated, cit-cof customer initiated using stored information or mit - merchant initiated (optional)
     * @param  string $cardAcquirerReference Transaction with card acquirer reference (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\TransactionList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransactionListWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $type = null, $state = null, $paymentType = null, $invoice = null, $currency = null, $amount = null, $cardType = null, $transactionCardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null, $cardCountry = null, $cardGateway = null, $paymentMethod = null, $cardAcquirerCode = null, $cardErrorState = null, $cardError = null, $paymentContext = null, $cardAcquirerReference = null)
    {
        $returnType = '\Reepay\Model\TransactionList';
        $request = $this->getTransactionListRequest($from, $to, $interval, $size, $nextPageToken, $range, $type, $state, $paymentType, $invoice, $currency, $amount, $cardType, $transactionCardType, $cardPrefix, $cardPostfix, $cardFingerprint, $cardCountry, $cardGateway, $paymentMethod, $cardAcquirerCode, $cardErrorState, $cardError, $paymentContext, $cardAcquirerReference);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\TransactionList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTransactionListAsync
     *
     * Get list of transactions
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60;, &#x60;settled&#x60;, &#x60;authorized&#x60;, &#x60;refunded&#x60; or &#x60;failed&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string[] $type Transaction type, multiple can be defined. Types: &#x60;settle&#x60;, &#x60;refund&#x60; and &#x60;authorization&#x60; (optional)
     * @param  string[] $state Transaction state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;authorized&#x60;, &#x60;processing&#x60;, &#x60;settled&#x60;, &#x60;refunded&#x60;, &#x60;failed&#x60; and &#x60;cancelled&#x60; (optional)
     * @param  string[] $paymentType Transaction payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param  string $invoice Transactions for invoice by invoice handle (optional)
     * @param  string[] $currency Currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $cardType Transactions for card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string[] $transactionCardType Transactions with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string $cardPrefix Transactions for card with prefix (optional)
     * @param  string $cardPostfix Transactions for card with postfix (optional)
     * @param  string $cardFingerprint Transactions for card with postfix (optional)
     * @param  string[] $cardCountry Transactions with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param  string $cardGateway Transactions with card gateway. (optional)
     * @param  string $paymentMethod Transactions using saved payment method (optional)
     * @param  string $cardAcquirerCode Transaction using card acquirer code (optional)
     * @param  string $cardErrorState Transactions with card error state. &#x60;pending&#x60;, &#x60;accepted&#x60;, &#x60;soft_declined&#x60;, &#x60;hard_declined&#x60;, or &#x60;processing_error&#x60; (optional)
     * @param  string $cardError Transactions with card error state. &#x60;credit_card_expired&#x60;, &#x60;insufficient_funds&#x60;, &#x60;declined_by_acquirer&#x60;, &#x60;acquirer_communication_error&#x60;, &#x60;acquirer_error&#x60;, &#x60;acquirer_integration_error&#x60;, &#x60;acquirer_authentication_error&#x60;, &#x60;acquirer_configuration_error&#x60;, &#x60;acquirer_rejected_error&#x60;, &#x60;card_identifier_not_found&#x60;, &#x60;refund_amount_too_high&#x60;, &#x60;credit_card_lost_or_stolen&#x60;, &#x60;credit_card_suspected_fraud&#x60;, &#x60;authorization_expired&#x60;, &#x60;authorization_amount_exceeded&#x60;, &#x60;authorization_voided&#x60;, &#x60;settle_blocked&#x60;, &#x60;sca_required&#x60;, &#x60;risk_filter_block&#x60;, or &#x60;fraud_block&#x60; (optional)
     * @param  string $paymentContext Transaction payment context: cit - customer initiated, cit-cof customer initiated using stored information or mit - merchant initiated (optional)
     * @param  string $cardAcquirerReference Transaction with card acquirer reference (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionListAsync($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $type = null, $state = null, $paymentType = null, $invoice = null, $currency = null, $amount = null, $cardType = null, $transactionCardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null, $cardCountry = null, $cardGateway = null, $paymentMethod = null, $cardAcquirerCode = null, $cardErrorState = null, $cardError = null, $paymentContext = null, $cardAcquirerReference = null)
    {
        return $this->getTransactionListAsyncWithHttpInfo($from, $to, $interval, $size, $nextPageToken, $range, $type, $state, $paymentType, $invoice, $currency, $amount, $cardType, $transactionCardType, $cardPrefix, $cardPostfix, $cardFingerprint, $cardCountry, $cardGateway, $paymentMethod, $cardAcquirerCode, $cardErrorState, $cardError, $paymentContext, $cardAcquirerReference)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransactionListAsyncWithHttpInfo
     *
     * Get list of transactions
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60;, &#x60;settled&#x60;, &#x60;authorized&#x60;, &#x60;refunded&#x60; or &#x60;failed&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string[] $type Transaction type, multiple can be defined. Types: &#x60;settle&#x60;, &#x60;refund&#x60; and &#x60;authorization&#x60; (optional)
     * @param  string[] $state Transaction state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;authorized&#x60;, &#x60;processing&#x60;, &#x60;settled&#x60;, &#x60;refunded&#x60;, &#x60;failed&#x60; and &#x60;cancelled&#x60; (optional)
     * @param  string[] $paymentType Transaction payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param  string $invoice Transactions for invoice by invoice handle (optional)
     * @param  string[] $currency Currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $cardType Transactions for card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string[] $transactionCardType Transactions with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string $cardPrefix Transactions for card with prefix (optional)
     * @param  string $cardPostfix Transactions for card with postfix (optional)
     * @param  string $cardFingerprint Transactions for card with postfix (optional)
     * @param  string[] $cardCountry Transactions with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param  string $cardGateway Transactions with card gateway. (optional)
     * @param  string $paymentMethod Transactions using saved payment method (optional)
     * @param  string $cardAcquirerCode Transaction using card acquirer code (optional)
     * @param  string $cardErrorState Transactions with card error state. &#x60;pending&#x60;, &#x60;accepted&#x60;, &#x60;soft_declined&#x60;, &#x60;hard_declined&#x60;, or &#x60;processing_error&#x60; (optional)
     * @param  string $cardError Transactions with card error state. &#x60;credit_card_expired&#x60;, &#x60;insufficient_funds&#x60;, &#x60;declined_by_acquirer&#x60;, &#x60;acquirer_communication_error&#x60;, &#x60;acquirer_error&#x60;, &#x60;acquirer_integration_error&#x60;, &#x60;acquirer_authentication_error&#x60;, &#x60;acquirer_configuration_error&#x60;, &#x60;acquirer_rejected_error&#x60;, &#x60;card_identifier_not_found&#x60;, &#x60;refund_amount_too_high&#x60;, &#x60;credit_card_lost_or_stolen&#x60;, &#x60;credit_card_suspected_fraud&#x60;, &#x60;authorization_expired&#x60;, &#x60;authorization_amount_exceeded&#x60;, &#x60;authorization_voided&#x60;, &#x60;settle_blocked&#x60;, &#x60;sca_required&#x60;, &#x60;risk_filter_block&#x60;, or &#x60;fraud_block&#x60; (optional)
     * @param  string $paymentContext Transaction payment context: cit - customer initiated, cit-cof customer initiated using stored information or mit - merchant initiated (optional)
     * @param  string $cardAcquirerReference Transaction with card acquirer reference (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionListAsyncWithHttpInfo($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $type = null, $state = null, $paymentType = null, $invoice = null, $currency = null, $amount = null, $cardType = null, $transactionCardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null, $cardCountry = null, $cardGateway = null, $paymentMethod = null, $cardAcquirerCode = null, $cardErrorState = null, $cardError = null, $paymentContext = null, $cardAcquirerReference = null)
    {
        $returnType = '\Reepay\Model\TransactionList';
        $request = $this->getTransactionListRequest($from, $to, $interval, $size, $nextPageToken, $range, $type, $state, $paymentType, $invoice, $currency, $amount, $cardType, $transactionCardType, $cardPrefix, $cardPostfix, $cardFingerprint, $cardCountry, $cardGateway, $paymentMethod, $cardAcquirerCode, $cardErrorState, $cardError, $paymentContext, $cardAcquirerReference);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransactionList'
     *
     * @param  string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param  string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param  string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param  int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param  string $nextPageToken Next page token from previous response to get next page (optional)
     * @param  string $range Time and date attribute to time limit. Either &#x60;created&#x60;, &#x60;settled&#x60;, &#x60;authorized&#x60;, &#x60;refunded&#x60; or &#x60;failed&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param  string[] $type Transaction type, multiple can be defined. Types: &#x60;settle&#x60;, &#x60;refund&#x60; and &#x60;authorization&#x60; (optional)
     * @param  string[] $state Transaction state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;authorized&#x60;, &#x60;processing&#x60;, &#x60;settled&#x60;, &#x60;refunded&#x60;, &#x60;failed&#x60; and &#x60;cancelled&#x60; (optional)
     * @param  string[] $paymentType Transaction payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param  string $invoice Transactions for invoice by invoice handle (optional)
     * @param  string[] $currency Currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param  string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param  string[] $cardType Transactions for card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string[] $transactionCardType Transactions with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param  string $cardPrefix Transactions for card with prefix (optional)
     * @param  string $cardPostfix Transactions for card with postfix (optional)
     * @param  string $cardFingerprint Transactions for card with postfix (optional)
     * @param  string[] $cardCountry Transactions with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param  string $cardGateway Transactions with card gateway. (optional)
     * @param  string $paymentMethod Transactions using saved payment method (optional)
     * @param  string $cardAcquirerCode Transaction using card acquirer code (optional)
     * @param  string $cardErrorState Transactions with card error state. &#x60;pending&#x60;, &#x60;accepted&#x60;, &#x60;soft_declined&#x60;, &#x60;hard_declined&#x60;, or &#x60;processing_error&#x60; (optional)
     * @param  string $cardError Transactions with card error state. &#x60;credit_card_expired&#x60;, &#x60;insufficient_funds&#x60;, &#x60;declined_by_acquirer&#x60;, &#x60;acquirer_communication_error&#x60;, &#x60;acquirer_error&#x60;, &#x60;acquirer_integration_error&#x60;, &#x60;acquirer_authentication_error&#x60;, &#x60;acquirer_configuration_error&#x60;, &#x60;acquirer_rejected_error&#x60;, &#x60;card_identifier_not_found&#x60;, &#x60;refund_amount_too_high&#x60;, &#x60;credit_card_lost_or_stolen&#x60;, &#x60;credit_card_suspected_fraud&#x60;, &#x60;authorization_expired&#x60;, &#x60;authorization_amount_exceeded&#x60;, &#x60;authorization_voided&#x60;, &#x60;settle_blocked&#x60;, &#x60;sca_required&#x60;, &#x60;risk_filter_block&#x60;, or &#x60;fraud_block&#x60; (optional)
     * @param  string $paymentContext Transaction payment context: cit - customer initiated, cit-cof customer initiated using stored information or mit - merchant initiated (optional)
     * @param  string $cardAcquirerReference Transaction with card acquirer reference (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTransactionListRequest($from = null, $to = null, $interval = null, $size = '20', $nextPageToken = null, $range = 'created', $type = null, $state = null, $paymentType = null, $invoice = null, $currency = null, $amount = null, $cardType = null, $transactionCardType = null, $cardPrefix = null, $cardPostfix = null, $cardFingerprint = null, $cardCountry = null, $cardGateway = null, $paymentMethod = null, $cardAcquirerCode = null, $cardErrorState = null, $cardError = null, $paymentContext = null, $cardAcquirerReference = null)
    {

        $resourcePath = '/v1/list/transaction';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($nextPageToken !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($nextPageToken, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, 'multi', true);
        }
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, 'multi', true);
        }
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if (is_array($paymentType)) {
            $paymentType = ObjectSerializer::serializeCollection($paymentType, 'multi', true);
        }
        if ($paymentType !== null) {
            $queryParams['payment_type'] = ObjectSerializer::toQueryValue($paymentType, null);
        }
        // query params
        if ($invoice !== null) {
            $queryParams['invoice'] = ObjectSerializer::toQueryValue($invoice, null);
        }
        // query params
        if (is_array($currency)) {
            $currency = ObjectSerializer::serializeCollection($currency, 'multi', true);
        }
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if (is_array($cardType)) {
            $cardType = ObjectSerializer::serializeCollection($cardType, 'multi', true);
        }
        if ($cardType !== null) {
            $queryParams['card_type'] = ObjectSerializer::toQueryValue($cardType, null);
        }
        // query params
        if (is_array($transactionCardType)) {
            $transactionCardType = ObjectSerializer::serializeCollection($transactionCardType, 'multi', true);
        }
        if ($transactionCardType !== null) {
            $queryParams['transaction_card_type'] = ObjectSerializer::toQueryValue($transactionCardType, null);
        }
        // query params
        if ($cardPrefix !== null) {
            $queryParams['card_prefix'] = ObjectSerializer::toQueryValue($cardPrefix, null);
        }
        // query params
        if ($cardPostfix !== null) {
            $queryParams['card_postfix'] = ObjectSerializer::toQueryValue($cardPostfix, null);
        }
        // query params
        if ($cardFingerprint !== null) {
            $queryParams['card_fingerprint'] = ObjectSerializer::toQueryValue($cardFingerprint, null);
        }
        // query params
        if (is_array($cardCountry)) {
            $cardCountry = ObjectSerializer::serializeCollection($cardCountry, 'multi', true);
        }
        if ($cardCountry !== null) {
            $queryParams['card_country'] = ObjectSerializer::toQueryValue($cardCountry, null);
        }
        // query params
        if ($cardGateway !== null) {
            $queryParams['card_gateway'] = ObjectSerializer::toQueryValue($cardGateway, null);
        }
        // query params
        if ($paymentMethod !== null) {
            $queryParams['payment_method'] = ObjectSerializer::toQueryValue($paymentMethod, null);
        }
        // query params
        if ($cardAcquirerCode !== null) {
            $queryParams['card_acquirer_code'] = ObjectSerializer::toQueryValue($cardAcquirerCode, null);
        }
        // query params
        if ($cardErrorState !== null) {
            $queryParams['card_error_state'] = ObjectSerializer::toQueryValue($cardErrorState, null);
        }
        // query params
        if ($cardError !== null) {
            $queryParams['card_error'] = ObjectSerializer::toQueryValue($cardError, null);
        }
        // query params
        if ($paymentContext !== null) {
            $queryParams['payment_context'] = ObjectSerializer::toQueryValue($paymentContext, null);
        }
        // query params
        if ($cardAcquirerReference !== null) {
            $queryParams['card_acquirer_reference'] = ObjectSerializer::toQueryValue($cardAcquirerReference, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
