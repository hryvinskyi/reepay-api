<?php
/**
 * ListApi
 * PHP version 5
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * API
 *
 * REST API to manage Reepay resources
 *
 * OpenAPI spec version: 1
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.41
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Reepay\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Reepay\ApiException;
use Reepay\Configuration;
use Reepay\HeaderSelector;
use Reepay\ObjectSerializer;

/**
 * ListApi Class Doc Comment
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ListApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getAddOnList
     *
     * Get list of add-ons
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param string $handle Add-on handle prefix (optional)
     * @param string $state Add-on state. Accepted values &#x60;active&#x60; or &#x60;deleted&#x60; (optional, default to active)
     * @param string $type Type of add-on. Accepted values: &#x60;on_off&#x60; or &#x60;quantity&#x60;. An on_off type cannot be given a quantity when attached to subscription. For quantity type it is possible.&#x60; (optional)
     * @param string $name Name of add-on. Used as order line text. (optional)
     * @param string $description Optional description of add-on (optional)
     * @param string $amount Add-on amount interval. See documentation of intervals. (optional)
     * @param string $amount_incl_vat Amount incl vat flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $all_plans Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\AddOnList
     */
    public function getAddOnList(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = 'active',
        $type = null,
        $name = null,
        $description = null,
        $amount = null,
        $amount_incl_vat = null,
        $all_plans = null
    ) {
        list($response) = $this->getAddOnListWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $state,
            $type,
            $name,
            $description,
            $amount,
            $amount_incl_vat,
            $all_plans
        );
        return $response;
    }

    /**
     * Operation getAddOnListWithHttpInfo
     *
     * Get list of add-ons
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param string $handle Add-on handle prefix (optional)
     * @param string $state Add-on state. Accepted values &#x60;active&#x60; or &#x60;deleted&#x60; (optional, default to active)
     * @param string $type Type of add-on. Accepted values: &#x60;on_off&#x60; or &#x60;quantity&#x60;. An on_off type cannot be given a quantity when attached to subscription. For quantity type it is possible.&#x60; (optional)
     * @param string $name Name of add-on. Used as order line text. (optional)
     * @param string $description Optional description of add-on (optional)
     * @param string $amount Add-on amount interval. See documentation of intervals. (optional)
     * @param string $amount_incl_vat Amount incl vat flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $all_plans Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\AddOnList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAddOnListWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = 'active',
        $type = null,
        $name = null,
        $description = null,
        $amount = null,
        $amount_incl_vat = null,
        $all_plans = null
    ) {
        $returnType = '\Reepay\Model\AddOnList';
        $request = $this->getAddOnListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $state,
            $type,
            $name,
            $description,
            $amount,
            $amount_incl_vat,
            $all_plans
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\AddOnList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAddOnListAsync
     *
     * Get list of add-ons
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param string $handle Add-on handle prefix (optional)
     * @param string $state Add-on state. Accepted values &#x60;active&#x60; or &#x60;deleted&#x60; (optional, default to active)
     * @param string $type Type of add-on. Accepted values: &#x60;on_off&#x60; or &#x60;quantity&#x60;. An on_off type cannot be given a quantity when attached to subscription. For quantity type it is possible.&#x60; (optional)
     * @param string $name Name of add-on. Used as order line text. (optional)
     * @param string $description Optional description of add-on (optional)
     * @param string $amount Add-on amount interval. See documentation of intervals. (optional)
     * @param string $amount_incl_vat Amount incl vat flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $all_plans Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAddOnListAsync(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = 'active',
        $type = null,
        $name = null,
        $description = null,
        $amount = null,
        $amount_incl_vat = null,
        $all_plans = null
    ) {
        return $this->getAddOnListAsyncWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $state,
            $type,
            $name,
            $description,
            $amount,
            $amount_incl_vat,
            $all_plans
        )
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAddOnListAsyncWithHttpInfo
     *
     * Get list of add-ons
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param string $handle Add-on handle prefix (optional)
     * @param string $state Add-on state. Accepted values &#x60;active&#x60; or &#x60;deleted&#x60; (optional, default to active)
     * @param string $type Type of add-on. Accepted values: &#x60;on_off&#x60; or &#x60;quantity&#x60;. An on_off type cannot be given a quantity when attached to subscription. For quantity type it is possible.&#x60; (optional)
     * @param string $name Name of add-on. Used as order line text. (optional)
     * @param string $description Optional description of add-on (optional)
     * @param string $amount Add-on amount interval. See documentation of intervals. (optional)
     * @param string $amount_incl_vat Amount incl vat flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $all_plans Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAddOnListAsyncWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = 'active',
        $type = null,
        $name = null,
        $description = null,
        $amount = null,
        $amount_incl_vat = null,
        $all_plans = null
    ) {
        $returnType = '\Reepay\Model\AddOnList';
        $request = $this->getAddOnListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $state,
            $type,
            $name,
            $description,
            $amount,
            $amount_incl_vat,
            $all_plans
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAddOnList'
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param string $handle Add-on handle prefix (optional)
     * @param string $state Add-on state. Accepted values &#x60;active&#x60; or &#x60;deleted&#x60; (optional, default to active)
     * @param string $type Type of add-on. Accepted values: &#x60;on_off&#x60; or &#x60;quantity&#x60;. An on_off type cannot be given a quantity when attached to subscription. For quantity type it is possible.&#x60; (optional)
     * @param string $name Name of add-on. Used as order line text. (optional)
     * @param string $description Optional description of add-on (optional)
     * @param string $amount Add-on amount interval. See documentation of intervals. (optional)
     * @param string $amount_incl_vat Amount incl vat flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $all_plans Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAddOnListRequest(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = 'active',
        $type = null,
        $name = null,
        $description = null,
        $amount = null,
        $amount_incl_vat = null,
        $all_plans = null
    ) {
        $resourcePath = '/v1/list/add_on';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($next_page_token !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($next_page_token, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if ($amount_incl_vat !== null) {
            $queryParams['amount_incl_vat'] = ObjectSerializer::toQueryValue($amount_incl_vat, null);
        }
        // query params
        if ($all_plans !== null) {
            $queryParams['all_plans'] = ObjectSerializer::toQueryValue($all_plans, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChargeList
     *
     * Get list of charges
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Invoice handle prefix (optional)
     * @param string $handle_contains Invoice handle contains (optional)
     * @param string[] $state Invoice state, multiple can be defined (optional)
     * @param string[] $exclude_state Invoice state to exclude, multiple can be defined (optional)
     * @param string $customer Invoices for customer by customer handle (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $authorized_amount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param bool $partial_settled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\ChargeList
     */
    public function getChargeList(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $state = null,
        $exclude_state = null,
        $customer = null,
        $amount = null,
        $refunded_amount = null,
        $authorized_amount = null,
        $currency = null,
        $partial_settled = null
    ) {
        list($response) = $this->getChargeListWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $state,
            $exclude_state,
            $customer,
            $amount,
            $refunded_amount,
            $authorized_amount,
            $currency,
            $partial_settled
        );
        return $response;
    }

    /**
     * Operation getChargeListWithHttpInfo
     *
     * Get list of charges
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Invoice handle prefix (optional)
     * @param string $handle_contains Invoice handle contains (optional)
     * @param string[] $state Invoice state, multiple can be defined (optional)
     * @param string[] $exclude_state Invoice state to exclude, multiple can be defined (optional)
     * @param string $customer Invoices for customer by customer handle (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $authorized_amount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param bool $partial_settled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\ChargeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChargeListWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $state = null,
        $exclude_state = null,
        $customer = null,
        $amount = null,
        $refunded_amount = null,
        $authorized_amount = null,
        $currency = null,
        $partial_settled = null
    ) {
        $returnType = '\Reepay\Model\ChargeList';
        $request = $this->getChargeListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $state,
            $exclude_state,
            $customer,
            $amount,
            $refunded_amount,
            $authorized_amount,
            $currency,
            $partial_settled
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ChargeList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getChargeListAsync
     *
     * Get list of charges
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Invoice handle prefix (optional)
     * @param string $handle_contains Invoice handle contains (optional)
     * @param string[] $state Invoice state, multiple can be defined (optional)
     * @param string[] $exclude_state Invoice state to exclude, multiple can be defined (optional)
     * @param string $customer Invoices for customer by customer handle (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $authorized_amount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param bool $partial_settled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChargeListAsync(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $state = null,
        $exclude_state = null,
        $customer = null,
        $amount = null,
        $refunded_amount = null,
        $authorized_amount = null,
        $currency = null,
        $partial_settled = null
    ) {
        return $this->getChargeListAsyncWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $state,
            $exclude_state,
            $customer,
            $amount,
            $refunded_amount,
            $authorized_amount,
            $currency,
            $partial_settled
        )
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChargeListAsyncWithHttpInfo
     *
     * Get list of charges
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Invoice handle prefix (optional)
     * @param string $handle_contains Invoice handle contains (optional)
     * @param string[] $state Invoice state, multiple can be defined (optional)
     * @param string[] $exclude_state Invoice state to exclude, multiple can be defined (optional)
     * @param string $customer Invoices for customer by customer handle (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $authorized_amount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param bool $partial_settled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChargeListAsyncWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $state = null,
        $exclude_state = null,
        $customer = null,
        $amount = null,
        $refunded_amount = null,
        $authorized_amount = null,
        $currency = null,
        $partial_settled = null
    ) {
        $returnType = '\Reepay\Model\ChargeList';
        $request = $this->getChargeListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $state,
            $exclude_state,
            $customer,
            $amount,
            $refunded_amount,
            $authorized_amount,
            $currency,
            $partial_settled
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChargeList'
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Invoice handle prefix (optional)
     * @param string $handle_contains Invoice handle contains (optional)
     * @param string[] $state Invoice state, multiple can be defined (optional)
     * @param string[] $exclude_state Invoice state to exclude, multiple can be defined (optional)
     * @param string $customer Invoices for customer by customer handle (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $authorized_amount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param bool $partial_settled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getChargeListRequest(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $state = null,
        $exclude_state = null,
        $customer = null,
        $amount = null,
        $refunded_amount = null,
        $authorized_amount = null,
        $currency = null,
        $partial_settled = null
    ) {
        $resourcePath = '/v1/list/charge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($next_page_token !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($next_page_token, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($handle_contains !== null) {
            $queryParams['handle_contains'] = ObjectSerializer::toQueryValue($handle_contains, null);
        }
        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, 'multi', true);
        }
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if (is_array($exclude_state)) {
            $exclude_state = ObjectSerializer::serializeCollection($exclude_state, 'multi', true);
        }
        if ($exclude_state !== null) {
            $queryParams['exclude_state'] = ObjectSerializer::toQueryValue($exclude_state, null);
        }
        // query params
        if ($customer !== null) {
            $queryParams['customer'] = ObjectSerializer::toQueryValue($customer, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if ($refunded_amount !== null) {
            $queryParams['refunded_amount'] = ObjectSerializer::toQueryValue($refunded_amount, null);
        }
        // query params
        if ($authorized_amount !== null) {
            $queryParams['authorized_amount'] = ObjectSerializer::toQueryValue($authorized_amount, null);
        }
        // query params
        if (is_array($currency)) {
            $currency = ObjectSerializer::serializeCollection($currency, 'multi', true);
        }
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency, null);
        }
        // query params
        if ($partial_settled !== null) {
            $queryParams['partial_settled'] = ObjectSerializer::toQueryValue($partial_settled, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCouponList
     *
     * Get list of coupons
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60; or &#x60;expired&#x60; (optional, default to created)
     * @param string $handle Coupon handle prefix (optional)
     * @param string $type Type of coupon. Accepted values: &#x60;single&#x60; or &#x60;set&#x60; (optional)
     * @param string[] $expire_reason The expire reason if expired, multiple can be defined. Possible values: &#x60;early&#x60;, &#x60;valid_until&#x60; or &#x60;max&#x60; (optional)
     * @param string $discount_handle Handle of discount to use for coupon (optional)
     * @param string $code The coupon code. Maximum 128 characters. (optional)
     * @param string $name Internal name for the coupon. (optional)
     * @param string $all_plans Whether all plans are eligible for this coupon. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $max_redemptions Optional maximum number of times this coupon can be redeemed. (optional)
     * @param string $redemptions Number of times the coupon has been redeemed. (optional)
     * @param string $valid_until Valid-until period date interval (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\CouponList
     */
    public function getCouponList(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $type = null,
        $expire_reason = null,
        $discount_handle = null,
        $code = null,
        $name = null,
        $all_plans = null,
        $max_redemptions = null,
        $redemptions = null,
        $valid_until = null
    ) {
        list($response) = $this->getCouponListWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $type,
            $expire_reason,
            $discount_handle,
            $code,
            $name,
            $all_plans,
            $max_redemptions,
            $redemptions,
            $valid_until
        );
        return $response;
    }

    /**
     * Operation getCouponListWithHttpInfo
     *
     * Get list of coupons
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60; or &#x60;expired&#x60; (optional, default to created)
     * @param string $handle Coupon handle prefix (optional)
     * @param string $type Type of coupon. Accepted values: &#x60;single&#x60; or &#x60;set&#x60; (optional)
     * @param string[] $expire_reason The expire reason if expired, multiple can be defined. Possible values: &#x60;early&#x60;, &#x60;valid_until&#x60; or &#x60;max&#x60; (optional)
     * @param string $discount_handle Handle of discount to use for coupon (optional)
     * @param string $code The coupon code. Maximum 128 characters. (optional)
     * @param string $name Internal name for the coupon. (optional)
     * @param string $all_plans Whether all plans are eligible for this coupon. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $max_redemptions Optional maximum number of times this coupon can be redeemed. (optional)
     * @param string $redemptions Number of times the coupon has been redeemed. (optional)
     * @param string $valid_until Valid-until period date interval (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\CouponList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCouponListWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $type = null,
        $expire_reason = null,
        $discount_handle = null,
        $code = null,
        $name = null,
        $all_plans = null,
        $max_redemptions = null,
        $redemptions = null,
        $valid_until = null
    ) {
        $returnType = '\Reepay\Model\CouponList';
        $request = $this->getCouponListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $type,
            $expire_reason,
            $discount_handle,
            $code,
            $name,
            $all_plans,
            $max_redemptions,
            $redemptions,
            $valid_until
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\CouponList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCouponListAsync
     *
     * Get list of coupons
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60; or &#x60;expired&#x60; (optional, default to created)
     * @param string $handle Coupon handle prefix (optional)
     * @param string $type Type of coupon. Accepted values: &#x60;single&#x60; or &#x60;set&#x60; (optional)
     * @param string[] $expire_reason The expire reason if expired, multiple can be defined. Possible values: &#x60;early&#x60;, &#x60;valid_until&#x60; or &#x60;max&#x60; (optional)
     * @param string $discount_handle Handle of discount to use for coupon (optional)
     * @param string $code The coupon code. Maximum 128 characters. (optional)
     * @param string $name Internal name for the coupon. (optional)
     * @param string $all_plans Whether all plans are eligible for this coupon. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $max_redemptions Optional maximum number of times this coupon can be redeemed. (optional)
     * @param string $redemptions Number of times the coupon has been redeemed. (optional)
     * @param string $valid_until Valid-until period date interval (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponListAsync(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $type = null,
        $expire_reason = null,
        $discount_handle = null,
        $code = null,
        $name = null,
        $all_plans = null,
        $max_redemptions = null,
        $redemptions = null,
        $valid_until = null
    ) {
        return $this->getCouponListAsyncWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $type,
            $expire_reason,
            $discount_handle,
            $code,
            $name,
            $all_plans,
            $max_redemptions,
            $redemptions,
            $valid_until
        )
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCouponListAsyncWithHttpInfo
     *
     * Get list of coupons
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60; or &#x60;expired&#x60; (optional, default to created)
     * @param string $handle Coupon handle prefix (optional)
     * @param string $type Type of coupon. Accepted values: &#x60;single&#x60; or &#x60;set&#x60; (optional)
     * @param string[] $expire_reason The expire reason if expired, multiple can be defined. Possible values: &#x60;early&#x60;, &#x60;valid_until&#x60; or &#x60;max&#x60; (optional)
     * @param string $discount_handle Handle of discount to use for coupon (optional)
     * @param string $code The coupon code. Maximum 128 characters. (optional)
     * @param string $name Internal name for the coupon. (optional)
     * @param string $all_plans Whether all plans are eligible for this coupon. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $max_redemptions Optional maximum number of times this coupon can be redeemed. (optional)
     * @param string $redemptions Number of times the coupon has been redeemed. (optional)
     * @param string $valid_until Valid-until period date interval (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCouponListAsyncWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $type = null,
        $expire_reason = null,
        $discount_handle = null,
        $code = null,
        $name = null,
        $all_plans = null,
        $max_redemptions = null,
        $redemptions = null,
        $valid_until = null
    ) {
        $returnType = '\Reepay\Model\CouponList';
        $request = $this->getCouponListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $type,
            $expire_reason,
            $discount_handle,
            $code,
            $name,
            $all_plans,
            $max_redemptions,
            $redemptions,
            $valid_until
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCouponList'
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60; or &#x60;expired&#x60; (optional, default to created)
     * @param string $handle Coupon handle prefix (optional)
     * @param string $type Type of coupon. Accepted values: &#x60;single&#x60; or &#x60;set&#x60; (optional)
     * @param string[] $expire_reason The expire reason if expired, multiple can be defined. Possible values: &#x60;early&#x60;, &#x60;valid_until&#x60; or &#x60;max&#x60; (optional)
     * @param string $discount_handle Handle of discount to use for coupon (optional)
     * @param string $code The coupon code. Maximum 128 characters. (optional)
     * @param string $name Internal name for the coupon. (optional)
     * @param string $all_plans Whether all plans are eligible for this coupon. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $max_redemptions Optional maximum number of times this coupon can be redeemed. (optional)
     * @param string $redemptions Number of times the coupon has been redeemed. (optional)
     * @param string $valid_until Valid-until period date interval (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCouponListRequest(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $type = null,
        $expire_reason = null,
        $discount_handle = null,
        $code = null,
        $name = null,
        $all_plans = null,
        $max_redemptions = null,
        $redemptions = null,
        $valid_until = null
    ) {
        $resourcePath = '/v1/list/coupon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($next_page_token !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($next_page_token, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if (is_array($expire_reason)) {
            $expire_reason = ObjectSerializer::serializeCollection($expire_reason, 'multi', true);
        }
        if ($expire_reason !== null) {
            $queryParams['expire_reason'] = ObjectSerializer::toQueryValue($expire_reason, null);
        }
        // query params
        if ($discount_handle !== null) {
            $queryParams['discount_handle'] = ObjectSerializer::toQueryValue($discount_handle, null);
        }
        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($all_plans !== null) {
            $queryParams['all_plans'] = ObjectSerializer::toQueryValue($all_plans, null);
        }
        // query params
        if ($max_redemptions !== null) {
            $queryParams['max_redemptions'] = ObjectSerializer::toQueryValue($max_redemptions, null);
        }
        // query params
        if ($redemptions !== null) {
            $queryParams['redemptions'] = ObjectSerializer::toQueryValue($redemptions, null);
        }
        // query params
        if ($valid_until !== null) {
            $queryParams['valid_until'] = ObjectSerializer::toQueryValue($valid_until, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomerList
     *
     * Get list of customers
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param string $handle Customer handle prefix (optional)
     * @param string $handle_contains Customer handle contains (optional)
     * @param string $name Search for name contained in first name concatenated with last name (optional)
     * @param string $email Customer email (optional)
     * @param string $email_prefix Customer email prefix (optional)
     * @param string $first_name Contained in customer first name (optional)
     * @param string $last_name Contained in customer last name (optional)
     * @param string $address Contained in customer address (optional)
     * @param string $address2 Contained in customer address2 (optional)
     * @param string $postal_code Contained in customer postal code (optional)
     * @param string $city Contained in customer city (optional)
     * @param string $country Customer country in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (optional)
     * @param string $phone Contained in customer phone (optional)
     * @param string $company Contained in customer company (optional)
     * @param string $vat Contained in customer vat code (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\CustomerList
     */
    public function getCustomerList(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $name = null,
        $email = null,
        $email_prefix = null,
        $first_name = null,
        $last_name = null,
        $address = null,
        $address2 = null,
        $postal_code = null,
        $city = null,
        $country = null,
        $phone = null,
        $company = null,
        $vat = null
    ) {
        list($response) = $this->getCustomerListWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $name,
            $email,
            $email_prefix,
            $first_name,
            $last_name,
            $address,
            $address2,
            $postal_code,
            $city,
            $country,
            $phone,
            $company,
            $vat
        );
        return $response;
    }

    /**
     * Operation getCustomerListWithHttpInfo
     *
     * Get list of customers
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param string $handle Customer handle prefix (optional)
     * @param string $handle_contains Customer handle contains (optional)
     * @param string $name Search for name contained in first name concatenated with last name (optional)
     * @param string $email Customer email (optional)
     * @param string $email_prefix Customer email prefix (optional)
     * @param string $first_name Contained in customer first name (optional)
     * @param string $last_name Contained in customer last name (optional)
     * @param string $address Contained in customer address (optional)
     * @param string $address2 Contained in customer address2 (optional)
     * @param string $postal_code Contained in customer postal code (optional)
     * @param string $city Contained in customer city (optional)
     * @param string $country Customer country in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (optional)
     * @param string $phone Contained in customer phone (optional)
     * @param string $company Contained in customer company (optional)
     * @param string $vat Contained in customer vat code (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\CustomerList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomerListWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $name = null,
        $email = null,
        $email_prefix = null,
        $first_name = null,
        $last_name = null,
        $address = null,
        $address2 = null,
        $postal_code = null,
        $city = null,
        $country = null,
        $phone = null,
        $company = null,
        $vat = null
    ) {
        $returnType = '\Reepay\Model\CustomerList';
        $request = $this->getCustomerListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $name,
            $email,
            $email_prefix,
            $first_name,
            $last_name,
            $address,
            $address2,
            $postal_code,
            $city,
            $country,
            $phone,
            $company,
            $vat
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\CustomerList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCustomerListAsync
     *
     * Get list of customers
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param string $handle Customer handle prefix (optional)
     * @param string $handle_contains Customer handle contains (optional)
     * @param string $name Search for name contained in first name concatenated with last name (optional)
     * @param string $email Customer email (optional)
     * @param string $email_prefix Customer email prefix (optional)
     * @param string $first_name Contained in customer first name (optional)
     * @param string $last_name Contained in customer last name (optional)
     * @param string $address Contained in customer address (optional)
     * @param string $address2 Contained in customer address2 (optional)
     * @param string $postal_code Contained in customer postal code (optional)
     * @param string $city Contained in customer city (optional)
     * @param string $country Customer country in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (optional)
     * @param string $phone Contained in customer phone (optional)
     * @param string $company Contained in customer company (optional)
     * @param string $vat Contained in customer vat code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerListAsync(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $name = null,
        $email = null,
        $email_prefix = null,
        $first_name = null,
        $last_name = null,
        $address = null,
        $address2 = null,
        $postal_code = null,
        $city = null,
        $country = null,
        $phone = null,
        $company = null,
        $vat = null
    ) {
        return $this->getCustomerListAsyncWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $name,
            $email,
            $email_prefix,
            $first_name,
            $last_name,
            $address,
            $address2,
            $postal_code,
            $city,
            $country,
            $phone,
            $company,
            $vat
        )
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomerListAsyncWithHttpInfo
     *
     * Get list of customers
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param string $handle Customer handle prefix (optional)
     * @param string $handle_contains Customer handle contains (optional)
     * @param string $name Search for name contained in first name concatenated with last name (optional)
     * @param string $email Customer email (optional)
     * @param string $email_prefix Customer email prefix (optional)
     * @param string $first_name Contained in customer first name (optional)
     * @param string $last_name Contained in customer last name (optional)
     * @param string $address Contained in customer address (optional)
     * @param string $address2 Contained in customer address2 (optional)
     * @param string $postal_code Contained in customer postal code (optional)
     * @param string $city Contained in customer city (optional)
     * @param string $country Customer country in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (optional)
     * @param string $phone Contained in customer phone (optional)
     * @param string $company Contained in customer company (optional)
     * @param string $vat Contained in customer vat code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerListAsyncWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $name = null,
        $email = null,
        $email_prefix = null,
        $first_name = null,
        $last_name = null,
        $address = null,
        $address2 = null,
        $postal_code = null,
        $city = null,
        $country = null,
        $phone = null,
        $company = null,
        $vat = null
    ) {
        $returnType = '\Reepay\Model\CustomerList';
        $request = $this->getCustomerListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $name,
            $email,
            $email_prefix,
            $first_name,
            $last_name,
            $address,
            $address2,
            $postal_code,
            $city,
            $country,
            $phone,
            $company,
            $vat
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomerList'
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param string $handle Customer handle prefix (optional)
     * @param string $handle_contains Customer handle contains (optional)
     * @param string $name Search for name contained in first name concatenated with last name (optional)
     * @param string $email Customer email (optional)
     * @param string $email_prefix Customer email prefix (optional)
     * @param string $first_name Contained in customer first name (optional)
     * @param string $last_name Contained in customer last name (optional)
     * @param string $address Contained in customer address (optional)
     * @param string $address2 Contained in customer address2 (optional)
     * @param string $postal_code Contained in customer postal code (optional)
     * @param string $city Contained in customer city (optional)
     * @param string $country Customer country in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (optional)
     * @param string $phone Contained in customer phone (optional)
     * @param string $company Contained in customer company (optional)
     * @param string $vat Contained in customer vat code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCustomerListRequest(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $name = null,
        $email = null,
        $email_prefix = null,
        $first_name = null,
        $last_name = null,
        $address = null,
        $address2 = null,
        $postal_code = null,
        $city = null,
        $country = null,
        $phone = null,
        $company = null,
        $vat = null
    ) {
        $resourcePath = '/v1/list/customer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($next_page_token !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($next_page_token, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($handle_contains !== null) {
            $queryParams['handle_contains'] = ObjectSerializer::toQueryValue($handle_contains, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email, null);
        }
        // query params
        if ($email_prefix !== null) {
            $queryParams['email_prefix'] = ObjectSerializer::toQueryValue($email_prefix, null);
        }
        // query params
        if ($first_name !== null) {
            $queryParams['first_name'] = ObjectSerializer::toQueryValue($first_name, null);
        }
        // query params
        if ($last_name !== null) {
            $queryParams['last_name'] = ObjectSerializer::toQueryValue($last_name, null);
        }
        // query params
        if ($address !== null) {
            $queryParams['address'] = ObjectSerializer::toQueryValue($address, null);
        }
        // query params
        if ($address2 !== null) {
            $queryParams['address2'] = ObjectSerializer::toQueryValue($address2, null);
        }
        // query params
        if ($postal_code !== null) {
            $queryParams['postal_code'] = ObjectSerializer::toQueryValue($postal_code, null);
        }
        // query params
        if ($city !== null) {
            $queryParams['city'] = ObjectSerializer::toQueryValue($city, null);
        }
        // query params
        if ($country !== null) {
            $queryParams['country'] = ObjectSerializer::toQueryValue($country, null);
        }
        // query params
        if ($phone !== null) {
            $queryParams['phone'] = ObjectSerializer::toQueryValue($phone, null);
        }
        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company, null);
        }
        // query params
        if ($vat !== null) {
            $queryParams['vat'] = ObjectSerializer::toQueryValue($vat, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDiscountList
     *
     * Get list of discounts
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute for time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param string $handle Discount handle prefix (optional)
     * @param string $state State of discount. States: &#x60;active&#x60; or &#x60;deleted&#x60; (optional)
     * @param string[] $apply_to Which order lines the discount is applicable to: &#x60;all&#x60;, &#x60;setup_fee&#x60;, &#x60;plan&#x60;, &#x60;additional_cost&#x60;, &#x60;add_on&#x60; and &#x60;ondemand&#x60;. Multiple can be defined. (optional)
     * @param string $name Name of discount. Used as order line text. (optional)
     * @param string $description Optional description of discount (optional)
     * @param string $amount Fixed amount discount deducted from order line amounts including VAT. (optional)
     * @param string $percentage Percentage discount applied to each applicable order line. (optional)
     * @param string $fixed_count Apply discount to a fixed number of invoices (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\DiscountList
     */
    public function getDiscountList(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = null,
        $apply_to = null,
        $name = null,
        $description = null,
        $amount = null,
        $percentage = null,
        $fixed_count = null
    ) {
        list($response) = $this->getDiscountListWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $state,
            $apply_to,
            $name,
            $description,
            $amount,
            $percentage,
            $fixed_count
        );
        return $response;
    }

    /**
     * Operation getDiscountListWithHttpInfo
     *
     * Get list of discounts
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute for time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param string $handle Discount handle prefix (optional)
     * @param string $state State of discount. States: &#x60;active&#x60; or &#x60;deleted&#x60; (optional)
     * @param string[] $apply_to Which order lines the discount is applicable to: &#x60;all&#x60;, &#x60;setup_fee&#x60;, &#x60;plan&#x60;, &#x60;additional_cost&#x60;, &#x60;add_on&#x60; and &#x60;ondemand&#x60;. Multiple can be defined. (optional)
     * @param string $name Name of discount. Used as order line text. (optional)
     * @param string $description Optional description of discount (optional)
     * @param string $amount Fixed amount discount deducted from order line amounts including VAT. (optional)
     * @param string $percentage Percentage discount applied to each applicable order line. (optional)
     * @param string $fixed_count Apply discount to a fixed number of invoices (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\DiscountList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDiscountListWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = null,
        $apply_to = null,
        $name = null,
        $description = null,
        $amount = null,
        $percentage = null,
        $fixed_count = null
    ) {
        $returnType = '\Reepay\Model\DiscountList';
        $request = $this->getDiscountListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $state,
            $apply_to,
            $name,
            $description,
            $amount,
            $percentage,
            $fixed_count
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\DiscountList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDiscountListAsync
     *
     * Get list of discounts
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute for time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param string $handle Discount handle prefix (optional)
     * @param string $state State of discount. States: &#x60;active&#x60; or &#x60;deleted&#x60; (optional)
     * @param string[] $apply_to Which order lines the discount is applicable to: &#x60;all&#x60;, &#x60;setup_fee&#x60;, &#x60;plan&#x60;, &#x60;additional_cost&#x60;, &#x60;add_on&#x60; and &#x60;ondemand&#x60;. Multiple can be defined. (optional)
     * @param string $name Name of discount. Used as order line text. (optional)
     * @param string $description Optional description of discount (optional)
     * @param string $amount Fixed amount discount deducted from order line amounts including VAT. (optional)
     * @param string $percentage Percentage discount applied to each applicable order line. (optional)
     * @param string $fixed_count Apply discount to a fixed number of invoices (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDiscountListAsync(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = null,
        $apply_to = null,
        $name = null,
        $description = null,
        $amount = null,
        $percentage = null,
        $fixed_count = null
    ) {
        return $this->getDiscountListAsyncWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $state,
            $apply_to,
            $name,
            $description,
            $amount,
            $percentage,
            $fixed_count
        )
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDiscountListAsyncWithHttpInfo
     *
     * Get list of discounts
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute for time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param string $handle Discount handle prefix (optional)
     * @param string $state State of discount. States: &#x60;active&#x60; or &#x60;deleted&#x60; (optional)
     * @param string[] $apply_to Which order lines the discount is applicable to: &#x60;all&#x60;, &#x60;setup_fee&#x60;, &#x60;plan&#x60;, &#x60;additional_cost&#x60;, &#x60;add_on&#x60; and &#x60;ondemand&#x60;. Multiple can be defined. (optional)
     * @param string $name Name of discount. Used as order line text. (optional)
     * @param string $description Optional description of discount (optional)
     * @param string $amount Fixed amount discount deducted from order line amounts including VAT. (optional)
     * @param string $percentage Percentage discount applied to each applicable order line. (optional)
     * @param string $fixed_count Apply discount to a fixed number of invoices (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDiscountListAsyncWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = null,
        $apply_to = null,
        $name = null,
        $description = null,
        $amount = null,
        $percentage = null,
        $fixed_count = null
    ) {
        $returnType = '\Reepay\Model\DiscountList';
        $request = $this->getDiscountListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $state,
            $apply_to,
            $name,
            $description,
            $amount,
            $percentage,
            $fixed_count
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDiscountList'
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute for time limit. Can be &#x60;created&#x60; or &#x60;deleted&#x60; (optional, default to created)
     * @param string $handle Discount handle prefix (optional)
     * @param string $state State of discount. States: &#x60;active&#x60; or &#x60;deleted&#x60; (optional)
     * @param string[] $apply_to Which order lines the discount is applicable to: &#x60;all&#x60;, &#x60;setup_fee&#x60;, &#x60;plan&#x60;, &#x60;additional_cost&#x60;, &#x60;add_on&#x60; and &#x60;ondemand&#x60;. Multiple can be defined. (optional)
     * @param string $name Name of discount. Used as order line text. (optional)
     * @param string $description Optional description of discount (optional)
     * @param string $amount Fixed amount discount deducted from order line amounts including VAT. (optional)
     * @param string $percentage Percentage discount applied to each applicable order line. (optional)
     * @param string $fixed_count Apply discount to a fixed number of invoices (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDiscountListRequest(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = null,
        $apply_to = null,
        $name = null,
        $description = null,
        $amount = null,
        $percentage = null,
        $fixed_count = null
    ) {
        $resourcePath = '/v1/list/discount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($next_page_token !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($next_page_token, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if (is_array($apply_to)) {
            $apply_to = ObjectSerializer::serializeCollection($apply_to, 'multi', true);
        }
        if ($apply_to !== null) {
            $queryParams['apply_to'] = ObjectSerializer::toQueryValue($apply_to, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if ($percentage !== null) {
            $queryParams['percentage'] = ObjectSerializer::toQueryValue($percentage, null);
        }
        // query params
        if ($fixed_count !== null) {
            $queryParams['fixed_count'] = ObjectSerializer::toQueryValue($fixed_count, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceList
     *
     * Get list of invoices
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Invoice handle prefix (optional)
     * @param string $handle_contains Invoice handle contains (optional)
     * @param string[] $state Invoice state, multiple can be defined (optional)
     * @param string[] $exclude_state Invoice state to exclude, multiple can be defined (optional)
     * @param string $customer Invoices for customer by customer handle (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $authorized_amount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param bool $partial_settled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     * @param string[] $type Invoice type, multiple can be defined. &#x60;s&#x60; - subscription recurring, &#x60;so&#x60; - subscription one-time, &#x60;soi&#x60; - subscription one-time instant, &#x60;co&#x60; - customer one-time, &#x60;ch&#x60; - charge (optional)
     * @param string $subscription Invoices for subscription by subscription handle (optional)
     * @param string $plan Invoices for subscription plan by subscription plan handle (optional)
     * @param string $dunning_start Dunning start date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param string $dunning_success Dunning success date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param int $number Invoice number if subscription invoice (optional)
     * @param string $due Due date if due date defined for subscription invoice (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\InvoiceList
     */
    public function getInvoiceList(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $state = null,
        $exclude_state = null,
        $customer = null,
        $amount = null,
        $refunded_amount = null,
        $authorized_amount = null,
        $currency = null,
        $partial_settled = null,
        $type = null,
        $subscription = null,
        $plan = null,
        $dunning_start = null,
        $dunning_success = null,
        $number = null,
        $due = null
    ) {
        list($response) = $this->getInvoiceListWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $state,
            $exclude_state,
            $customer,
            $amount,
            $refunded_amount,
            $authorized_amount,
            $currency,
            $partial_settled,
            $type,
            $subscription,
            $plan,
            $dunning_start,
            $dunning_success,
            $number,
            $due
        );
        return $response;
    }

    /**
     * Operation getInvoiceListWithHttpInfo
     *
     * Get list of invoices
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Invoice handle prefix (optional)
     * @param string $handle_contains Invoice handle contains (optional)
     * @param string[] $state Invoice state, multiple can be defined (optional)
     * @param string[] $exclude_state Invoice state to exclude, multiple can be defined (optional)
     * @param string $customer Invoices for customer by customer handle (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $authorized_amount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param bool $partial_settled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     * @param string[] $type Invoice type, multiple can be defined. &#x60;s&#x60; - subscription recurring, &#x60;so&#x60; - subscription one-time, &#x60;soi&#x60; - subscription one-time instant, &#x60;co&#x60; - customer one-time, &#x60;ch&#x60; - charge (optional)
     * @param string $subscription Invoices for subscription by subscription handle (optional)
     * @param string $plan Invoices for subscription plan by subscription plan handle (optional)
     * @param string $dunning_start Dunning start date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param string $dunning_success Dunning success date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param int $number Invoice number if subscription invoice (optional)
     * @param string $due Due date if due date defined for subscription invoice (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\InvoiceList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceListWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $state = null,
        $exclude_state = null,
        $customer = null,
        $amount = null,
        $refunded_amount = null,
        $authorized_amount = null,
        $currency = null,
        $partial_settled = null,
        $type = null,
        $subscription = null,
        $plan = null,
        $dunning_start = null,
        $dunning_success = null,
        $number = null,
        $due = null
    ) {
        $returnType = '\Reepay\Model\InvoiceList';
        $request = $this->getInvoiceListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $state,
            $exclude_state,
            $customer,
            $amount,
            $refunded_amount,
            $authorized_amount,
            $currency,
            $partial_settled,
            $type,
            $subscription,
            $plan,
            $dunning_start,
            $dunning_success,
            $number,
            $due
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\InvoiceList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceListAsync
     *
     * Get list of invoices
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Invoice handle prefix (optional)
     * @param string $handle_contains Invoice handle contains (optional)
     * @param string[] $state Invoice state, multiple can be defined (optional)
     * @param string[] $exclude_state Invoice state to exclude, multiple can be defined (optional)
     * @param string $customer Invoices for customer by customer handle (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $authorized_amount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param bool $partial_settled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     * @param string[] $type Invoice type, multiple can be defined. &#x60;s&#x60; - subscription recurring, &#x60;so&#x60; - subscription one-time, &#x60;soi&#x60; - subscription one-time instant, &#x60;co&#x60; - customer one-time, &#x60;ch&#x60; - charge (optional)
     * @param string $subscription Invoices for subscription by subscription handle (optional)
     * @param string $plan Invoices for subscription plan by subscription plan handle (optional)
     * @param string $dunning_start Dunning start date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param string $dunning_success Dunning success date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param int $number Invoice number if subscription invoice (optional)
     * @param string $due Due date if due date defined for subscription invoice (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceListAsync(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $state = null,
        $exclude_state = null,
        $customer = null,
        $amount = null,
        $refunded_amount = null,
        $authorized_amount = null,
        $currency = null,
        $partial_settled = null,
        $type = null,
        $subscription = null,
        $plan = null,
        $dunning_start = null,
        $dunning_success = null,
        $number = null,
        $due = null
    ) {
        return $this->getInvoiceListAsyncWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $state,
            $exclude_state,
            $customer,
            $amount,
            $refunded_amount,
            $authorized_amount,
            $currency,
            $partial_settled,
            $type,
            $subscription,
            $plan,
            $dunning_start,
            $dunning_success,
            $number,
            $due
        )
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceListAsyncWithHttpInfo
     *
     * Get list of invoices
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Invoice handle prefix (optional)
     * @param string $handle_contains Invoice handle contains (optional)
     * @param string[] $state Invoice state, multiple can be defined (optional)
     * @param string[] $exclude_state Invoice state to exclude, multiple can be defined (optional)
     * @param string $customer Invoices for customer by customer handle (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $authorized_amount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param bool $partial_settled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     * @param string[] $type Invoice type, multiple can be defined. &#x60;s&#x60; - subscription recurring, &#x60;so&#x60; - subscription one-time, &#x60;soi&#x60; - subscription one-time instant, &#x60;co&#x60; - customer one-time, &#x60;ch&#x60; - charge (optional)
     * @param string $subscription Invoices for subscription by subscription handle (optional)
     * @param string $plan Invoices for subscription plan by subscription plan handle (optional)
     * @param string $dunning_start Dunning start date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param string $dunning_success Dunning success date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param int $number Invoice number if subscription invoice (optional)
     * @param string $due Due date if due date defined for subscription invoice (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceListAsyncWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $state = null,
        $exclude_state = null,
        $customer = null,
        $amount = null,
        $refunded_amount = null,
        $authorized_amount = null,
        $currency = null,
        $partial_settled = null,
        $type = null,
        $subscription = null,
        $plan = null,
        $dunning_start = null,
        $dunning_success = null,
        $number = null,
        $due = null
    ) {
        $returnType = '\Reepay\Model\InvoiceList';
        $request = $this->getInvoiceListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $state,
            $exclude_state,
            $customer,
            $amount,
            $refunded_amount,
            $authorized_amount,
            $currency,
            $partial_settled,
            $type,
            $subscription,
            $plan,
            $dunning_start,
            $dunning_success,
            $number,
            $due
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceList'
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;settled&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Invoice handle prefix (optional)
     * @param string $handle_contains Invoice handle contains (optional)
     * @param string[] $state Invoice state, multiple can be defined (optional)
     * @param string[] $exclude_state Invoice state to exclude, multiple can be defined (optional)
     * @param string $customer Invoices for customer by customer handle (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $authorized_amount Authorized amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Invoice currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param bool $partial_settled Filter invoices based on partial settled. If &#x60;true&#x60; invoices where &#x60;authorized_amount &lt; settled_amount&#x60; is returned. If &#x60;false&#x60; invoices where &#x60;settled_amount &#x3D; authorized_amount&#x60; is returned. (optional)
     * @param string[] $type Invoice type, multiple can be defined. &#x60;s&#x60; - subscription recurring, &#x60;so&#x60; - subscription one-time, &#x60;soi&#x60; - subscription one-time instant, &#x60;co&#x60; - customer one-time, &#x60;ch&#x60; - charge (optional)
     * @param string $subscription Invoices for subscription by subscription handle (optional)
     * @param string $plan Invoices for subscription plan by subscription plan handle (optional)
     * @param string $dunning_start Dunning start date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param string $dunning_success Dunning success date and time in local date time interval for account timezone. Date time given in ISO-8601 local date or local date time. See documentation of intervals. (optional)
     * @param int $number Invoice number if subscription invoice (optional)
     * @param string $due Due date if due date defined for subscription invoice (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceListRequest(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $state = null,
        $exclude_state = null,
        $customer = null,
        $amount = null,
        $refunded_amount = null,
        $authorized_amount = null,
        $currency = null,
        $partial_settled = null,
        $type = null,
        $subscription = null,
        $plan = null,
        $dunning_start = null,
        $dunning_success = null,
        $number = null,
        $due = null
    ) {
        $resourcePath = '/v1/list/invoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($next_page_token !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($next_page_token, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($handle_contains !== null) {
            $queryParams['handle_contains'] = ObjectSerializer::toQueryValue($handle_contains, null);
        }
        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, 'multi', true);
        }
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if (is_array($exclude_state)) {
            $exclude_state = ObjectSerializer::serializeCollection($exclude_state, 'multi', true);
        }
        if ($exclude_state !== null) {
            $queryParams['exclude_state'] = ObjectSerializer::toQueryValue($exclude_state, null);
        }
        // query params
        if ($customer !== null) {
            $queryParams['customer'] = ObjectSerializer::toQueryValue($customer, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if ($refunded_amount !== null) {
            $queryParams['refunded_amount'] = ObjectSerializer::toQueryValue($refunded_amount, null);
        }
        // query params
        if ($authorized_amount !== null) {
            $queryParams['authorized_amount'] = ObjectSerializer::toQueryValue($authorized_amount, null);
        }
        // query params
        if (is_array($currency)) {
            $currency = ObjectSerializer::serializeCollection($currency, 'multi', true);
        }
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency, null);
        }
        // query params
        if ($partial_settled !== null) {
            $queryParams['partial_settled'] = ObjectSerializer::toQueryValue($partial_settled, null);
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, 'multi', true);
        }
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($subscription !== null) {
            $queryParams['subscription'] = ObjectSerializer::toQueryValue($subscription, null);
        }
        // query params
        if ($plan !== null) {
            $queryParams['plan'] = ObjectSerializer::toQueryValue($plan, null);
        }
        // query params
        if ($dunning_start !== null) {
            $queryParams['dunning_start'] = ObjectSerializer::toQueryValue($dunning_start, null);
        }
        // query params
        if ($dunning_success !== null) {
            $queryParams['dunning_success'] = ObjectSerializer::toQueryValue($dunning_success, null);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number, 'int32');
        }
        // query params
        if ($due !== null) {
            $queryParams['due'] = ObjectSerializer::toQueryValue($due, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentMethodList
     *
     * Get list of payment methods
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param string $id Payment method id (optional)
     * @param string[] $state Payment state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;active&#x60;, &#x60;inactivated&#x60;, &#x60;failed&#x60; and &#x60;deleted&#x60; (optional)
     * @param string[] $payment_type Payment method payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param string $customer Customer owning payment method (optional)
     * @param string $subscription Payment methods for subscription (optional)
     * @param string $reference Payment method reference (optional)
     * @param string $failed Failed date interval (optional)
     * @param string[] $card_type Card payment methods with card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string[] $transaction_card_type Card payment methods with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string $card_prefix Card payment methods with card with prefix (optional)
     * @param string $card_postfix Card payment methods with card number postfix (optional)
     * @param string $card_fingerprint Card payment methods with card number postfix (optional)
     * @param string[] $card_country Card payment methods with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param string $card_gateway Card payment methods tied to card gateway (optional)
     * @param string $card_agreement Card payment methods tied to card agreement with id (optional)
     * @param string $mps_external_id MobilePay Subscription external id (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\PaymentMethodList
     */
    public function getPaymentMethodList(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $id = null,
        $state = null,
        $payment_type = null,
        $customer = null,
        $subscription = null,
        $reference = null,
        $failed = null,
        $card_type = null,
        $transaction_card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null,
        $card_country = null,
        $card_gateway = null,
        $card_agreement = null,
        $mps_external_id = null
    ) {
        list($response) = $this->getPaymentMethodListWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $id,
            $state,
            $payment_type,
            $customer,
            $subscription,
            $reference,
            $failed,
            $card_type,
            $transaction_card_type,
            $card_prefix,
            $card_postfix,
            $card_fingerprint,
            $card_country,
            $card_gateway,
            $card_agreement,
            $mps_external_id
        );
        return $response;
    }

    /**
     * Operation getPaymentMethodListWithHttpInfo
     *
     * Get list of payment methods
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param string $id Payment method id (optional)
     * @param string[] $state Payment state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;active&#x60;, &#x60;inactivated&#x60;, &#x60;failed&#x60; and &#x60;deleted&#x60; (optional)
     * @param string[] $payment_type Payment method payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param string $customer Customer owning payment method (optional)
     * @param string $subscription Payment methods for subscription (optional)
     * @param string $reference Payment method reference (optional)
     * @param string $failed Failed date interval (optional)
     * @param string[] $card_type Card payment methods with card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string[] $transaction_card_type Card payment methods with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string $card_prefix Card payment methods with card with prefix (optional)
     * @param string $card_postfix Card payment methods with card number postfix (optional)
     * @param string $card_fingerprint Card payment methods with card number postfix (optional)
     * @param string[] $card_country Card payment methods with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param string $card_gateway Card payment methods tied to card gateway (optional)
     * @param string $card_agreement Card payment methods tied to card agreement with id (optional)
     * @param string $mps_external_id MobilePay Subscription external id (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\PaymentMethodList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentMethodListWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $id = null,
        $state = null,
        $payment_type = null,
        $customer = null,
        $subscription = null,
        $reference = null,
        $failed = null,
        $card_type = null,
        $transaction_card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null,
        $card_country = null,
        $card_gateway = null,
        $card_agreement = null,
        $mps_external_id = null
    ) {
        $returnType = '\Reepay\Model\PaymentMethodList';
        $request = $this->getPaymentMethodListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $id,
            $state,
            $payment_type,
            $customer,
            $subscription,
            $reference,
            $failed,
            $card_type,
            $transaction_card_type,
            $card_prefix,
            $card_postfix,
            $card_fingerprint,
            $card_country,
            $card_gateway,
            $card_agreement,
            $mps_external_id
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\PaymentMethodList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentMethodListAsync
     *
     * Get list of payment methods
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param string $id Payment method id (optional)
     * @param string[] $state Payment state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;active&#x60;, &#x60;inactivated&#x60;, &#x60;failed&#x60; and &#x60;deleted&#x60; (optional)
     * @param string[] $payment_type Payment method payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param string $customer Customer owning payment method (optional)
     * @param string $subscription Payment methods for subscription (optional)
     * @param string $reference Payment method reference (optional)
     * @param string $failed Failed date interval (optional)
     * @param string[] $card_type Card payment methods with card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string[] $transaction_card_type Card payment methods with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string $card_prefix Card payment methods with card with prefix (optional)
     * @param string $card_postfix Card payment methods with card number postfix (optional)
     * @param string $card_fingerprint Card payment methods with card number postfix (optional)
     * @param string[] $card_country Card payment methods with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param string $card_gateway Card payment methods tied to card gateway (optional)
     * @param string $card_agreement Card payment methods tied to card agreement with id (optional)
     * @param string $mps_external_id MobilePay Subscription external id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentMethodListAsync(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $id = null,
        $state = null,
        $payment_type = null,
        $customer = null,
        $subscription = null,
        $reference = null,
        $failed = null,
        $card_type = null,
        $transaction_card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null,
        $card_country = null,
        $card_gateway = null,
        $card_agreement = null,
        $mps_external_id = null
    ) {
        return $this->getPaymentMethodListAsyncWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $id,
            $state,
            $payment_type,
            $customer,
            $subscription,
            $reference,
            $failed,
            $card_type,
            $transaction_card_type,
            $card_prefix,
            $card_postfix,
            $card_fingerprint,
            $card_country,
            $card_gateway,
            $card_agreement,
            $mps_external_id
        )
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentMethodListAsyncWithHttpInfo
     *
     * Get list of payment methods
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param string $id Payment method id (optional)
     * @param string[] $state Payment state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;active&#x60;, &#x60;inactivated&#x60;, &#x60;failed&#x60; and &#x60;deleted&#x60; (optional)
     * @param string[] $payment_type Payment method payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param string $customer Customer owning payment method (optional)
     * @param string $subscription Payment methods for subscription (optional)
     * @param string $reference Payment method reference (optional)
     * @param string $failed Failed date interval (optional)
     * @param string[] $card_type Card payment methods with card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string[] $transaction_card_type Card payment methods with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string $card_prefix Card payment methods with card with prefix (optional)
     * @param string $card_postfix Card payment methods with card number postfix (optional)
     * @param string $card_fingerprint Card payment methods with card number postfix (optional)
     * @param string[] $card_country Card payment methods with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param string $card_gateway Card payment methods tied to card gateway (optional)
     * @param string $card_agreement Card payment methods tied to card agreement with id (optional)
     * @param string $mps_external_id MobilePay Subscription external id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentMethodListAsyncWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $id = null,
        $state = null,
        $payment_type = null,
        $customer = null,
        $subscription = null,
        $reference = null,
        $failed = null,
        $card_type = null,
        $transaction_card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null,
        $card_country = null,
        $card_gateway = null,
        $card_agreement = null,
        $mps_external_id = null
    ) {
        $returnType = '\Reepay\Model\PaymentMethodList';
        $request = $this->getPaymentMethodListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $id,
            $state,
            $payment_type,
            $customer,
            $subscription,
            $reference,
            $failed,
            $card_type,
            $transaction_card_type,
            $card_prefix,
            $card_postfix,
            $card_fingerprint,
            $card_country,
            $card_gateway,
            $card_agreement,
            $mps_external_id
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentMethodList'
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can only be the default &#x60;created&#x60; (optional, default to created)
     * @param string $id Payment method id (optional)
     * @param string[] $state Payment state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;active&#x60;, &#x60;inactivated&#x60;, &#x60;failed&#x60; and &#x60;deleted&#x60; (optional)
     * @param string[] $payment_type Payment method payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param string $customer Customer owning payment method (optional)
     * @param string $subscription Payment methods for subscription (optional)
     * @param string $reference Payment method reference (optional)
     * @param string $failed Failed date interval (optional)
     * @param string[] $card_type Card payment methods with card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string[] $transaction_card_type Card payment methods with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string $card_prefix Card payment methods with card with prefix (optional)
     * @param string $card_postfix Card payment methods with card number postfix (optional)
     * @param string $card_fingerprint Card payment methods with card number postfix (optional)
     * @param string[] $card_country Card payment methods with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param string $card_gateway Card payment methods tied to card gateway (optional)
     * @param string $card_agreement Card payment methods tied to card agreement with id (optional)
     * @param string $mps_external_id MobilePay Subscription external id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPaymentMethodListRequest(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $id = null,
        $state = null,
        $payment_type = null,
        $customer = null,
        $subscription = null,
        $reference = null,
        $failed = null,
        $card_type = null,
        $transaction_card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null,
        $card_country = null,
        $card_gateway = null,
        $card_agreement = null,
        $mps_external_id = null
    ) {
        $resourcePath = '/v1/list/payment_method';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($next_page_token !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($next_page_token, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id, null);
        }
        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, 'multi', true);
        }
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if (is_array($payment_type)) {
            $payment_type = ObjectSerializer::serializeCollection($payment_type, 'multi', true);
        }
        if ($payment_type !== null) {
            $queryParams['payment_type'] = ObjectSerializer::toQueryValue($payment_type, null);
        }
        // query params
        if ($customer !== null) {
            $queryParams['customer'] = ObjectSerializer::toQueryValue($customer, null);
        }
        // query params
        if ($subscription !== null) {
            $queryParams['subscription'] = ObjectSerializer::toQueryValue($subscription, null);
        }
        // query params
        if ($reference !== null) {
            $queryParams['reference'] = ObjectSerializer::toQueryValue($reference, null);
        }
        // query params
        if ($failed !== null) {
            $queryParams['failed'] = ObjectSerializer::toQueryValue($failed, null);
        }
        // query params
        if (is_array($card_type)) {
            $card_type = ObjectSerializer::serializeCollection($card_type, 'multi', true);
        }
        if ($card_type !== null) {
            $queryParams['card_type'] = ObjectSerializer::toQueryValue($card_type, null);
        }
        // query params
        if (is_array($transaction_card_type)) {
            $transaction_card_type = ObjectSerializer::serializeCollection($transaction_card_type, 'multi', true);
        }
        if ($transaction_card_type !== null) {
            $queryParams['transaction_card_type'] = ObjectSerializer::toQueryValue($transaction_card_type, null);
        }
        // query params
        if ($card_prefix !== null) {
            $queryParams['card_prefix'] = ObjectSerializer::toQueryValue($card_prefix, null);
        }
        // query params
        if ($card_postfix !== null) {
            $queryParams['card_postfix'] = ObjectSerializer::toQueryValue($card_postfix, null);
        }
        // query params
        if ($card_fingerprint !== null) {
            $queryParams['card_fingerprint'] = ObjectSerializer::toQueryValue($card_fingerprint, null);
        }
        // query params
        if (is_array($card_country)) {
            $card_country = ObjectSerializer::serializeCollection($card_country, 'multi', true);
        }
        if ($card_country !== null) {
            $queryParams['card_country'] = ObjectSerializer::toQueryValue($card_country, null);
        }
        // query params
        if ($card_gateway !== null) {
            $queryParams['card_gateway'] = ObjectSerializer::toQueryValue($card_gateway, null);
        }
        // query params
        if ($card_agreement !== null) {
            $queryParams['card_agreement'] = ObjectSerializer::toQueryValue($card_agreement, null);
        }
        // query params
        if ($mps_external_id !== null) {
            $queryParams['mps_external_id'] = ObjectSerializer::toQueryValue($mps_external_id, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPayoutList
     *
     * Get list of payouts
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;paid&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Payout handle prefix (optional)
     * @param string $handle_contains Payout handle contains (optional)
     * @param string $customer Payouts for customer by customer handle (optional)
     * @param string[] $state Payout transaction state, multiple can be defined (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Payout currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param string $card Payouts for saved card (optional)
     * @param string $card_type Payouts for card type (optional)
     * @param string $card_prefix Payouts for card with prefix (optional)
     * @param string $card_postfix Payouts for card with postfix (optional)
     * @param string $card_fingerprint Payouts for card with postfix (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\PayoutList
     */
    public function getPayoutList(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $customer = null,
        $state = null,
        $amount = null,
        $currency = null,
        $card = null,
        $card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null
    ) {
        list($response) = $this->getPayoutListWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $customer,
            $state,
            $amount,
            $currency,
            $card,
            $card_type,
            $card_prefix,
            $card_postfix,
            $card_fingerprint
        );
        return $response;
    }

    /**
     * Operation getPayoutListWithHttpInfo
     *
     * Get list of payouts
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;paid&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Payout handle prefix (optional)
     * @param string $handle_contains Payout handle contains (optional)
     * @param string $customer Payouts for customer by customer handle (optional)
     * @param string[] $state Payout transaction state, multiple can be defined (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Payout currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param string $card Payouts for saved card (optional)
     * @param string $card_type Payouts for card type (optional)
     * @param string $card_prefix Payouts for card with prefix (optional)
     * @param string $card_postfix Payouts for card with postfix (optional)
     * @param string $card_fingerprint Payouts for card with postfix (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\PayoutList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPayoutListWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $customer = null,
        $state = null,
        $amount = null,
        $currency = null,
        $card = null,
        $card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null
    ) {
        $returnType = '\Reepay\Model\PayoutList';
        $request = $this->getPayoutListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $customer,
            $state,
            $amount,
            $currency,
            $card,
            $card_type,
            $card_prefix,
            $card_postfix,
            $card_fingerprint
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\PayoutList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPayoutListAsync
     *
     * Get list of payouts
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;paid&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Payout handle prefix (optional)
     * @param string $handle_contains Payout handle contains (optional)
     * @param string $customer Payouts for customer by customer handle (optional)
     * @param string[] $state Payout transaction state, multiple can be defined (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Payout currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param string $card Payouts for saved card (optional)
     * @param string $card_type Payouts for card type (optional)
     * @param string $card_prefix Payouts for card with prefix (optional)
     * @param string $card_postfix Payouts for card with postfix (optional)
     * @param string $card_fingerprint Payouts for card with postfix (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPayoutListAsync(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $customer = null,
        $state = null,
        $amount = null,
        $currency = null,
        $card = null,
        $card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null
    ) {
        return $this->getPayoutListAsyncWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $customer,
            $state,
            $amount,
            $currency,
            $card,
            $card_type,
            $card_prefix,
            $card_postfix,
            $card_fingerprint
        )
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPayoutListAsyncWithHttpInfo
     *
     * Get list of payouts
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;paid&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Payout handle prefix (optional)
     * @param string $handle_contains Payout handle contains (optional)
     * @param string $customer Payouts for customer by customer handle (optional)
     * @param string[] $state Payout transaction state, multiple can be defined (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Payout currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param string $card Payouts for saved card (optional)
     * @param string $card_type Payouts for card type (optional)
     * @param string $card_prefix Payouts for card with prefix (optional)
     * @param string $card_postfix Payouts for card with postfix (optional)
     * @param string $card_fingerprint Payouts for card with postfix (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPayoutListAsyncWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $customer = null,
        $state = null,
        $amount = null,
        $currency = null,
        $card = null,
        $card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null
    ) {
        $returnType = '\Reepay\Model\PayoutList';
        $request = $this->getPayoutListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $customer,
            $state,
            $amount,
            $currency,
            $card,
            $card_type,
            $card_prefix,
            $card_postfix,
            $card_fingerprint
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPayoutList'
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60; or &#x60;paid&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string $handle Payout handle prefix (optional)
     * @param string $handle_contains Payout handle contains (optional)
     * @param string $customer Payouts for customer by customer handle (optional)
     * @param string[] $state Payout transaction state, multiple can be defined (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $currency Payout currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param string $card Payouts for saved card (optional)
     * @param string $card_type Payouts for card type (optional)
     * @param string $card_prefix Payouts for card with prefix (optional)
     * @param string $card_postfix Payouts for card with postfix (optional)
     * @param string $card_fingerprint Payouts for card with postfix (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPayoutListRequest(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $customer = null,
        $state = null,
        $amount = null,
        $currency = null,
        $card = null,
        $card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null
    ) {
        $resourcePath = '/v1/list/payout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($next_page_token !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($next_page_token, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($handle_contains !== null) {
            $queryParams['handle_contains'] = ObjectSerializer::toQueryValue($handle_contains, null);
        }
        // query params
        if ($customer !== null) {
            $queryParams['customer'] = ObjectSerializer::toQueryValue($customer, null);
        }
        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, 'multi', true);
        }
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if (is_array($currency)) {
            $currency = ObjectSerializer::serializeCollection($currency, 'multi', true);
        }
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency, null);
        }
        // query params
        if ($card !== null) {
            $queryParams['card'] = ObjectSerializer::toQueryValue($card, null);
        }
        // query params
        if ($card_type !== null) {
            $queryParams['card_type'] = ObjectSerializer::toQueryValue($card_type, null);
        }
        // query params
        if ($card_prefix !== null) {
            $queryParams['card_prefix'] = ObjectSerializer::toQueryValue($card_prefix, null);
        }
        // query params
        if ($card_postfix !== null) {
            $queryParams['card_postfix'] = ObjectSerializer::toQueryValue($card_postfix, null);
        }
        // query params
        if ($card_fingerprint !== null) {
            $queryParams['card_fingerprint'] = ObjectSerializer::toQueryValue($card_fingerprint, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPlanList
     *
     * Get list of plans
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute for time limit. Accepted value &#x60;created&#x60; (optional, default to created)
     * @param string $handle Plan handle prefix (optional)
     * @param string[] $state State of the subscription plan, one of the following: &#x60;active&#x60;, &#x60;superseded&#x60; or &#x60;deleted&#x60;. Multiple can be defined. (optional)
     * @param string[] $schedule_type Scheduling type, one of the following: &#x60;manual&#x60;, &#x60;daily&#x60;, &#x60;weekly_fixedday&#x60;, &#x60;month_startdate&#x60;, &#x60;month_fixedday&#x60;, &#x60;month_lastday&#x60;. Multiple can be defined. (optional)
     * @param string[] $partial_period_handling The way to bill initial (not full) period. Options: &#x60;bill_full&#x60;, &#x60;bill_prorated&#x60;, &#x60;bill_zero_amount&#x60;, &#x60;no_bill&#x60;. Multiple can be defined. (optional)
     * @param string[] $setup_fee_handling How the billing of the setup fee should be done. Accepted values: &#x60;first&#x60;, &#x60;separate&#x60;, &#x60;separate_conditional&#x60;. Multiple can be defined. (optional)
     * @param string[] $fixed_life_time_unit Time unit use for fixed life time. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param string[] $trial_interval_unit Time unit for free trial period. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param string $dunning_plan_handle Dunning plan handle (optional)
     * @param string $name Name of plan. Used as order line text. (optional)
     * @param string $description Optional description of plan (optional)
     * @param string $setup_fee_text Optional invoice order text for the setup fee (optional)
     * @param string $amount Fixed amount plan deducted from order line amounts including VAT. (optional)
     * @param string $quantity Optional default quantity of the subscription plan product for new subscriptions. Default is 1. (optional)
     * @param string $fixed_count Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices. (optional)
     * @param string $fixed_life_time_length The number of days/months for which the subscription is live. (optional)
     * @param string $trial_interval_length The number of days/months for how long the free trial period lasts (optional)
     * @param string $interval_length The length of subscription intervals. E.g. every second month or every 14 days. (optional)
     * @param string $schedule_fixed_day The number of day for &#x60;weekly_fixedday&#x60; and &#x60;month_fixedday&#x60; schedule types. For months the allowed values are 1-28 for weeks 1-7 (optional)
     * @param string $renewal_reminder_email_days Number of days before next billing to send a reminder email. (optional)
     * @param string $trial_reminder_email_days Number of days before end of trial to send a reminder email. (optional)
     * @param string $base_month Base month for fixed month schedule type (optional)
     * @param string $notice_periods Number of notice periods before a cancellation. (optional)
     * @param string $minimum_prorated_amount Minimum amount for prorated invoice. If the amount is less, 0 is charged (optional)
     * @param string $fixation_periods Number of paid periods before expiring after a cancellation. (optional)
     * @param string $setup_fee Optional one-time setup fee billed with the first invoice. (optional)
     * @param string $amount_incl_vat Whether the amount is including VAT. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $notice_periods_after_current Is cancelled flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixation_periods_full If fixation periods are defined, and the subscription can have a partial prorated first period,this parameter controls if the the last period should be full, or partial. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $include_zero_amount Whether to add a zero amount order line to subscription invoices. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $partial_proration_days If proration should be day based (instead of minute). Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixed_trial_days Controls if trial expires at midnight or it&#x27;s down to the minute. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\PlanList
     */
    public function getPlanList(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = null,
        $schedule_type = null,
        $partial_period_handling = null,
        $setup_fee_handling = null,
        $fixed_life_time_unit = null,
        $trial_interval_unit = null,
        $dunning_plan_handle = null,
        $name = null,
        $description = null,
        $setup_fee_text = null,
        $amount = null,
        $quantity = null,
        $fixed_count = null,
        $fixed_life_time_length = null,
        $trial_interval_length = null,
        $interval_length = null,
        $schedule_fixed_day = null,
        $renewal_reminder_email_days = null,
        $trial_reminder_email_days = null,
        $base_month = null,
        $notice_periods = null,
        $minimum_prorated_amount = null,
        $fixation_periods = null,
        $setup_fee = null,
        $amount_incl_vat = null,
        $notice_periods_after_current = null,
        $fixation_periods_full = null,
        $include_zero_amount = null,
        $partial_proration_days = null,
        $fixed_trial_days = null
    ) {
        list($response) = $this->getPlanListWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $state,
            $schedule_type,
            $partial_period_handling,
            $setup_fee_handling,
            $fixed_life_time_unit,
            $trial_interval_unit,
            $dunning_plan_handle,
            $name,
            $description,
            $setup_fee_text,
            $amount,
            $quantity,
            $fixed_count,
            $fixed_life_time_length,
            $trial_interval_length,
            $interval_length,
            $schedule_fixed_day,
            $renewal_reminder_email_days,
            $trial_reminder_email_days,
            $base_month,
            $notice_periods,
            $minimum_prorated_amount,
            $fixation_periods,
            $setup_fee,
            $amount_incl_vat,
            $notice_periods_after_current,
            $fixation_periods_full,
            $include_zero_amount,
            $partial_proration_days,
            $fixed_trial_days
        );
        return $response;
    }

    /**
     * Operation getPlanListWithHttpInfo
     *
     * Get list of plans
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute for time limit. Accepted value &#x60;created&#x60; (optional, default to created)
     * @param string $handle Plan handle prefix (optional)
     * @param string[] $state State of the subscription plan, one of the following: &#x60;active&#x60;, &#x60;superseded&#x60; or &#x60;deleted&#x60;. Multiple can be defined. (optional)
     * @param string[] $schedule_type Scheduling type, one of the following: &#x60;manual&#x60;, &#x60;daily&#x60;, &#x60;weekly_fixedday&#x60;, &#x60;month_startdate&#x60;, &#x60;month_fixedday&#x60;, &#x60;month_lastday&#x60;. Multiple can be defined. (optional)
     * @param string[] $partial_period_handling The way to bill initial (not full) period. Options: &#x60;bill_full&#x60;, &#x60;bill_prorated&#x60;, &#x60;bill_zero_amount&#x60;, &#x60;no_bill&#x60;. Multiple can be defined. (optional)
     * @param string[] $setup_fee_handling How the billing of the setup fee should be done. Accepted values: &#x60;first&#x60;, &#x60;separate&#x60;, &#x60;separate_conditional&#x60;. Multiple can be defined. (optional)
     * @param string[] $fixed_life_time_unit Time unit use for fixed life time. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param string[] $trial_interval_unit Time unit for free trial period. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param string $dunning_plan_handle Dunning plan handle (optional)
     * @param string $name Name of plan. Used as order line text. (optional)
     * @param string $description Optional description of plan (optional)
     * @param string $setup_fee_text Optional invoice order text for the setup fee (optional)
     * @param string $amount Fixed amount plan deducted from order line amounts including VAT. (optional)
     * @param string $quantity Optional default quantity of the subscription plan product for new subscriptions. Default is 1. (optional)
     * @param string $fixed_count Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices. (optional)
     * @param string $fixed_life_time_length The number of days/months for which the subscription is live. (optional)
     * @param string $trial_interval_length The number of days/months for how long the free trial period lasts (optional)
     * @param string $interval_length The length of subscription intervals. E.g. every second month or every 14 days. (optional)
     * @param string $schedule_fixed_day The number of day for &#x60;weekly_fixedday&#x60; and &#x60;month_fixedday&#x60; schedule types. For months the allowed values are 1-28 for weeks 1-7 (optional)
     * @param string $renewal_reminder_email_days Number of days before next billing to send a reminder email. (optional)
     * @param string $trial_reminder_email_days Number of days before end of trial to send a reminder email. (optional)
     * @param string $base_month Base month for fixed month schedule type (optional)
     * @param string $notice_periods Number of notice periods before a cancellation. (optional)
     * @param string $minimum_prorated_amount Minimum amount for prorated invoice. If the amount is less, 0 is charged (optional)
     * @param string $fixation_periods Number of paid periods before expiring after a cancellation. (optional)
     * @param string $setup_fee Optional one-time setup fee billed with the first invoice. (optional)
     * @param string $amount_incl_vat Whether the amount is including VAT. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $notice_periods_after_current Is cancelled flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixation_periods_full If fixation periods are defined, and the subscription can have a partial prorated first period,this parameter controls if the the last period should be full, or partial. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $include_zero_amount Whether to add a zero amount order line to subscription invoices. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $partial_proration_days If proration should be day based (instead of minute). Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixed_trial_days Controls if trial expires at midnight or it&#x27;s down to the minute. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\PlanList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPlanListWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = null,
        $schedule_type = null,
        $partial_period_handling = null,
        $setup_fee_handling = null,
        $fixed_life_time_unit = null,
        $trial_interval_unit = null,
        $dunning_plan_handle = null,
        $name = null,
        $description = null,
        $setup_fee_text = null,
        $amount = null,
        $quantity = null,
        $fixed_count = null,
        $fixed_life_time_length = null,
        $trial_interval_length = null,
        $interval_length = null,
        $schedule_fixed_day = null,
        $renewal_reminder_email_days = null,
        $trial_reminder_email_days = null,
        $base_month = null,
        $notice_periods = null,
        $minimum_prorated_amount = null,
        $fixation_periods = null,
        $setup_fee = null,
        $amount_incl_vat = null,
        $notice_periods_after_current = null,
        $fixation_periods_full = null,
        $include_zero_amount = null,
        $partial_proration_days = null,
        $fixed_trial_days = null
    ) {
        $returnType = '\Reepay\Model\PlanList';
        $request = $this->getPlanListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $state,
            $schedule_type,
            $partial_period_handling,
            $setup_fee_handling,
            $fixed_life_time_unit,
            $trial_interval_unit,
            $dunning_plan_handle,
            $name,
            $description,
            $setup_fee_text,
            $amount,
            $quantity,
            $fixed_count,
            $fixed_life_time_length,
            $trial_interval_length,
            $interval_length,
            $schedule_fixed_day,
            $renewal_reminder_email_days,
            $trial_reminder_email_days,
            $base_month,
            $notice_periods,
            $minimum_prorated_amount,
            $fixation_periods,
            $setup_fee,
            $amount_incl_vat,
            $notice_periods_after_current,
            $fixation_periods_full,
            $include_zero_amount,
            $partial_proration_days,
            $fixed_trial_days
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\PlanList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPlanListAsync
     *
     * Get list of plans
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute for time limit. Accepted value &#x60;created&#x60; (optional, default to created)
     * @param string $handle Plan handle prefix (optional)
     * @param string[] $state State of the subscription plan, one of the following: &#x60;active&#x60;, &#x60;superseded&#x60; or &#x60;deleted&#x60;. Multiple can be defined. (optional)
     * @param string[] $schedule_type Scheduling type, one of the following: &#x60;manual&#x60;, &#x60;daily&#x60;, &#x60;weekly_fixedday&#x60;, &#x60;month_startdate&#x60;, &#x60;month_fixedday&#x60;, &#x60;month_lastday&#x60;. Multiple can be defined. (optional)
     * @param string[] $partial_period_handling The way to bill initial (not full) period. Options: &#x60;bill_full&#x60;, &#x60;bill_prorated&#x60;, &#x60;bill_zero_amount&#x60;, &#x60;no_bill&#x60;. Multiple can be defined. (optional)
     * @param string[] $setup_fee_handling How the billing of the setup fee should be done. Accepted values: &#x60;first&#x60;, &#x60;separate&#x60;, &#x60;separate_conditional&#x60;. Multiple can be defined. (optional)
     * @param string[] $fixed_life_time_unit Time unit use for fixed life time. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param string[] $trial_interval_unit Time unit for free trial period. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param string $dunning_plan_handle Dunning plan handle (optional)
     * @param string $name Name of plan. Used as order line text. (optional)
     * @param string $description Optional description of plan (optional)
     * @param string $setup_fee_text Optional invoice order text for the setup fee (optional)
     * @param string $amount Fixed amount plan deducted from order line amounts including VAT. (optional)
     * @param string $quantity Optional default quantity of the subscription plan product for new subscriptions. Default is 1. (optional)
     * @param string $fixed_count Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices. (optional)
     * @param string $fixed_life_time_length The number of days/months for which the subscription is live. (optional)
     * @param string $trial_interval_length The number of days/months for how long the free trial period lasts (optional)
     * @param string $interval_length The length of subscription intervals. E.g. every second month or every 14 days. (optional)
     * @param string $schedule_fixed_day The number of day for &#x60;weekly_fixedday&#x60; and &#x60;month_fixedday&#x60; schedule types. For months the allowed values are 1-28 for weeks 1-7 (optional)
     * @param string $renewal_reminder_email_days Number of days before next billing to send a reminder email. (optional)
     * @param string $trial_reminder_email_days Number of days before end of trial to send a reminder email. (optional)
     * @param string $base_month Base month for fixed month schedule type (optional)
     * @param string $notice_periods Number of notice periods before a cancellation. (optional)
     * @param string $minimum_prorated_amount Minimum amount for prorated invoice. If the amount is less, 0 is charged (optional)
     * @param string $fixation_periods Number of paid periods before expiring after a cancellation. (optional)
     * @param string $setup_fee Optional one-time setup fee billed with the first invoice. (optional)
     * @param string $amount_incl_vat Whether the amount is including VAT. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $notice_periods_after_current Is cancelled flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixation_periods_full If fixation periods are defined, and the subscription can have a partial prorated first period,this parameter controls if the the last period should be full, or partial. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $include_zero_amount Whether to add a zero amount order line to subscription invoices. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $partial_proration_days If proration should be day based (instead of minute). Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixed_trial_days Controls if trial expires at midnight or it&#x27;s down to the minute. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPlanListAsync(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = null,
        $schedule_type = null,
        $partial_period_handling = null,
        $setup_fee_handling = null,
        $fixed_life_time_unit = null,
        $trial_interval_unit = null,
        $dunning_plan_handle = null,
        $name = null,
        $description = null,
        $setup_fee_text = null,
        $amount = null,
        $quantity = null,
        $fixed_count = null,
        $fixed_life_time_length = null,
        $trial_interval_length = null,
        $interval_length = null,
        $schedule_fixed_day = null,
        $renewal_reminder_email_days = null,
        $trial_reminder_email_days = null,
        $base_month = null,
        $notice_periods = null,
        $minimum_prorated_amount = null,
        $fixation_periods = null,
        $setup_fee = null,
        $amount_incl_vat = null,
        $notice_periods_after_current = null,
        $fixation_periods_full = null,
        $include_zero_amount = null,
        $partial_proration_days = null,
        $fixed_trial_days = null
    ) {
        return $this->getPlanListAsyncWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $state,
            $schedule_type,
            $partial_period_handling,
            $setup_fee_handling,
            $fixed_life_time_unit,
            $trial_interval_unit,
            $dunning_plan_handle,
            $name,
            $description,
            $setup_fee_text,
            $amount,
            $quantity,
            $fixed_count,
            $fixed_life_time_length,
            $trial_interval_length,
            $interval_length,
            $schedule_fixed_day,
            $renewal_reminder_email_days,
            $trial_reminder_email_days,
            $base_month,
            $notice_periods,
            $minimum_prorated_amount,
            $fixation_periods,
            $setup_fee,
            $amount_incl_vat,
            $notice_periods_after_current,
            $fixation_periods_full,
            $include_zero_amount,
            $partial_proration_days,
            $fixed_trial_days
        )
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPlanListAsyncWithHttpInfo
     *
     * Get list of plans
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute for time limit. Accepted value &#x60;created&#x60; (optional, default to created)
     * @param string $handle Plan handle prefix (optional)
     * @param string[] $state State of the subscription plan, one of the following: &#x60;active&#x60;, &#x60;superseded&#x60; or &#x60;deleted&#x60;. Multiple can be defined. (optional)
     * @param string[] $schedule_type Scheduling type, one of the following: &#x60;manual&#x60;, &#x60;daily&#x60;, &#x60;weekly_fixedday&#x60;, &#x60;month_startdate&#x60;, &#x60;month_fixedday&#x60;, &#x60;month_lastday&#x60;. Multiple can be defined. (optional)
     * @param string[] $partial_period_handling The way to bill initial (not full) period. Options: &#x60;bill_full&#x60;, &#x60;bill_prorated&#x60;, &#x60;bill_zero_amount&#x60;, &#x60;no_bill&#x60;. Multiple can be defined. (optional)
     * @param string[] $setup_fee_handling How the billing of the setup fee should be done. Accepted values: &#x60;first&#x60;, &#x60;separate&#x60;, &#x60;separate_conditional&#x60;. Multiple can be defined. (optional)
     * @param string[] $fixed_life_time_unit Time unit use for fixed life time. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param string[] $trial_interval_unit Time unit for free trial period. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param string $dunning_plan_handle Dunning plan handle (optional)
     * @param string $name Name of plan. Used as order line text. (optional)
     * @param string $description Optional description of plan (optional)
     * @param string $setup_fee_text Optional invoice order text for the setup fee (optional)
     * @param string $amount Fixed amount plan deducted from order line amounts including VAT. (optional)
     * @param string $quantity Optional default quantity of the subscription plan product for new subscriptions. Default is 1. (optional)
     * @param string $fixed_count Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices. (optional)
     * @param string $fixed_life_time_length The number of days/months for which the subscription is live. (optional)
     * @param string $trial_interval_length The number of days/months for how long the free trial period lasts (optional)
     * @param string $interval_length The length of subscription intervals. E.g. every second month or every 14 days. (optional)
     * @param string $schedule_fixed_day The number of day for &#x60;weekly_fixedday&#x60; and &#x60;month_fixedday&#x60; schedule types. For months the allowed values are 1-28 for weeks 1-7 (optional)
     * @param string $renewal_reminder_email_days Number of days before next billing to send a reminder email. (optional)
     * @param string $trial_reminder_email_days Number of days before end of trial to send a reminder email. (optional)
     * @param string $base_month Base month for fixed month schedule type (optional)
     * @param string $notice_periods Number of notice periods before a cancellation. (optional)
     * @param string $minimum_prorated_amount Minimum amount for prorated invoice. If the amount is less, 0 is charged (optional)
     * @param string $fixation_periods Number of paid periods before expiring after a cancellation. (optional)
     * @param string $setup_fee Optional one-time setup fee billed with the first invoice. (optional)
     * @param string $amount_incl_vat Whether the amount is including VAT. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $notice_periods_after_current Is cancelled flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixation_periods_full If fixation periods are defined, and the subscription can have a partial prorated first period,this parameter controls if the the last period should be full, or partial. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $include_zero_amount Whether to add a zero amount order line to subscription invoices. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $partial_proration_days If proration should be day based (instead of minute). Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixed_trial_days Controls if trial expires at midnight or it&#x27;s down to the minute. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPlanListAsyncWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = null,
        $schedule_type = null,
        $partial_period_handling = null,
        $setup_fee_handling = null,
        $fixed_life_time_unit = null,
        $trial_interval_unit = null,
        $dunning_plan_handle = null,
        $name = null,
        $description = null,
        $setup_fee_text = null,
        $amount = null,
        $quantity = null,
        $fixed_count = null,
        $fixed_life_time_length = null,
        $trial_interval_length = null,
        $interval_length = null,
        $schedule_fixed_day = null,
        $renewal_reminder_email_days = null,
        $trial_reminder_email_days = null,
        $base_month = null,
        $notice_periods = null,
        $minimum_prorated_amount = null,
        $fixation_periods = null,
        $setup_fee = null,
        $amount_incl_vat = null,
        $notice_periods_after_current = null,
        $fixation_periods_full = null,
        $include_zero_amount = null,
        $partial_proration_days = null,
        $fixed_trial_days = null
    ) {
        $returnType = '\Reepay\Model\PlanList';
        $request = $this->getPlanListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $state,
            $schedule_type,
            $partial_period_handling,
            $setup_fee_handling,
            $fixed_life_time_unit,
            $trial_interval_unit,
            $dunning_plan_handle,
            $name,
            $description,
            $setup_fee_text,
            $amount,
            $quantity,
            $fixed_count,
            $fixed_life_time_length,
            $trial_interval_length,
            $interval_length,
            $schedule_fixed_day,
            $renewal_reminder_email_days,
            $trial_reminder_email_days,
            $base_month,
            $notice_periods,
            $minimum_prorated_amount,
            $fixation_periods,
            $setup_fee,
            $amount_incl_vat,
            $notice_periods_after_current,
            $fixation_periods_full,
            $include_zero_amount,
            $partial_proration_days,
            $fixed_trial_days
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPlanList'
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute for time limit. Accepted value &#x60;created&#x60; (optional, default to created)
     * @param string $handle Plan handle prefix (optional)
     * @param string[] $state State of the subscription plan, one of the following: &#x60;active&#x60;, &#x60;superseded&#x60; or &#x60;deleted&#x60;. Multiple can be defined. (optional)
     * @param string[] $schedule_type Scheduling type, one of the following: &#x60;manual&#x60;, &#x60;daily&#x60;, &#x60;weekly_fixedday&#x60;, &#x60;month_startdate&#x60;, &#x60;month_fixedday&#x60;, &#x60;month_lastday&#x60;. Multiple can be defined. (optional)
     * @param string[] $partial_period_handling The way to bill initial (not full) period. Options: &#x60;bill_full&#x60;, &#x60;bill_prorated&#x60;, &#x60;bill_zero_amount&#x60;, &#x60;no_bill&#x60;. Multiple can be defined. (optional)
     * @param string[] $setup_fee_handling How the billing of the setup fee should be done. Accepted values: &#x60;first&#x60;, &#x60;separate&#x60;, &#x60;separate_conditional&#x60;. Multiple can be defined. (optional)
     * @param string[] $fixed_life_time_unit Time unit use for fixed life time. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param string[] $trial_interval_unit Time unit for free trial period. Accepted units: &#x60;days&#x60; or &#x60;months&#x60; (optional)
     * @param string $dunning_plan_handle Dunning plan handle (optional)
     * @param string $name Name of plan. Used as order line text. (optional)
     * @param string $description Optional description of plan (optional)
     * @param string $setup_fee_text Optional invoice order text for the setup fee (optional)
     * @param string $amount Fixed amount plan deducted from order line amounts including VAT. (optional)
     * @param string $quantity Optional default quantity of the subscription plan product for new subscriptions. Default is 1. (optional)
     * @param string $fixed_count Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices. (optional)
     * @param string $fixed_life_time_length The number of days/months for which the subscription is live. (optional)
     * @param string $trial_interval_length The number of days/months for how long the free trial period lasts (optional)
     * @param string $interval_length The length of subscription intervals. E.g. every second month or every 14 days. (optional)
     * @param string $schedule_fixed_day The number of day for &#x60;weekly_fixedday&#x60; and &#x60;month_fixedday&#x60; schedule types. For months the allowed values are 1-28 for weeks 1-7 (optional)
     * @param string $renewal_reminder_email_days Number of days before next billing to send a reminder email. (optional)
     * @param string $trial_reminder_email_days Number of days before end of trial to send a reminder email. (optional)
     * @param string $base_month Base month for fixed month schedule type (optional)
     * @param string $notice_periods Number of notice periods before a cancellation. (optional)
     * @param string $minimum_prorated_amount Minimum amount for prorated invoice. If the amount is less, 0 is charged (optional)
     * @param string $fixation_periods Number of paid periods before expiring after a cancellation. (optional)
     * @param string $setup_fee Optional one-time setup fee billed with the first invoice. (optional)
     * @param string $amount_incl_vat Whether the amount is including VAT. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $notice_periods_after_current Is cancelled flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixation_periods_full If fixation periods are defined, and the subscription can have a partial prorated first period,this parameter controls if the the last period should be full, or partial. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $include_zero_amount Whether to add a zero amount order line to subscription invoices. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $partial_proration_days If proration should be day based (instead of minute). Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $fixed_trial_days Controls if trial expires at midnight or it&#x27;s down to the minute. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPlanListRequest(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $state = null,
        $schedule_type = null,
        $partial_period_handling = null,
        $setup_fee_handling = null,
        $fixed_life_time_unit = null,
        $trial_interval_unit = null,
        $dunning_plan_handle = null,
        $name = null,
        $description = null,
        $setup_fee_text = null,
        $amount = null,
        $quantity = null,
        $fixed_count = null,
        $fixed_life_time_length = null,
        $trial_interval_length = null,
        $interval_length = null,
        $schedule_fixed_day = null,
        $renewal_reminder_email_days = null,
        $trial_reminder_email_days = null,
        $base_month = null,
        $notice_periods = null,
        $minimum_prorated_amount = null,
        $fixation_periods = null,
        $setup_fee = null,
        $amount_incl_vat = null,
        $notice_periods_after_current = null,
        $fixation_periods_full = null,
        $include_zero_amount = null,
        $partial_proration_days = null,
        $fixed_trial_days = null
    ) {
        $resourcePath = '/v1/list/plan';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($next_page_token !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($next_page_token, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, 'multi', true);
        }
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if (is_array($schedule_type)) {
            $schedule_type = ObjectSerializer::serializeCollection($schedule_type, 'multi', true);
        }
        if ($schedule_type !== null) {
            $queryParams['schedule_type'] = ObjectSerializer::toQueryValue($schedule_type, null);
        }
        // query params
        if (is_array($partial_period_handling)) {
            $partial_period_handling = ObjectSerializer::serializeCollection($partial_period_handling, 'multi', true);
        }
        if ($partial_period_handling !== null) {
            $queryParams['partial_period_handling'] = ObjectSerializer::toQueryValue($partial_period_handling, null);
        }
        // query params
        if (is_array($setup_fee_handling)) {
            $setup_fee_handling = ObjectSerializer::serializeCollection($setup_fee_handling, 'multi', true);
        }
        if ($setup_fee_handling !== null) {
            $queryParams['setup_fee_handling'] = ObjectSerializer::toQueryValue($setup_fee_handling, null);
        }
        // query params
        if (is_array($fixed_life_time_unit)) {
            $fixed_life_time_unit = ObjectSerializer::serializeCollection($fixed_life_time_unit, 'multi', true);
        }
        if ($fixed_life_time_unit !== null) {
            $queryParams['fixed_life_time_unit'] = ObjectSerializer::toQueryValue($fixed_life_time_unit, null);
        }
        // query params
        if (is_array($trial_interval_unit)) {
            $trial_interval_unit = ObjectSerializer::serializeCollection($trial_interval_unit, 'multi', true);
        }
        if ($trial_interval_unit !== null) {
            $queryParams['trial_interval_unit'] = ObjectSerializer::toQueryValue($trial_interval_unit, null);
        }
        // query params
        if ($dunning_plan_handle !== null) {
            $queryParams['dunning_plan_handle'] = ObjectSerializer::toQueryValue($dunning_plan_handle, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description, null);
        }
        // query params
        if ($setup_fee_text !== null) {
            $queryParams['setup_fee_text'] = ObjectSerializer::toQueryValue($setup_fee_text, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if ($quantity !== null) {
            $queryParams['quantity'] = ObjectSerializer::toQueryValue($quantity, null);
        }
        // query params
        if ($fixed_count !== null) {
            $queryParams['fixed_count'] = ObjectSerializer::toQueryValue($fixed_count, null);
        }
        // query params
        if ($fixed_life_time_length !== null) {
            $queryParams['fixed_life_time_length'] = ObjectSerializer::toQueryValue($fixed_life_time_length, null);
        }
        // query params
        if ($trial_interval_length !== null) {
            $queryParams['trial_interval_length'] = ObjectSerializer::toQueryValue($trial_interval_length, null);
        }
        // query params
        if ($interval_length !== null) {
            $queryParams['interval_length'] = ObjectSerializer::toQueryValue($interval_length, null);
        }
        // query params
        if ($schedule_fixed_day !== null) {
            $queryParams['schedule_fixed_day'] = ObjectSerializer::toQueryValue($schedule_fixed_day, null);
        }
        // query params
        if ($renewal_reminder_email_days !== null) {
            $queryParams['renewal_reminder_email_days'] = ObjectSerializer::toQueryValue(
                $renewal_reminder_email_days,
                null
            );
        }
        // query params
        if ($trial_reminder_email_days !== null) {
            $queryParams['trial_reminder_email_days'] = ObjectSerializer::toQueryValue(
                $trial_reminder_email_days,
                null
            );
        }
        // query params
        if ($base_month !== null) {
            $queryParams['base_month'] = ObjectSerializer::toQueryValue($base_month, null);
        }
        // query params
        if ($notice_periods !== null) {
            $queryParams['notice_periods'] = ObjectSerializer::toQueryValue($notice_periods, null);
        }
        // query params
        if ($minimum_prorated_amount !== null) {
            $queryParams['minimum_prorated_amount'] = ObjectSerializer::toQueryValue($minimum_prorated_amount, null);
        }
        // query params
        if ($fixation_periods !== null) {
            $queryParams['fixation_periods'] = ObjectSerializer::toQueryValue($fixation_periods, null);
        }
        // query params
        if ($setup_fee !== null) {
            $queryParams['setup_fee'] = ObjectSerializer::toQueryValue($setup_fee, null);
        }
        // query params
        if ($amount_incl_vat !== null) {
            $queryParams['amount_incl_vat'] = ObjectSerializer::toQueryValue($amount_incl_vat, null);
        }
        // query params
        if ($notice_periods_after_current !== null) {
            $queryParams['notice_periods_after_current'] = ObjectSerializer::toQueryValue(
                $notice_periods_after_current,
                null
            );
        }
        // query params
        if ($fixation_periods_full !== null) {
            $queryParams['fixation_periods_full'] = ObjectSerializer::toQueryValue($fixation_periods_full, null);
        }
        // query params
        if ($include_zero_amount !== null) {
            $queryParams['include_zero_amount'] = ObjectSerializer::toQueryValue($include_zero_amount, null);
        }
        // query params
        if ($partial_proration_days !== null) {
            $queryParams['partial_proration_days'] = ObjectSerializer::toQueryValue($partial_proration_days, null);
        }
        // query params
        if ($fixed_trial_days !== null) {
            $queryParams['fixed_trial_days'] = ObjectSerializer::toQueryValue($fixed_trial_days, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSubscriptionList
     *
     * Get list of subscriptions
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60;, &#x60;activated&#x60;, &#x60;expired&#x60;, &#x60;cancelled&#x60;, &#x60;on_hold&#x60; or &#x60;reactivated&#x60; (optional, default to created)
     * @param string $handle Subscription handle prefix (optional)
     * @param string $handle_contains Subscription handle contains (optional)
     * @param string $customer Customer owning subscription (optional)
     * @param string $plan Plan owning subscription (optional)
     * @param string[] $state Subscription state, multiple can be defined. States: &#x60;active&#x60;, &#x60;expired&#x60;, &#x60;on_hold&#x60; or &#x60;pending&#x60; (optional)
     * @param string $amount Custom amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $quantity Quantity. See documentation of intervals. (optional)
     * @param string $activated Activated date interval (optional)
     * @param string $cancelled_date Cancelled date interval (optional)
     * @param string $reactivated Reactivated date interval (optional)
     * @param string $created Created date interval (optional)
     * @param string $renewing Renewing flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param int $plan_version Plan version (optional)
     * @param string $amount_incl_vat Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $start_date Start date interval (optional)
     * @param string $end_date End date interval (optional)
     * @param string $grace_duration Grace duration in seconds. See documentation of intervals. (optional)
     * @param string $current_period_start Current period start date interval (optional)
     * @param string $next_period_start Next period start date interval (optional)
     * @param string $first_period_start First period start date interval (optional)
     * @param string $last_period_start Last period start date interval (optional)
     * @param string $trial_start Trial period start date interval (optional)
     * @param string $trial_end Trial period end date interval (optional)
     * @param string $in_trial In trial flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $has_started Has started flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $renewal_count Renewal Count. See documentation of intervals. (optional)
     * @param string $expired_date Expired period date interval (optional)
     * @param string[] $expire_reason On hold reason, multiple can be defined. Types: &#x60;dunning&#x60;, &#x60;cancelled&#x60;,&#x60;ondemand&#x60;, and &#x60;fixed&#x60; (optional)
     * @param string $on_hold_date On hold period date interval (optional)
     * @param string[] $on_hold_reason On hold reason, multiple can be defined. Types: &#x60;ondemand&#x60;, and &#x60;dunning&#x60; (optional)
     * @param string $payment_method_added Payment method added flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $reminder_email_sent Reminder email sent period date interval (optional)
     * @param string $failed_invoices Failed invoices. See documentation of intervals. (optional)
     * @param string $failed_amount Failed amount. See documentation of intervals. (optional)
     * @param string $cancelled_invoices Cancelled invoices. See documentation of intervals. (optional)
     * @param string $cancelled_amount Cancelled amount. See documentation of intervals. (optional)
     * @param string $pending_invoices Pending invoices. See documentation of intervals. (optional)
     * @param string $pending_amount Pending amount invoices. See documentation of intervals. (optional)
     * @param string $dunning_invoices Dunning invoices. See documentation of intervals. (optional)
     * @param string $dunning_amount Dunning amount. See documentation of intervals. (optional)
     * @param string $settled_invoices Settled invoices. See documentation of intervals. (optional)
     * @param string $settled_amount Settled amount. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount. See documentation of intervals. (optional)
     * @param string $pending_additional_costs Pending additional costs. See documentation of intervals. (optional)
     * @param string $pending_additional_cost_amount Pending additional cost amount. See documentation of intervals. (optional)
     * @param string $transferred_additional_costs Transferred additional costs. See documentation of intervals. (optional)
     * @param string $transferred_additional_cost_amount Transferred additional cost amount. See documentation of intervals. (optional)
     * @param string $pending_credits Pending credits. See documentation of intervals. (optional)
     * @param string $pending_credit_amount Pending credit amount. See documentation of intervals. (optional)
     * @param string $transferred_credits Transferred credits. See documentation of intervals. (optional)
     * @param string $transferred_credit_amount Transferred credit amount. See documentation of intervals. (optional)
     * @param string $subscription_add_on_handle Subscription add-on handle (optional)
     * @param string $add_on_handle Add-on handle (optional)
     * @param string $subscription_discount_handle Subscription discount handle (optional)
     * @param string $discount_handle Discount handle (optional)
     * @param string $coupon_handle Coupon handle (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\SubscriptionList
     */
    public function getSubscriptionList(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $customer = null,
        $plan = null,
        $state = null,
        $amount = null,
        $quantity = null,
        $activated = null,
        $cancelled_date = null,
        $reactivated = null,
        $created = null,
        $renewing = null,
        $plan_version = null,
        $amount_incl_vat = null,
        $start_date = null,
        $end_date = null,
        $grace_duration = null,
        $current_period_start = null,
        $next_period_start = null,
        $first_period_start = null,
        $last_period_start = null,
        $trial_start = null,
        $trial_end = null,
        $in_trial = null,
        $has_started = null,
        $renewal_count = null,
        $expired_date = null,
        $expire_reason = null,
        $on_hold_date = null,
        $on_hold_reason = null,
        $payment_method_added = null,
        $reminder_email_sent = null,
        $failed_invoices = null,
        $failed_amount = null,
        $cancelled_invoices = null,
        $cancelled_amount = null,
        $pending_invoices = null,
        $pending_amount = null,
        $dunning_invoices = null,
        $dunning_amount = null,
        $settled_invoices = null,
        $settled_amount = null,
        $refunded_amount = null,
        $pending_additional_costs = null,
        $pending_additional_cost_amount = null,
        $transferred_additional_costs = null,
        $transferred_additional_cost_amount = null,
        $pending_credits = null,
        $pending_credit_amount = null,
        $transferred_credits = null,
        $transferred_credit_amount = null,
        $subscription_add_on_handle = null,
        $add_on_handle = null,
        $subscription_discount_handle = null,
        $discount_handle = null,
        $coupon_handle = null
    ) {
        list($response) = $this->getSubscriptionListWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $customer,
            $plan,
            $state,
            $amount,
            $quantity,
            $activated,
            $cancelled_date,
            $reactivated,
            $created,
            $renewing,
            $plan_version,
            $amount_incl_vat,
            $start_date,
            $end_date,
            $grace_duration,
            $current_period_start,
            $next_period_start,
            $first_period_start,
            $last_period_start,
            $trial_start,
            $trial_end,
            $in_trial,
            $has_started,
            $renewal_count,
            $expired_date,
            $expire_reason,
            $on_hold_date,
            $on_hold_reason,
            $payment_method_added,
            $reminder_email_sent,
            $failed_invoices,
            $failed_amount,
            $cancelled_invoices,
            $cancelled_amount,
            $pending_invoices,
            $pending_amount,
            $dunning_invoices,
            $dunning_amount,
            $settled_invoices,
            $settled_amount,
            $refunded_amount,
            $pending_additional_costs,
            $pending_additional_cost_amount,
            $transferred_additional_costs,
            $transferred_additional_cost_amount,
            $pending_credits,
            $pending_credit_amount,
            $transferred_credits,
            $transferred_credit_amount,
            $subscription_add_on_handle,
            $add_on_handle,
            $subscription_discount_handle,
            $discount_handle,
            $coupon_handle
        );
        return $response;
    }

    /**
     * Operation getSubscriptionListWithHttpInfo
     *
     * Get list of subscriptions
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60;, &#x60;activated&#x60;, &#x60;expired&#x60;, &#x60;cancelled&#x60;, &#x60;on_hold&#x60; or &#x60;reactivated&#x60; (optional, default to created)
     * @param string $handle Subscription handle prefix (optional)
     * @param string $handle_contains Subscription handle contains (optional)
     * @param string $customer Customer owning subscription (optional)
     * @param string $plan Plan owning subscription (optional)
     * @param string[] $state Subscription state, multiple can be defined. States: &#x60;active&#x60;, &#x60;expired&#x60;, &#x60;on_hold&#x60; or &#x60;pending&#x60; (optional)
     * @param string $amount Custom amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $quantity Quantity. See documentation of intervals. (optional)
     * @param string $activated Activated date interval (optional)
     * @param string $cancelled_date Cancelled date interval (optional)
     * @param string $reactivated Reactivated date interval (optional)
     * @param string $created Created date interval (optional)
     * @param string $renewing Renewing flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param int $plan_version Plan version (optional)
     * @param string $amount_incl_vat Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $start_date Start date interval (optional)
     * @param string $end_date End date interval (optional)
     * @param string $grace_duration Grace duration in seconds. See documentation of intervals. (optional)
     * @param string $current_period_start Current period start date interval (optional)
     * @param string $next_period_start Next period start date interval (optional)
     * @param string $first_period_start First period start date interval (optional)
     * @param string $last_period_start Last period start date interval (optional)
     * @param string $trial_start Trial period start date interval (optional)
     * @param string $trial_end Trial period end date interval (optional)
     * @param string $in_trial In trial flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $has_started Has started flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $renewal_count Renewal Count. See documentation of intervals. (optional)
     * @param string $expired_date Expired period date interval (optional)
     * @param string[] $expire_reason On hold reason, multiple can be defined. Types: &#x60;dunning&#x60;, &#x60;cancelled&#x60;,&#x60;ondemand&#x60;, and &#x60;fixed&#x60; (optional)
     * @param string $on_hold_date On hold period date interval (optional)
     * @param string[] $on_hold_reason On hold reason, multiple can be defined. Types: &#x60;ondemand&#x60;, and &#x60;dunning&#x60; (optional)
     * @param string $payment_method_added Payment method added flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $reminder_email_sent Reminder email sent period date interval (optional)
     * @param string $failed_invoices Failed invoices. See documentation of intervals. (optional)
     * @param string $failed_amount Failed amount. See documentation of intervals. (optional)
     * @param string $cancelled_invoices Cancelled invoices. See documentation of intervals. (optional)
     * @param string $cancelled_amount Cancelled amount. See documentation of intervals. (optional)
     * @param string $pending_invoices Pending invoices. See documentation of intervals. (optional)
     * @param string $pending_amount Pending amount invoices. See documentation of intervals. (optional)
     * @param string $dunning_invoices Dunning invoices. See documentation of intervals. (optional)
     * @param string $dunning_amount Dunning amount. See documentation of intervals. (optional)
     * @param string $settled_invoices Settled invoices. See documentation of intervals. (optional)
     * @param string $settled_amount Settled amount. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount. See documentation of intervals. (optional)
     * @param string $pending_additional_costs Pending additional costs. See documentation of intervals. (optional)
     * @param string $pending_additional_cost_amount Pending additional cost amount. See documentation of intervals. (optional)
     * @param string $transferred_additional_costs Transferred additional costs. See documentation of intervals. (optional)
     * @param string $transferred_additional_cost_amount Transferred additional cost amount. See documentation of intervals. (optional)
     * @param string $pending_credits Pending credits. See documentation of intervals. (optional)
     * @param string $pending_credit_amount Pending credit amount. See documentation of intervals. (optional)
     * @param string $transferred_credits Transferred credits. See documentation of intervals. (optional)
     * @param string $transferred_credit_amount Transferred credit amount. See documentation of intervals. (optional)
     * @param string $subscription_add_on_handle Subscription add-on handle (optional)
     * @param string $add_on_handle Add-on handle (optional)
     * @param string $subscription_discount_handle Subscription discount handle (optional)
     * @param string $discount_handle Discount handle (optional)
     * @param string $coupon_handle Coupon handle (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\SubscriptionList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSubscriptionListWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $customer = null,
        $plan = null,
        $state = null,
        $amount = null,
        $quantity = null,
        $activated = null,
        $cancelled_date = null,
        $reactivated = null,
        $created = null,
        $renewing = null,
        $plan_version = null,
        $amount_incl_vat = null,
        $start_date = null,
        $end_date = null,
        $grace_duration = null,
        $current_period_start = null,
        $next_period_start = null,
        $first_period_start = null,
        $last_period_start = null,
        $trial_start = null,
        $trial_end = null,
        $in_trial = null,
        $has_started = null,
        $renewal_count = null,
        $expired_date = null,
        $expire_reason = null,
        $on_hold_date = null,
        $on_hold_reason = null,
        $payment_method_added = null,
        $reminder_email_sent = null,
        $failed_invoices = null,
        $failed_amount = null,
        $cancelled_invoices = null,
        $cancelled_amount = null,
        $pending_invoices = null,
        $pending_amount = null,
        $dunning_invoices = null,
        $dunning_amount = null,
        $settled_invoices = null,
        $settled_amount = null,
        $refunded_amount = null,
        $pending_additional_costs = null,
        $pending_additional_cost_amount = null,
        $transferred_additional_costs = null,
        $transferred_additional_cost_amount = null,
        $pending_credits = null,
        $pending_credit_amount = null,
        $transferred_credits = null,
        $transferred_credit_amount = null,
        $subscription_add_on_handle = null,
        $add_on_handle = null,
        $subscription_discount_handle = null,
        $discount_handle = null,
        $coupon_handle = null
    ) {
        $returnType = '\Reepay\Model\SubscriptionList';
        $request = $this->getSubscriptionListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $customer,
            $plan,
            $state,
            $amount,
            $quantity,
            $activated,
            $cancelled_date,
            $reactivated,
            $created,
            $renewing,
            $plan_version,
            $amount_incl_vat,
            $start_date,
            $end_date,
            $grace_duration,
            $current_period_start,
            $next_period_start,
            $first_period_start,
            $last_period_start,
            $trial_start,
            $trial_end,
            $in_trial,
            $has_started,
            $renewal_count,
            $expired_date,
            $expire_reason,
            $on_hold_date,
            $on_hold_reason,
            $payment_method_added,
            $reminder_email_sent,
            $failed_invoices,
            $failed_amount,
            $cancelled_invoices,
            $cancelled_amount,
            $pending_invoices,
            $pending_amount,
            $dunning_invoices,
            $dunning_amount,
            $settled_invoices,
            $settled_amount,
            $refunded_amount,
            $pending_additional_costs,
            $pending_additional_cost_amount,
            $transferred_additional_costs,
            $transferred_additional_cost_amount,
            $pending_credits,
            $pending_credit_amount,
            $transferred_credits,
            $transferred_credit_amount,
            $subscription_add_on_handle,
            $add_on_handle,
            $subscription_discount_handle,
            $discount_handle,
            $coupon_handle
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\SubscriptionList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSubscriptionListAsync
     *
     * Get list of subscriptions
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60;, &#x60;activated&#x60;, &#x60;expired&#x60;, &#x60;cancelled&#x60;, &#x60;on_hold&#x60; or &#x60;reactivated&#x60; (optional, default to created)
     * @param string $handle Subscription handle prefix (optional)
     * @param string $handle_contains Subscription handle contains (optional)
     * @param string $customer Customer owning subscription (optional)
     * @param string $plan Plan owning subscription (optional)
     * @param string[] $state Subscription state, multiple can be defined. States: &#x60;active&#x60;, &#x60;expired&#x60;, &#x60;on_hold&#x60; or &#x60;pending&#x60; (optional)
     * @param string $amount Custom amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $quantity Quantity. See documentation of intervals. (optional)
     * @param string $activated Activated date interval (optional)
     * @param string $cancelled_date Cancelled date interval (optional)
     * @param string $reactivated Reactivated date interval (optional)
     * @param string $created Created date interval (optional)
     * @param string $renewing Renewing flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param int $plan_version Plan version (optional)
     * @param string $amount_incl_vat Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $start_date Start date interval (optional)
     * @param string $end_date End date interval (optional)
     * @param string $grace_duration Grace duration in seconds. See documentation of intervals. (optional)
     * @param string $current_period_start Current period start date interval (optional)
     * @param string $next_period_start Next period start date interval (optional)
     * @param string $first_period_start First period start date interval (optional)
     * @param string $last_period_start Last period start date interval (optional)
     * @param string $trial_start Trial period start date interval (optional)
     * @param string $trial_end Trial period end date interval (optional)
     * @param string $in_trial In trial flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $has_started Has started flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $renewal_count Renewal Count. See documentation of intervals. (optional)
     * @param string $expired_date Expired period date interval (optional)
     * @param string[] $expire_reason On hold reason, multiple can be defined. Types: &#x60;dunning&#x60;, &#x60;cancelled&#x60;,&#x60;ondemand&#x60;, and &#x60;fixed&#x60; (optional)
     * @param string $on_hold_date On hold period date interval (optional)
     * @param string[] $on_hold_reason On hold reason, multiple can be defined. Types: &#x60;ondemand&#x60;, and &#x60;dunning&#x60; (optional)
     * @param string $payment_method_added Payment method added flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $reminder_email_sent Reminder email sent period date interval (optional)
     * @param string $failed_invoices Failed invoices. See documentation of intervals. (optional)
     * @param string $failed_amount Failed amount. See documentation of intervals. (optional)
     * @param string $cancelled_invoices Cancelled invoices. See documentation of intervals. (optional)
     * @param string $cancelled_amount Cancelled amount. See documentation of intervals. (optional)
     * @param string $pending_invoices Pending invoices. See documentation of intervals. (optional)
     * @param string $pending_amount Pending amount invoices. See documentation of intervals. (optional)
     * @param string $dunning_invoices Dunning invoices. See documentation of intervals. (optional)
     * @param string $dunning_amount Dunning amount. See documentation of intervals. (optional)
     * @param string $settled_invoices Settled invoices. See documentation of intervals. (optional)
     * @param string $settled_amount Settled amount. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount. See documentation of intervals. (optional)
     * @param string $pending_additional_costs Pending additional costs. See documentation of intervals. (optional)
     * @param string $pending_additional_cost_amount Pending additional cost amount. See documentation of intervals. (optional)
     * @param string $transferred_additional_costs Transferred additional costs. See documentation of intervals. (optional)
     * @param string $transferred_additional_cost_amount Transferred additional cost amount. See documentation of intervals. (optional)
     * @param string $pending_credits Pending credits. See documentation of intervals. (optional)
     * @param string $pending_credit_amount Pending credit amount. See documentation of intervals. (optional)
     * @param string $transferred_credits Transferred credits. See documentation of intervals. (optional)
     * @param string $transferred_credit_amount Transferred credit amount. See documentation of intervals. (optional)
     * @param string $subscription_add_on_handle Subscription add-on handle (optional)
     * @param string $add_on_handle Add-on handle (optional)
     * @param string $subscription_discount_handle Subscription discount handle (optional)
     * @param string $discount_handle Discount handle (optional)
     * @param string $coupon_handle Coupon handle (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubscriptionListAsync(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $customer = null,
        $plan = null,
        $state = null,
        $amount = null,
        $quantity = null,
        $activated = null,
        $cancelled_date = null,
        $reactivated = null,
        $created = null,
        $renewing = null,
        $plan_version = null,
        $amount_incl_vat = null,
        $start_date = null,
        $end_date = null,
        $grace_duration = null,
        $current_period_start = null,
        $next_period_start = null,
        $first_period_start = null,
        $last_period_start = null,
        $trial_start = null,
        $trial_end = null,
        $in_trial = null,
        $has_started = null,
        $renewal_count = null,
        $expired_date = null,
        $expire_reason = null,
        $on_hold_date = null,
        $on_hold_reason = null,
        $payment_method_added = null,
        $reminder_email_sent = null,
        $failed_invoices = null,
        $failed_amount = null,
        $cancelled_invoices = null,
        $cancelled_amount = null,
        $pending_invoices = null,
        $pending_amount = null,
        $dunning_invoices = null,
        $dunning_amount = null,
        $settled_invoices = null,
        $settled_amount = null,
        $refunded_amount = null,
        $pending_additional_costs = null,
        $pending_additional_cost_amount = null,
        $transferred_additional_costs = null,
        $transferred_additional_cost_amount = null,
        $pending_credits = null,
        $pending_credit_amount = null,
        $transferred_credits = null,
        $transferred_credit_amount = null,
        $subscription_add_on_handle = null,
        $add_on_handle = null,
        $subscription_discount_handle = null,
        $discount_handle = null,
        $coupon_handle = null
    ) {
        return $this->getSubscriptionListAsyncWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $customer,
            $plan,
            $state,
            $amount,
            $quantity,
            $activated,
            $cancelled_date,
            $reactivated,
            $created,
            $renewing,
            $plan_version,
            $amount_incl_vat,
            $start_date,
            $end_date,
            $grace_duration,
            $current_period_start,
            $next_period_start,
            $first_period_start,
            $last_period_start,
            $trial_start,
            $trial_end,
            $in_trial,
            $has_started,
            $renewal_count,
            $expired_date,
            $expire_reason,
            $on_hold_date,
            $on_hold_reason,
            $payment_method_added,
            $reminder_email_sent,
            $failed_invoices,
            $failed_amount,
            $cancelled_invoices,
            $cancelled_amount,
            $pending_invoices,
            $pending_amount,
            $dunning_invoices,
            $dunning_amount,
            $settled_invoices,
            $settled_amount,
            $refunded_amount,
            $pending_additional_costs,
            $pending_additional_cost_amount,
            $transferred_additional_costs,
            $transferred_additional_cost_amount,
            $pending_credits,
            $pending_credit_amount,
            $transferred_credits,
            $transferred_credit_amount,
            $subscription_add_on_handle,
            $add_on_handle,
            $subscription_discount_handle,
            $discount_handle,
            $coupon_handle
        )
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSubscriptionListAsyncWithHttpInfo
     *
     * Get list of subscriptions
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60;, &#x60;activated&#x60;, &#x60;expired&#x60;, &#x60;cancelled&#x60;, &#x60;on_hold&#x60; or &#x60;reactivated&#x60; (optional, default to created)
     * @param string $handle Subscription handle prefix (optional)
     * @param string $handle_contains Subscription handle contains (optional)
     * @param string $customer Customer owning subscription (optional)
     * @param string $plan Plan owning subscription (optional)
     * @param string[] $state Subscription state, multiple can be defined. States: &#x60;active&#x60;, &#x60;expired&#x60;, &#x60;on_hold&#x60; or &#x60;pending&#x60; (optional)
     * @param string $amount Custom amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $quantity Quantity. See documentation of intervals. (optional)
     * @param string $activated Activated date interval (optional)
     * @param string $cancelled_date Cancelled date interval (optional)
     * @param string $reactivated Reactivated date interval (optional)
     * @param string $created Created date interval (optional)
     * @param string $renewing Renewing flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param int $plan_version Plan version (optional)
     * @param string $amount_incl_vat Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $start_date Start date interval (optional)
     * @param string $end_date End date interval (optional)
     * @param string $grace_duration Grace duration in seconds. See documentation of intervals. (optional)
     * @param string $current_period_start Current period start date interval (optional)
     * @param string $next_period_start Next period start date interval (optional)
     * @param string $first_period_start First period start date interval (optional)
     * @param string $last_period_start Last period start date interval (optional)
     * @param string $trial_start Trial period start date interval (optional)
     * @param string $trial_end Trial period end date interval (optional)
     * @param string $in_trial In trial flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $has_started Has started flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $renewal_count Renewal Count. See documentation of intervals. (optional)
     * @param string $expired_date Expired period date interval (optional)
     * @param string[] $expire_reason On hold reason, multiple can be defined. Types: &#x60;dunning&#x60;, &#x60;cancelled&#x60;,&#x60;ondemand&#x60;, and &#x60;fixed&#x60; (optional)
     * @param string $on_hold_date On hold period date interval (optional)
     * @param string[] $on_hold_reason On hold reason, multiple can be defined. Types: &#x60;ondemand&#x60;, and &#x60;dunning&#x60; (optional)
     * @param string $payment_method_added Payment method added flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $reminder_email_sent Reminder email sent period date interval (optional)
     * @param string $failed_invoices Failed invoices. See documentation of intervals. (optional)
     * @param string $failed_amount Failed amount. See documentation of intervals. (optional)
     * @param string $cancelled_invoices Cancelled invoices. See documentation of intervals. (optional)
     * @param string $cancelled_amount Cancelled amount. See documentation of intervals. (optional)
     * @param string $pending_invoices Pending invoices. See documentation of intervals. (optional)
     * @param string $pending_amount Pending amount invoices. See documentation of intervals. (optional)
     * @param string $dunning_invoices Dunning invoices. See documentation of intervals. (optional)
     * @param string $dunning_amount Dunning amount. See documentation of intervals. (optional)
     * @param string $settled_invoices Settled invoices. See documentation of intervals. (optional)
     * @param string $settled_amount Settled amount. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount. See documentation of intervals. (optional)
     * @param string $pending_additional_costs Pending additional costs. See documentation of intervals. (optional)
     * @param string $pending_additional_cost_amount Pending additional cost amount. See documentation of intervals. (optional)
     * @param string $transferred_additional_costs Transferred additional costs. See documentation of intervals. (optional)
     * @param string $transferred_additional_cost_amount Transferred additional cost amount. See documentation of intervals. (optional)
     * @param string $pending_credits Pending credits. See documentation of intervals. (optional)
     * @param string $pending_credit_amount Pending credit amount. See documentation of intervals. (optional)
     * @param string $transferred_credits Transferred credits. See documentation of intervals. (optional)
     * @param string $transferred_credit_amount Transferred credit amount. See documentation of intervals. (optional)
     * @param string $subscription_add_on_handle Subscription add-on handle (optional)
     * @param string $add_on_handle Add-on handle (optional)
     * @param string $subscription_discount_handle Subscription discount handle (optional)
     * @param string $discount_handle Discount handle (optional)
     * @param string $coupon_handle Coupon handle (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubscriptionListAsyncWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $customer = null,
        $plan = null,
        $state = null,
        $amount = null,
        $quantity = null,
        $activated = null,
        $cancelled_date = null,
        $reactivated = null,
        $created = null,
        $renewing = null,
        $plan_version = null,
        $amount_incl_vat = null,
        $start_date = null,
        $end_date = null,
        $grace_duration = null,
        $current_period_start = null,
        $next_period_start = null,
        $first_period_start = null,
        $last_period_start = null,
        $trial_start = null,
        $trial_end = null,
        $in_trial = null,
        $has_started = null,
        $renewal_count = null,
        $expired_date = null,
        $expire_reason = null,
        $on_hold_date = null,
        $on_hold_reason = null,
        $payment_method_added = null,
        $reminder_email_sent = null,
        $failed_invoices = null,
        $failed_amount = null,
        $cancelled_invoices = null,
        $cancelled_amount = null,
        $pending_invoices = null,
        $pending_amount = null,
        $dunning_invoices = null,
        $dunning_amount = null,
        $settled_invoices = null,
        $settled_amount = null,
        $refunded_amount = null,
        $pending_additional_costs = null,
        $pending_additional_cost_amount = null,
        $transferred_additional_costs = null,
        $transferred_additional_cost_amount = null,
        $pending_credits = null,
        $pending_credit_amount = null,
        $transferred_credits = null,
        $transferred_credit_amount = null,
        $subscription_add_on_handle = null,
        $add_on_handle = null,
        $subscription_discount_handle = null,
        $discount_handle = null,
        $coupon_handle = null
    ) {
        $returnType = '\Reepay\Model\SubscriptionList';
        $request = $this->getSubscriptionListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $handle,
            $handle_contains,
            $customer,
            $plan,
            $state,
            $amount,
            $quantity,
            $activated,
            $cancelled_date,
            $reactivated,
            $created,
            $renewing,
            $plan_version,
            $amount_incl_vat,
            $start_date,
            $end_date,
            $grace_duration,
            $current_period_start,
            $next_period_start,
            $first_period_start,
            $last_period_start,
            $trial_start,
            $trial_end,
            $in_trial,
            $has_started,
            $renewal_count,
            $expired_date,
            $expire_reason,
            $on_hold_date,
            $on_hold_reason,
            $payment_method_added,
            $reminder_email_sent,
            $failed_invoices,
            $failed_amount,
            $cancelled_invoices,
            $cancelled_amount,
            $pending_invoices,
            $pending_amount,
            $dunning_invoices,
            $dunning_amount,
            $settled_invoices,
            $settled_amount,
            $refunded_amount,
            $pending_additional_costs,
            $pending_additional_cost_amount,
            $transferred_additional_costs,
            $transferred_additional_cost_amount,
            $pending_credits,
            $pending_credit_amount,
            $transferred_credits,
            $transferred_credit_amount,
            $subscription_add_on_handle,
            $add_on_handle,
            $subscription_discount_handle,
            $discount_handle,
            $coupon_handle
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSubscriptionList'
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Can be the &#x60;created&#x60;, &#x60;activated&#x60;, &#x60;expired&#x60;, &#x60;cancelled&#x60;, &#x60;on_hold&#x60; or &#x60;reactivated&#x60; (optional, default to created)
     * @param string $handle Subscription handle prefix (optional)
     * @param string $handle_contains Subscription handle contains (optional)
     * @param string $customer Customer owning subscription (optional)
     * @param string $plan Plan owning subscription (optional)
     * @param string[] $state Subscription state, multiple can be defined. States: &#x60;active&#x60;, &#x60;expired&#x60;, &#x60;on_hold&#x60; or &#x60;pending&#x60; (optional)
     * @param string $amount Custom amount in minor unit interval. See documentation of intervals. (optional)
     * @param string $quantity Quantity. See documentation of intervals. (optional)
     * @param string $activated Activated date interval (optional)
     * @param string $cancelled_date Cancelled date interval (optional)
     * @param string $reactivated Reactivated date interval (optional)
     * @param string $created Created date interval (optional)
     * @param string $renewing Renewing flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param int $plan_version Plan version (optional)
     * @param string $amount_incl_vat Amount incl vat test flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $start_date Start date interval (optional)
     * @param string $end_date End date interval (optional)
     * @param string $grace_duration Grace duration in seconds. See documentation of intervals. (optional)
     * @param string $current_period_start Current period start date interval (optional)
     * @param string $next_period_start Next period start date interval (optional)
     * @param string $first_period_start First period start date interval (optional)
     * @param string $last_period_start Last period start date interval (optional)
     * @param string $trial_start Trial period start date interval (optional)
     * @param string $trial_end Trial period end date interval (optional)
     * @param string $in_trial In trial flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $has_started Has started flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $renewal_count Renewal Count. See documentation of intervals. (optional)
     * @param string $expired_date Expired period date interval (optional)
     * @param string[] $expire_reason On hold reason, multiple can be defined. Types: &#x60;dunning&#x60;, &#x60;cancelled&#x60;,&#x60;ondemand&#x60;, and &#x60;fixed&#x60; (optional)
     * @param string $on_hold_date On hold period date interval (optional)
     * @param string[] $on_hold_reason On hold reason, multiple can be defined. Types: &#x60;ondemand&#x60;, and &#x60;dunning&#x60; (optional)
     * @param string $payment_method_added Payment method added flag. Values: &#x60;true&#x60; or &#x60;false&#x60; (optional)
     * @param string $reminder_email_sent Reminder email sent period date interval (optional)
     * @param string $failed_invoices Failed invoices. See documentation of intervals. (optional)
     * @param string $failed_amount Failed amount. See documentation of intervals. (optional)
     * @param string $cancelled_invoices Cancelled invoices. See documentation of intervals. (optional)
     * @param string $cancelled_amount Cancelled amount. See documentation of intervals. (optional)
     * @param string $pending_invoices Pending invoices. See documentation of intervals. (optional)
     * @param string $pending_amount Pending amount invoices. See documentation of intervals. (optional)
     * @param string $dunning_invoices Dunning invoices. See documentation of intervals. (optional)
     * @param string $dunning_amount Dunning amount. See documentation of intervals. (optional)
     * @param string $settled_invoices Settled invoices. See documentation of intervals. (optional)
     * @param string $settled_amount Settled amount. See documentation of intervals. (optional)
     * @param string $refunded_amount Refunded amount. See documentation of intervals. (optional)
     * @param string $pending_additional_costs Pending additional costs. See documentation of intervals. (optional)
     * @param string $pending_additional_cost_amount Pending additional cost amount. See documentation of intervals. (optional)
     * @param string $transferred_additional_costs Transferred additional costs. See documentation of intervals. (optional)
     * @param string $transferred_additional_cost_amount Transferred additional cost amount. See documentation of intervals. (optional)
     * @param string $pending_credits Pending credits. See documentation of intervals. (optional)
     * @param string $pending_credit_amount Pending credit amount. See documentation of intervals. (optional)
     * @param string $transferred_credits Transferred credits. See documentation of intervals. (optional)
     * @param string $transferred_credit_amount Transferred credit amount. See documentation of intervals. (optional)
     * @param string $subscription_add_on_handle Subscription add-on handle (optional)
     * @param string $add_on_handle Add-on handle (optional)
     * @param string $subscription_discount_handle Subscription discount handle (optional)
     * @param string $discount_handle Discount handle (optional)
     * @param string $coupon_handle Coupon handle (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSubscriptionListRequest(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $handle = null,
        $handle_contains = null,
        $customer = null,
        $plan = null,
        $state = null,
        $amount = null,
        $quantity = null,
        $activated = null,
        $cancelled_date = null,
        $reactivated = null,
        $created = null,
        $renewing = null,
        $plan_version = null,
        $amount_incl_vat = null,
        $start_date = null,
        $end_date = null,
        $grace_duration = null,
        $current_period_start = null,
        $next_period_start = null,
        $first_period_start = null,
        $last_period_start = null,
        $trial_start = null,
        $trial_end = null,
        $in_trial = null,
        $has_started = null,
        $renewal_count = null,
        $expired_date = null,
        $expire_reason = null,
        $on_hold_date = null,
        $on_hold_reason = null,
        $payment_method_added = null,
        $reminder_email_sent = null,
        $failed_invoices = null,
        $failed_amount = null,
        $cancelled_invoices = null,
        $cancelled_amount = null,
        $pending_invoices = null,
        $pending_amount = null,
        $dunning_invoices = null,
        $dunning_amount = null,
        $settled_invoices = null,
        $settled_amount = null,
        $refunded_amount = null,
        $pending_additional_costs = null,
        $pending_additional_cost_amount = null,
        $transferred_additional_costs = null,
        $transferred_additional_cost_amount = null,
        $pending_credits = null,
        $pending_credit_amount = null,
        $transferred_credits = null,
        $transferred_credit_amount = null,
        $subscription_add_on_handle = null,
        $add_on_handle = null,
        $subscription_discount_handle = null,
        $discount_handle = null,
        $coupon_handle = null
    ) {
        $resourcePath = '/v1/list/subscription';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($next_page_token !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($next_page_token, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if ($handle !== null) {
            $queryParams['handle'] = ObjectSerializer::toQueryValue($handle, null);
        }
        // query params
        if ($handle_contains !== null) {
            $queryParams['handle_contains'] = ObjectSerializer::toQueryValue($handle_contains, null);
        }
        // query params
        if ($customer !== null) {
            $queryParams['customer'] = ObjectSerializer::toQueryValue($customer, null);
        }
        // query params
        if ($plan !== null) {
            $queryParams['plan'] = ObjectSerializer::toQueryValue($plan, null);
        }
        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, 'multi', true);
        }
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if ($quantity !== null) {
            $queryParams['quantity'] = ObjectSerializer::toQueryValue($quantity, null);
        }
        // query params
        if ($activated !== null) {
            $queryParams['activated'] = ObjectSerializer::toQueryValue($activated, null);
        }
        // query params
        if ($cancelled_date !== null) {
            $queryParams['cancelled_date'] = ObjectSerializer::toQueryValue($cancelled_date, null);
        }
        // query params
        if ($reactivated !== null) {
            $queryParams['reactivated'] = ObjectSerializer::toQueryValue($reactivated, null);
        }
        // query params
        if ($created !== null) {
            $queryParams['created'] = ObjectSerializer::toQueryValue($created, null);
        }
        // query params
        if ($renewing !== null) {
            $queryParams['renewing'] = ObjectSerializer::toQueryValue($renewing, null);
        }
        // query params
        if ($plan_version !== null) {
            $queryParams['plan_version'] = ObjectSerializer::toQueryValue($plan_version, 'int32');
        }
        // query params
        if ($amount_incl_vat !== null) {
            $queryParams['amount_incl_vat'] = ObjectSerializer::toQueryValue($amount_incl_vat, null);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['start_date'] = ObjectSerializer::toQueryValue($start_date, null);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['end_date'] = ObjectSerializer::toQueryValue($end_date, null);
        }
        // query params
        if ($grace_duration !== null) {
            $queryParams['grace_duration'] = ObjectSerializer::toQueryValue($grace_duration, null);
        }
        // query params
        if ($current_period_start !== null) {
            $queryParams['current_period_start'] = ObjectSerializer::toQueryValue($current_period_start, null);
        }
        // query params
        if ($next_period_start !== null) {
            $queryParams['next_period_start'] = ObjectSerializer::toQueryValue($next_period_start, null);
        }
        // query params
        if ($first_period_start !== null) {
            $queryParams['first_period_start'] = ObjectSerializer::toQueryValue($first_period_start, null);
        }
        // query params
        if ($last_period_start !== null) {
            $queryParams['last_period_start'] = ObjectSerializer::toQueryValue($last_period_start, null);
        }
        // query params
        if ($trial_start !== null) {
            $queryParams['trial_start'] = ObjectSerializer::toQueryValue($trial_start, null);
        }
        // query params
        if ($trial_end !== null) {
            $queryParams['trial_end'] = ObjectSerializer::toQueryValue($trial_end, null);
        }
        // query params
        if ($in_trial !== null) {
            $queryParams['in_trial'] = ObjectSerializer::toQueryValue($in_trial, null);
        }
        // query params
        if ($has_started !== null) {
            $queryParams['has_started'] = ObjectSerializer::toQueryValue($has_started, null);
        }
        // query params
        if ($renewal_count !== null) {
            $queryParams['renewal_count'] = ObjectSerializer::toQueryValue($renewal_count, null);
        }
        // query params
        if ($expired_date !== null) {
            $queryParams['expired_date'] = ObjectSerializer::toQueryValue($expired_date, null);
        }
        // query params
        if (is_array($expire_reason)) {
            $expire_reason = ObjectSerializer::serializeCollection($expire_reason, 'multi', true);
        }
        if ($expire_reason !== null) {
            $queryParams['expire_reason'] = ObjectSerializer::toQueryValue($expire_reason, null);
        }
        // query params
        if ($on_hold_date !== null) {
            $queryParams['on_hold_date'] = ObjectSerializer::toQueryValue($on_hold_date, null);
        }
        // query params
        if (is_array($on_hold_reason)) {
            $on_hold_reason = ObjectSerializer::serializeCollection($on_hold_reason, 'multi', true);
        }
        if ($on_hold_reason !== null) {
            $queryParams['on_hold_reason'] = ObjectSerializer::toQueryValue($on_hold_reason, null);
        }
        // query params
        if ($payment_method_added !== null) {
            $queryParams['payment_method_added'] = ObjectSerializer::toQueryValue($payment_method_added, null);
        }
        // query params
        if ($reminder_email_sent !== null) {
            $queryParams['reminder_email_sent'] = ObjectSerializer::toQueryValue($reminder_email_sent, null);
        }
        // query params
        if ($failed_invoices !== null) {
            $queryParams['failed_invoices'] = ObjectSerializer::toQueryValue($failed_invoices, null);
        }
        // query params
        if ($failed_amount !== null) {
            $queryParams['failed_amount'] = ObjectSerializer::toQueryValue($failed_amount, null);
        }
        // query params
        if ($cancelled_invoices !== null) {
            $queryParams['cancelled_invoices'] = ObjectSerializer::toQueryValue($cancelled_invoices, null);
        }
        // query params
        if ($cancelled_amount !== null) {
            $queryParams['cancelled_amount'] = ObjectSerializer::toQueryValue($cancelled_amount, null);
        }
        // query params
        if ($pending_invoices !== null) {
            $queryParams['pending_invoices'] = ObjectSerializer::toQueryValue($pending_invoices, null);
        }
        // query params
        if ($pending_amount !== null) {
            $queryParams['pending_amount'] = ObjectSerializer::toQueryValue($pending_amount, null);
        }
        // query params
        if ($dunning_invoices !== null) {
            $queryParams['dunning_invoices'] = ObjectSerializer::toQueryValue($dunning_invoices, null);
        }
        // query params
        if ($dunning_amount !== null) {
            $queryParams['dunning_amount'] = ObjectSerializer::toQueryValue($dunning_amount, null);
        }
        // query params
        if ($settled_invoices !== null) {
            $queryParams['settled_invoices'] = ObjectSerializer::toQueryValue($settled_invoices, null);
        }
        // query params
        if ($settled_amount !== null) {
            $queryParams['settled_amount'] = ObjectSerializer::toQueryValue($settled_amount, null);
        }
        // query params
        if ($refunded_amount !== null) {
            $queryParams['refunded_amount'] = ObjectSerializer::toQueryValue($refunded_amount, null);
        }
        // query params
        if ($pending_additional_costs !== null) {
            $queryParams['pending_additional_costs'] = ObjectSerializer::toQueryValue($pending_additional_costs, null);
        }
        // query params
        if ($pending_additional_cost_amount !== null) {
            $queryParams['pending_additional_cost_amount'] = ObjectSerializer::toQueryValue(
                $pending_additional_cost_amount,
                null
            );
        }
        // query params
        if ($transferred_additional_costs !== null) {
            $queryParams['transferred_additional_costs'] = ObjectSerializer::toQueryValue(
                $transferred_additional_costs,
                null
            );
        }
        // query params
        if ($transferred_additional_cost_amount !== null) {
            $queryParams['transferred_additional_cost_amount'] = ObjectSerializer::toQueryValue(
                $transferred_additional_cost_amount,
                null
            );
        }
        // query params
        if ($pending_credits !== null) {
            $queryParams['pending_credits'] = ObjectSerializer::toQueryValue($pending_credits, null);
        }
        // query params
        if ($pending_credit_amount !== null) {
            $queryParams['pending_credit_amount'] = ObjectSerializer::toQueryValue($pending_credit_amount, null);
        }
        // query params
        if ($transferred_credits !== null) {
            $queryParams['transferred_credits'] = ObjectSerializer::toQueryValue($transferred_credits, null);
        }
        // query params
        if ($transferred_credit_amount !== null) {
            $queryParams['transferred_credit_amount'] = ObjectSerializer::toQueryValue(
                $transferred_credit_amount,
                null
            );
        }
        // query params
        if ($subscription_add_on_handle !== null) {
            $queryParams['subscription_add_on_handle'] = ObjectSerializer::toQueryValue(
                $subscription_add_on_handle,
                null
            );
        }
        // query params
        if ($add_on_handle !== null) {
            $queryParams['add_on_handle'] = ObjectSerializer::toQueryValue($add_on_handle, null);
        }
        // query params
        if ($subscription_discount_handle !== null) {
            $queryParams['subscription_discount_handle'] = ObjectSerializer::toQueryValue(
                $subscription_discount_handle,
                null
            );
        }
        // query params
        if ($discount_handle !== null) {
            $queryParams['discount_handle'] = ObjectSerializer::toQueryValue($discount_handle, null);
        }
        // query params
        if ($coupon_handle !== null) {
            $queryParams['coupon_handle'] = ObjectSerializer::toQueryValue($coupon_handle, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransactionList
     *
     * Get list of transactions
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60;, &#x60;settled&#x60;, &#x60;authorized&#x60;, &#x60;refunded&#x60; or &#x60;failed&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string[] $type Transaction type, multiple can be defined. Types: &#x60;settle&#x60;, &#x60;refund&#x60; and &#x60;authorization&#x60; (optional)
     * @param string[] $state Transaction state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;authorized&#x60;, &#x60;processing&#x60;, &#x60;settled&#x60;, &#x60;refunded&#x60;, &#x60;failed&#x60; and &#x60;cancelled&#x60; (optional)
     * @param string[] $payment_type Transaction payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param string $invoice Transactions for invoice by invoice handle (optional)
     * @param string[] $currency Currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $card_type Transactions for card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string[] $transaction_card_type Transactions with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string $card_prefix Transactions for card with prefix (optional)
     * @param string $card_postfix Transactions for card with postfix (optional)
     * @param string $card_fingerprint Transactions for card with postfix (optional)
     * @param string[] $card_country Transactions with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param string $card_gateway Transactions with card gateway. (optional)
     * @param string $payment_method Transactions using saved payment method (optional)
     * @param string $card_acquirer_code Transaction using card acquirer code (optional)
     * @param string $card_error_state Transactions with card error state. &#x60;pending&#x60;, &#x60;accepted&#x60;, &#x60;soft_declined&#x60;, &#x60;hard_declined&#x60;, or &#x60;processing_error&#x60; (optional)
     * @param string $card_error Transactions with card error state. &#x60;credit_card_expired&#x60;, &#x60;insufficient_funds&#x60;, &#x60;declined_by_acquirer&#x60;, &#x60;acquirer_communication_error&#x60;, &#x60;acquirer_error&#x60;, &#x60;acquirer_integration_error&#x60;, &#x60;acquirer_authentication_error&#x60;, &#x60;acquirer_configuration_error&#x60;, &#x60;acquirer_rejected_error&#x60;, &#x60;card_identifier_not_found&#x60;, &#x60;refund_amount_too_high&#x60;, &#x60;credit_card_lost_or_stolen&#x60;, &#x60;credit_card_suspected_fraud&#x60;, &#x60;authorization_expired&#x60;, &#x60;authorization_amount_exceeded&#x60;, &#x60;authorization_voided&#x60;, &#x60;settle_blocked&#x60;, &#x60;sca_required&#x60;, &#x60;risk_filter_block&#x60;, or &#x60;fraud_block&#x60; (optional)
     * @param string $payment_context Transaction payment context: cit - customer initiated, cit-cof customer initiated using stored information or mit - merchant initiated (optional)
     * @param string $card_acquirer_reference Transaction with card acquirer reference (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Reepay\Model\TransactionList
     */
    public function getTransactionList(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $type = null,
        $state = null,
        $payment_type = null,
        $invoice = null,
        $currency = null,
        $amount = null,
        $card_type = null,
        $transaction_card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null,
        $card_country = null,
        $card_gateway = null,
        $payment_method = null,
        $card_acquirer_code = null,
        $card_error_state = null,
        $card_error = null,
        $payment_context = null,
        $card_acquirer_reference = null
    ) {
        list($response) = $this->getTransactionListWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $type,
            $state,
            $payment_type,
            $invoice,
            $currency,
            $amount,
            $card_type,
            $transaction_card_type,
            $card_prefix,
            $card_postfix,
            $card_fingerprint,
            $card_country,
            $card_gateway,
            $payment_method,
            $card_acquirer_code,
            $card_error_state,
            $card_error,
            $payment_context,
            $card_acquirer_reference
        );
        return $response;
    }

    /**
     * Operation getTransactionListWithHttpInfo
     *
     * Get list of transactions
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60;, &#x60;settled&#x60;, &#x60;authorized&#x60;, &#x60;refunded&#x60; or &#x60;failed&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string[] $type Transaction type, multiple can be defined. Types: &#x60;settle&#x60;, &#x60;refund&#x60; and &#x60;authorization&#x60; (optional)
     * @param string[] $state Transaction state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;authorized&#x60;, &#x60;processing&#x60;, &#x60;settled&#x60;, &#x60;refunded&#x60;, &#x60;failed&#x60; and &#x60;cancelled&#x60; (optional)
     * @param string[] $payment_type Transaction payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param string $invoice Transactions for invoice by invoice handle (optional)
     * @param string[] $currency Currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $card_type Transactions for card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string[] $transaction_card_type Transactions with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string $card_prefix Transactions for card with prefix (optional)
     * @param string $card_postfix Transactions for card with postfix (optional)
     * @param string $card_fingerprint Transactions for card with postfix (optional)
     * @param string[] $card_country Transactions with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param string $card_gateway Transactions with card gateway. (optional)
     * @param string $payment_method Transactions using saved payment method (optional)
     * @param string $card_acquirer_code Transaction using card acquirer code (optional)
     * @param string $card_error_state Transactions with card error state. &#x60;pending&#x60;, &#x60;accepted&#x60;, &#x60;soft_declined&#x60;, &#x60;hard_declined&#x60;, or &#x60;processing_error&#x60; (optional)
     * @param string $card_error Transactions with card error state. &#x60;credit_card_expired&#x60;, &#x60;insufficient_funds&#x60;, &#x60;declined_by_acquirer&#x60;, &#x60;acquirer_communication_error&#x60;, &#x60;acquirer_error&#x60;, &#x60;acquirer_integration_error&#x60;, &#x60;acquirer_authentication_error&#x60;, &#x60;acquirer_configuration_error&#x60;, &#x60;acquirer_rejected_error&#x60;, &#x60;card_identifier_not_found&#x60;, &#x60;refund_amount_too_high&#x60;, &#x60;credit_card_lost_or_stolen&#x60;, &#x60;credit_card_suspected_fraud&#x60;, &#x60;authorization_expired&#x60;, &#x60;authorization_amount_exceeded&#x60;, &#x60;authorization_voided&#x60;, &#x60;settle_blocked&#x60;, &#x60;sca_required&#x60;, &#x60;risk_filter_block&#x60;, or &#x60;fraud_block&#x60; (optional)
     * @param string $payment_context Transaction payment context: cit - customer initiated, cit-cof customer initiated using stored information or mit - merchant initiated (optional)
     * @param string $card_acquirer_reference Transaction with card acquirer reference (optional)
     *
     * @throws \Reepay\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Reepay\Model\TransactionList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransactionListWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $type = null,
        $state = null,
        $payment_type = null,
        $invoice = null,
        $currency = null,
        $amount = null,
        $card_type = null,
        $transaction_card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null,
        $card_country = null,
        $card_gateway = null,
        $payment_method = null,
        $card_acquirer_code = null,
        $card_error_state = null,
        $card_error = null,
        $payment_context = null,
        $card_acquirer_reference = null
    ) {
        $returnType = '\Reepay\Model\TransactionList';
        $request = $this->getTransactionListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $type,
            $state,
            $payment_type,
            $invoice,
            $currency,
            $amount,
            $card_type,
            $transaction_card_type,
            $card_prefix,
            $card_postfix,
            $card_fingerprint,
            $card_country,
            $card_gateway,
            $payment_method,
            $card_acquirer_code,
            $card_error_state,
            $card_error,
            $payment_context,
            $card_acquirer_reference
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\TransactionList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Reepay\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTransactionListAsync
     *
     * Get list of transactions
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60;, &#x60;settled&#x60;, &#x60;authorized&#x60;, &#x60;refunded&#x60; or &#x60;failed&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string[] $type Transaction type, multiple can be defined. Types: &#x60;settle&#x60;, &#x60;refund&#x60; and &#x60;authorization&#x60; (optional)
     * @param string[] $state Transaction state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;authorized&#x60;, &#x60;processing&#x60;, &#x60;settled&#x60;, &#x60;refunded&#x60;, &#x60;failed&#x60; and &#x60;cancelled&#x60; (optional)
     * @param string[] $payment_type Transaction payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param string $invoice Transactions for invoice by invoice handle (optional)
     * @param string[] $currency Currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $card_type Transactions for card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string[] $transaction_card_type Transactions with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string $card_prefix Transactions for card with prefix (optional)
     * @param string $card_postfix Transactions for card with postfix (optional)
     * @param string $card_fingerprint Transactions for card with postfix (optional)
     * @param string[] $card_country Transactions with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param string $card_gateway Transactions with card gateway. (optional)
     * @param string $payment_method Transactions using saved payment method (optional)
     * @param string $card_acquirer_code Transaction using card acquirer code (optional)
     * @param string $card_error_state Transactions with card error state. &#x60;pending&#x60;, &#x60;accepted&#x60;, &#x60;soft_declined&#x60;, &#x60;hard_declined&#x60;, or &#x60;processing_error&#x60; (optional)
     * @param string $card_error Transactions with card error state. &#x60;credit_card_expired&#x60;, &#x60;insufficient_funds&#x60;, &#x60;declined_by_acquirer&#x60;, &#x60;acquirer_communication_error&#x60;, &#x60;acquirer_error&#x60;, &#x60;acquirer_integration_error&#x60;, &#x60;acquirer_authentication_error&#x60;, &#x60;acquirer_configuration_error&#x60;, &#x60;acquirer_rejected_error&#x60;, &#x60;card_identifier_not_found&#x60;, &#x60;refund_amount_too_high&#x60;, &#x60;credit_card_lost_or_stolen&#x60;, &#x60;credit_card_suspected_fraud&#x60;, &#x60;authorization_expired&#x60;, &#x60;authorization_amount_exceeded&#x60;, &#x60;authorization_voided&#x60;, &#x60;settle_blocked&#x60;, &#x60;sca_required&#x60;, &#x60;risk_filter_block&#x60;, or &#x60;fraud_block&#x60; (optional)
     * @param string $payment_context Transaction payment context: cit - customer initiated, cit-cof customer initiated using stored information or mit - merchant initiated (optional)
     * @param string $card_acquirer_reference Transaction with card acquirer reference (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionListAsync(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $type = null,
        $state = null,
        $payment_type = null,
        $invoice = null,
        $currency = null,
        $amount = null,
        $card_type = null,
        $transaction_card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null,
        $card_country = null,
        $card_gateway = null,
        $payment_method = null,
        $card_acquirer_code = null,
        $card_error_state = null,
        $card_error = null,
        $payment_context = null,
        $card_acquirer_reference = null
    ) {
        return $this->getTransactionListAsyncWithHttpInfo(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $type,
            $state,
            $payment_type,
            $invoice,
            $currency,
            $amount,
            $card_type,
            $transaction_card_type,
            $card_prefix,
            $card_postfix,
            $card_fingerprint,
            $card_country,
            $card_gateway,
            $payment_method,
            $card_acquirer_code,
            $card_error_state,
            $card_error,
            $payment_context,
            $card_acquirer_reference
        )
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransactionListAsyncWithHttpInfo
     *
     * Get list of transactions
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60;, &#x60;settled&#x60;, &#x60;authorized&#x60;, &#x60;refunded&#x60; or &#x60;failed&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string[] $type Transaction type, multiple can be defined. Types: &#x60;settle&#x60;, &#x60;refund&#x60; and &#x60;authorization&#x60; (optional)
     * @param string[] $state Transaction state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;authorized&#x60;, &#x60;processing&#x60;, &#x60;settled&#x60;, &#x60;refunded&#x60;, &#x60;failed&#x60; and &#x60;cancelled&#x60; (optional)
     * @param string[] $payment_type Transaction payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param string $invoice Transactions for invoice by invoice handle (optional)
     * @param string[] $currency Currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $card_type Transactions for card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string[] $transaction_card_type Transactions with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string $card_prefix Transactions for card with prefix (optional)
     * @param string $card_postfix Transactions for card with postfix (optional)
     * @param string $card_fingerprint Transactions for card with postfix (optional)
     * @param string[] $card_country Transactions with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param string $card_gateway Transactions with card gateway. (optional)
     * @param string $payment_method Transactions using saved payment method (optional)
     * @param string $card_acquirer_code Transaction using card acquirer code (optional)
     * @param string $card_error_state Transactions with card error state. &#x60;pending&#x60;, &#x60;accepted&#x60;, &#x60;soft_declined&#x60;, &#x60;hard_declined&#x60;, or &#x60;processing_error&#x60; (optional)
     * @param string $card_error Transactions with card error state. &#x60;credit_card_expired&#x60;, &#x60;insufficient_funds&#x60;, &#x60;declined_by_acquirer&#x60;, &#x60;acquirer_communication_error&#x60;, &#x60;acquirer_error&#x60;, &#x60;acquirer_integration_error&#x60;, &#x60;acquirer_authentication_error&#x60;, &#x60;acquirer_configuration_error&#x60;, &#x60;acquirer_rejected_error&#x60;, &#x60;card_identifier_not_found&#x60;, &#x60;refund_amount_too_high&#x60;, &#x60;credit_card_lost_or_stolen&#x60;, &#x60;credit_card_suspected_fraud&#x60;, &#x60;authorization_expired&#x60;, &#x60;authorization_amount_exceeded&#x60;, &#x60;authorization_voided&#x60;, &#x60;settle_blocked&#x60;, &#x60;sca_required&#x60;, &#x60;risk_filter_block&#x60;, or &#x60;fraud_block&#x60; (optional)
     * @param string $payment_context Transaction payment context: cit - customer initiated, cit-cof customer initiated using stored information or mit - merchant initiated (optional)
     * @param string $card_acquirer_reference Transaction with card acquirer reference (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionListAsyncWithHttpInfo(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $type = null,
        $state = null,
        $payment_type = null,
        $invoice = null,
        $currency = null,
        $amount = null,
        $card_type = null,
        $transaction_card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null,
        $card_country = null,
        $card_gateway = null,
        $payment_method = null,
        $card_acquirer_code = null,
        $card_error_state = null,
        $card_error = null,
        $payment_context = null,
        $card_acquirer_reference = null
    ) {
        $returnType = '\Reepay\Model\TransactionList';
        $request = $this->getTransactionListRequest(
            $from,
            $to,
            $interval,
            $size,
            $next_page_token,
            $range,
            $type,
            $state,
            $payment_type,
            $invoice,
            $currency,
            $amount,
            $card_type,
            $transaction_card_type,
            $card_prefix,
            $card_postfix,
            $card_fingerprint,
            $card_country,
            $card_gateway,
            $payment_method,
            $card_acquirer_code,
            $card_error_state,
            $card_error,
            $payment_context,
            $card_acquirer_reference
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransactionList'
     *
     * @param string $from Time range from (inclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Default from if no &#x60;interval&#x60; is given depends on the query. If the query limits on relation e.g. customer and/or subscription, the default from will be epoch 1970-01-01, otherwise one month before &#x60;to&#x60; (optional)
     * @param string $to Time range to (exclusive). Local date and time (according to account timezone) on the form &#x60;yyyy-MM-dd&#x60;, &#x60;yyyyMMdd&#x60;, &#x60;yyyy-MM-ddTHH:mm&#x60;, &#x60;yyyy-MM-ddTHH:mm:ss&#x60; or &#x60;yyyy-MM-ddTHH:mm:ss.SSS&#x60;. Defaults to now. (optional)
     * @param string $interval Limit from &#x60;to&#x60; and interval back in time. E.g. one week. Will take precedence over &#x60;from&#x60;. Defined in ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations (optional)
     * @param int $size Page size between 10 and 100 (default 20) (optional, default to 20)
     * @param string $next_page_token Next page token from previous response to get next page (optional)
     * @param string $range Time and date attribute to time limit. Either &#x60;created&#x60;, &#x60;settled&#x60;, &#x60;authorized&#x60;, &#x60;refunded&#x60; or &#x60;failed&#x60;. Default is &#x60;created&#x60;. (optional, default to created)
     * @param string[] $type Transaction type, multiple can be defined. Types: &#x60;settle&#x60;, &#x60;refund&#x60; and &#x60;authorization&#x60; (optional)
     * @param string[] $state Transaction state, multiple can be defined. States: &#x60;pending&#x60;, &#x60;authorized&#x60;, &#x60;processing&#x60;, &#x60;settled&#x60;, &#x60;refunded&#x60;, &#x60;failed&#x60; and &#x60;cancelled&#x60; (optional)
     * @param string[] $payment_type Transaction payment type, multiple can be defined. &#x60;card&#x60;, &#x60;mobilepay&#x60;, &#x60;vipps&#x60;, &#x60;swish&#x60;, &#x60;viabill&#x60;, &#x60;manual&#x60;, &#x60;applepay&#x60;, &#x60;googlepay&#x60;, &#x60;paypal&#x60;, &#x60;klarna_pay_now&#x60;, &#x60;klarna_pay_later&#x60;, &#x60;klarna_slice_it&#x60;, &#x60;klarna_direct_bank_transfer&#x60;, &#x60;klarna_direct_debit&#x60;, &#x60;resurs&#x60;, &#x60;ideal&#x60;, &#x60;p24&#x60;, &#x60;blik&#x60;, &#x60;bancontact&#x60;, &#x60;giropay&#x60;, &#x60;sepa&#x60;, &#x60;verkkopankki&#x60; or &#x60;mobilepay_subscriptions&#x60; (optional)
     * @param string $invoice Transactions for invoice by invoice handle (optional)
     * @param string[] $currency Currency in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code. Multiple can be defined. (optional)
     * @param string $amount Amount in minor unit interval. See documentation of intervals. (optional)
     * @param string[] $card_type Transactions for card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string[] $transaction_card_type Transactions with transaction card type. Multiple can be defined. &#x60;unknown&#x60;, &#x60;visa&#x60;, &#x60;mc&#x60;, &#x60;dankort&#x60;, &#x60;visa_dk&#x60;, &#x60;ffk&#x60;, &#x60;visa_elec&#x60;, &#x60;maestro&#x60;, &#x60;laser&#x60;, &#x60;amex&#x60;, &#x60;diners&#x60;, &#x60;discover&#x60; or &#x60;jcb&#x60; (optional)
     * @param string $card_prefix Transactions for card with prefix (optional)
     * @param string $card_postfix Transactions for card with postfix (optional)
     * @param string $card_fingerprint Transactions for card with postfix (optional)
     * @param string[] $card_country Transactions with card country. Multiple can be defined. In  in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). (optional)
     * @param string $card_gateway Transactions with card gateway. (optional)
     * @param string $payment_method Transactions using saved payment method (optional)
     * @param string $card_acquirer_code Transaction using card acquirer code (optional)
     * @param string $card_error_state Transactions with card error state. &#x60;pending&#x60;, &#x60;accepted&#x60;, &#x60;soft_declined&#x60;, &#x60;hard_declined&#x60;, or &#x60;processing_error&#x60; (optional)
     * @param string $card_error Transactions with card error state. &#x60;credit_card_expired&#x60;, &#x60;insufficient_funds&#x60;, &#x60;declined_by_acquirer&#x60;, &#x60;acquirer_communication_error&#x60;, &#x60;acquirer_error&#x60;, &#x60;acquirer_integration_error&#x60;, &#x60;acquirer_authentication_error&#x60;, &#x60;acquirer_configuration_error&#x60;, &#x60;acquirer_rejected_error&#x60;, &#x60;card_identifier_not_found&#x60;, &#x60;refund_amount_too_high&#x60;, &#x60;credit_card_lost_or_stolen&#x60;, &#x60;credit_card_suspected_fraud&#x60;, &#x60;authorization_expired&#x60;, &#x60;authorization_amount_exceeded&#x60;, &#x60;authorization_voided&#x60;, &#x60;settle_blocked&#x60;, &#x60;sca_required&#x60;, &#x60;risk_filter_block&#x60;, or &#x60;fraud_block&#x60; (optional)
     * @param string $payment_context Transaction payment context: cit - customer initiated, cit-cof customer initiated using stored information or mit - merchant initiated (optional)
     * @param string $card_acquirer_reference Transaction with card acquirer reference (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTransactionListRequest(
        $from = null,
        $to = null,
        $interval = null,
        $size = '20',
        $next_page_token = null,
        $range = 'created',
        $type = null,
        $state = null,
        $payment_type = null,
        $invoice = null,
        $currency = null,
        $amount = null,
        $card_type = null,
        $transaction_card_type = null,
        $card_prefix = null,
        $card_postfix = null,
        $card_fingerprint = null,
        $card_country = null,
        $card_gateway = null,
        $payment_method = null,
        $card_acquirer_code = null,
        $card_error_state = null,
        $card_error = null,
        $payment_context = null,
        $card_acquirer_reference = null
    ) {
        $resourcePath = '/v1/list/transaction';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, null);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, null);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($next_page_token !== null) {
            $queryParams['next_page_token'] = ObjectSerializer::toQueryValue($next_page_token, null);
        }
        // query params
        if ($range !== null) {
            $queryParams['range'] = ObjectSerializer::toQueryValue($range, null);
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, 'multi', true);
        }
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, 'multi', true);
        }
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state, null);
        }
        // query params
        if (is_array($payment_type)) {
            $payment_type = ObjectSerializer::serializeCollection($payment_type, 'multi', true);
        }
        if ($payment_type !== null) {
            $queryParams['payment_type'] = ObjectSerializer::toQueryValue($payment_type, null);
        }
        // query params
        if ($invoice !== null) {
            $queryParams['invoice'] = ObjectSerializer::toQueryValue($invoice, null);
        }
        // query params
        if (is_array($currency)) {
            $currency = ObjectSerializer::serializeCollection($currency, 'multi', true);
        }
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency, null);
        }
        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount, null);
        }
        // query params
        if (is_array($card_type)) {
            $card_type = ObjectSerializer::serializeCollection($card_type, 'multi', true);
        }
        if ($card_type !== null) {
            $queryParams['card_type'] = ObjectSerializer::toQueryValue($card_type, null);
        }
        // query params
        if (is_array($transaction_card_type)) {
            $transaction_card_type = ObjectSerializer::serializeCollection($transaction_card_type, 'multi', true);
        }
        if ($transaction_card_type !== null) {
            $queryParams['transaction_card_type'] = ObjectSerializer::toQueryValue($transaction_card_type, null);
        }
        // query params
        if ($card_prefix !== null) {
            $queryParams['card_prefix'] = ObjectSerializer::toQueryValue($card_prefix, null);
        }
        // query params
        if ($card_postfix !== null) {
            $queryParams['card_postfix'] = ObjectSerializer::toQueryValue($card_postfix, null);
        }
        // query params
        if ($card_fingerprint !== null) {
            $queryParams['card_fingerprint'] = ObjectSerializer::toQueryValue($card_fingerprint, null);
        }
        // query params
        if (is_array($card_country)) {
            $card_country = ObjectSerializer::serializeCollection($card_country, 'multi', true);
        }
        if ($card_country !== null) {
            $queryParams['card_country'] = ObjectSerializer::toQueryValue($card_country, null);
        }
        // query params
        if ($card_gateway !== null) {
            $queryParams['card_gateway'] = ObjectSerializer::toQueryValue($card_gateway, null);
        }
        // query params
        if ($payment_method !== null) {
            $queryParams['payment_method'] = ObjectSerializer::toQueryValue($payment_method, null);
        }
        // query params
        if ($card_acquirer_code !== null) {
            $queryParams['card_acquirer_code'] = ObjectSerializer::toQueryValue($card_acquirer_code, null);
        }
        // query params
        if ($card_error_state !== null) {
            $queryParams['card_error_state'] = ObjectSerializer::toQueryValue($card_error_state, null);
        }
        // query params
        if ($card_error !== null) {
            $queryParams['card_error'] = ObjectSerializer::toQueryValue($card_error, null);
        }
        // query params
        if ($payment_context !== null) {
            $queryParams['payment_context'] = ObjectSerializer::toQueryValue($payment_context, null);
        }
        // query params
        if ($card_acquirer_reference !== null) {
            $queryParams['card_acquirer_reference'] = ObjectSerializer::toQueryValue($card_acquirer_reference, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
